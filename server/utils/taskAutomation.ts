/**
 * Utilitaire pour l'automatisation des tâches basées sur les commentaires clients
 */

import { db } from "../../db";
import { tasks, clients } from "../../shared/schema";
import { eq } from "drizzle-orm";
import { extractDatesFromComment, getFarthestDateFromComment, getDefaultDueDate } from "./dateExtraction";

export interface TaskCreationData {
  title: string;
  description: string;
  status: string;
  priority: string;
  dueDate: Date;
  clientId: number;
  userId: number;
  category: string;
  isAutoGenerated: boolean;
  triggerEvent: string;
}

/**
 * Crée automatiquement une tâche basée sur un commentaire client
 * @param clientId ID du client
 * @param userId ID de l'utilisateur créateur
 * @param clientPrenom Prénom du client
 * @param clientNom Nom du client
 * @param commentaire Commentaire du client
 * @returns La tâche créée ou null si pas de commentaire
 */
export async function createTaskFromComment(
  clientId: number,
  userId: number,
  clientPrenom: string,
  clientNom: string,
  commentaire: string
): Promise<any | null> {
  
  // Vérifier si le commentaire existe et n'est pas vide
  if (!commentaire || commentaire.trim() === '') {
    return null;
  }

  // Récupérer le client et son vendeur
  const client = await db
    .select()
    .from(clients)
    .where(eq(clients.id, clientId))
    .limit(1);

  if (client.length === 0) {
    console.error(`❌ Client ${clientId} non trouvé pour création de tâche`);
    return null;
  }

  // Trouver le vendeur du client
  let assignedUserId = userId; // Valeur par défaut
  
  if (client[0].codeVendeur) {
    const vendeur = await db
      .select()
      .from(users)
      .where(eq(users.codeVendeur, client[0].codeVendeur))
      .limit(1);

    if (vendeur.length > 0) {
      assignedUserId = vendeur[0].id;
    }
  }

  // Construire le titre de la tâche
  const taskTitle = `Suivi client: ${clientPrenom} ${clientNom}`;

  // Déterminer la date d'échéance
  let dueDate: Date;
  const extractedDate = getFarthestDateFromComment(commentaire);
  
  if (extractedDate) {
    dueDate = extractedDate;
  } else {
    // Utiliser la date par défaut (48h après création)
    dueDate = getDefaultDueDate();
  }

  // Créer les données de la tâche
  const taskData: TaskCreationData = {
    title: taskTitle,
    description: commentaire, // Afficher la totalité du commentaire
    status: 'pending', // En attente
    priority: 'medium', // Moyenne
    dueDate: dueDate,
    clientId: clientId,
    userId: assignedUserId,
    category: 'suivi', // Catégorie suivi
    isAutoGenerated: true, // Tâche générée automatiquement
    triggerEvent: 'client_comment' // Événement déclencheur
  };

  try {
    // Créer la tâche dans la base de données
    const [createdTask] = await db.insert(tasks).values({
      title: taskData.title,
      description: taskData.description,
      status: taskData.status,
      priority: taskData.priority,
      dueDate: taskData.dueDate,
      clientId: taskData.clientId,
      userId: taskData.userId,
      category: taskData.category,
      isAutoGenerated: taskData.isAutoGenerated,
      triggerEvent: taskData.triggerEvent,
      taskType: 'vendeur' // Marquer comme tâche vendeur
    }).returning();

    console.log(`✅ Tâche créée automatiquement: ${taskTitle} (ID: ${createdTask.id}) assignée à l'utilisateur ${assignedUserId}`);
    return createdTask;
  } catch (error) {
    console.error('❌ Erreur lors de la création de la tâche automatique:', error);
    return null;
  }
}

/**
 * Met à jour toutes les tâches pour les clients existants avec commentaires
 * @returns Nombre de tâches créées
 */
export async function updateAllClientsWithTasks(): Promise<number> {
  try {
    // Récupérer tous les clients avec des commentaires qui n'ont pas encore de tâches automatiques
    const clientsWithComments = await db
      .select({
        id: clients.id,
        prenom: clients.prenom,
        nom: clients.nom,
        commentaire: clients.commentaire,
        user_id: clients.user_id
      })
      .from(clients)
      .where(eq(clients.deletedAt, null)) // Clients non supprimés
      .execute();

    let tasksCreated = 0;

    for (const client of clientsWithComments) {
      // Vérifier si le client a un commentaire
      if (client.commentaire && client.commentaire.trim() !== '') {
        // Vérifier si une tâche automatique existe déjà pour ce client
        const existingTask = await db
          .select()
          .from(tasks)
          .where(eq(tasks.clientId, client.id))
          .where(eq(tasks.isAutoGenerated, true))
          .where(eq(tasks.triggerEvent, 'client_comment'))
          .limit(1)
          .execute();

        // Si aucune tâche automatique n'existe, en créer une
        if (existingTask.length === 0) {
          const createdTask = await createTaskFromComment(
            client.id,
            client.user_id,
            client.prenom || '',
            client.nom || '',
            client.commentaire
          );

          if (createdTask) {
            tasksCreated++;
          }
        }
      }
    }

    console.log(`✅ Mise à jour terminée: ${tasksCreated} tâches créées automatiquement`);
    return tasksCreated;
  } catch (error) {
    console.error('❌ Erreur lors de la mise à jour des tâches:', error);
    return 0;
  }
}

/**
 * Met à jour la tâche d'un client spécifique si son commentaire change
 * @param clientId ID du client
 * @param newComment Nouveau commentaire
 * @returns La tâche mise à jour ou null
 */
export async function updateTaskFromComment(
  clientId: number,
  newComment: string
): Promise<any | null> {
  try {
    // Trouver la tâche automatique existante pour ce client
    const existingTask = await db
      .select()
      .from(tasks)
      .where(eq(tasks.clientId, clientId))
      .where(eq(tasks.isAutoGenerated, true))
      .where(eq(tasks.triggerEvent, 'client_comment'))
      .limit(1)
      .execute();

    if (existingTask.length === 0) {
      return null;
    }

    const task = existingTask[0];

    // Si le nouveau commentaire est vide, ne pas mettre à jour la tâche
    if (!newComment || newComment.trim() === '') {
      return task;
    }

    // Calculer la nouvelle date d'échéance
    let newDueDate: Date;
    const extractedDate = getFarthestDateFromComment(newComment);
    
    if (extractedDate) {
      newDueDate = extractedDate;
    } else {
      // Garder la date existante si pas de nouvelle date dans le commentaire
      newDueDate = task.dueDate || getDefaultDueDate();
    }

    // Mettre à jour la tâche
    const [updatedTask] = await db
      .update(tasks)
      .set({
        description: newComment,
        dueDate: newDueDate,
        updatedAt: new Date()
      })
      .where(eq(tasks.id, task.id))
      .returning();

    console.log(`✅ Tâche mise à jour pour le client ${clientId}: ${task.title}`);
    return updatedTask;
  } catch (error) {
    console.error('❌ Erreur lors de la mise à jour de la tâche:', error);
    return null;
  }
}