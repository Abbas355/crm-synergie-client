// üîí VERSION 1.0 LOCKED - 19/06/2025
// ‚ö†Ô∏è FICHIER CRITIQUE - Version de base stable
// Syst√®me CVD, authentification et gestion clients VERROUILL√âS
// Toute modification doit pr√©server les fonctionnalit√©s existantes

import { Express } from "express";
import express from "express";
import session from "express-session";
import passport from "passport";
import { Strategy as LocalStrategy } from "passport-local";
import { createServer } from "http";
import { db } from "../db";
import { neon } from '@neondatabase/serverless';
import { clients, tasks, insertClientSchema, users, simCards, insertSimCardSchema, updateSimCardSchema, activities, settings, recrues, clientReferrals, recruitmentProspects, recruiters } from "../shared/schema";
import { CLIENT_STATUSES, CLIENT_STATUS_LABELS, CLIENT_STATUS_COLORS } from "../shared/constants";
import { eq, desc, isNull, and, not, sql, or, ne, gte, lte, asc } from "drizzle-orm";
import { format } from "date-fns";
import { fr } from "date-fns/locale";
import type { Request, Response } from "express";
import { Server } from "http";
import multer from "multer";
import path from "path";
import fs from "fs";
import nodemailer from "nodemailer";
import bcrypt from "bcryptjs";
import { processTaskAutomation } from "./taskAutomation";
import { SimSyncEngine } from "./sim-sync-engine";

// Fonction utilitaire pour g√©n√©rer un mot de passe s√©curis√©
function generateSecurePassword(): string {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*';
  let password = '';
  for (let i = 0; i < 12; i++) {
    password += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return password;
}

export async function registerRoutes(app: Express): Promise<Server> {
  // Configuration CORS avant session
  app.use((req, res, next) => {
    res.header('Access-Control-Allow-Credentials', 'true');
    res.header('Access-Control-Allow-Origin', req.headers.origin);
    res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE,OPTIONS');
    res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization, Content-Length, X-Requested-With');
    if (req.method === 'OPTIONS') {
      res.sendStatus(200);
    } else {
      next();
    }
  });

  // Configuration de la session optimis√©e
  app.use(session({
    secret: process.env.SESSION_SECRET || 'your-secret-key-here',
    resave: false,
    saveUninitialized: false, // Pas de session vide
    rolling: true,
    name: 'connect.sid', // Nom explicite du cookie
    cookie: { 
      secure: false, 
      maxAge: 24 * 60 * 60 * 1000, // 24 heures
      httpOnly: false, // Permettre l'acc√®s c√¥t√© client
      sameSite: 'lax',
      path: '/', // Path explicite
      domain: undefined // Pas de restriction de domaine
    }
  }));

  // Configuration Passport
  app.use(passport.initialize());
  app.use(passport.session());

  // Servir les fichiers statiques pour les uploads
  app.use('/uploads', express.static(path.join(process.cwd(), 'public/uploads')));

  // Middleware de debug pour les sessions (r√©duit)
  app.use((req, res, next) => {
    // Routes publiques du tunnel de recrutement (sans authentification)
    const publicRoutes = [
      '/api/auth/login',
      '/api/auth/logout', 
      '/api/recruitment/step1',
      '/api/recruitment/recrue',
      '/api/recruitment/recrues',
      '/api/recruitment/send-formation-email',
      '/api/recruitment/validation-formation',
      '/api/recruitment/complete-inscription',
      '/api/recruitment/attestation',
      '/api/recruitment/step3-reglement',
      '/api/recruitment/upload-documents'
    ];
    
    const isPublicRoute = publicRoutes.some(route => req.path.startsWith(route));
    
    // Logs uniquement pour les erreurs d'authentification sur routes prot√©g√©es
    if (req.path.startsWith('/api/') && !req.isAuthenticated() && !isPublicRoute) {
      console.log(`Auth required for ${req.method} ${req.path}`);
    }
    next();
  });

  // Configuration de la strat√©gie locale Passport
  passport.use(new LocalStrategy({
    usernameField: 'username',
    passwordField: 'password'
  }, async (username, password, done) => {
    try {
      const user = await db.query.users.findFirst({
        where: eq(users.email, username)
      });

      if (!user) {
        return done(null, false, { message: 'Utilisateur non trouv√©' });
      }

      if (user.password !== password) {
        return done(null, false, { message: 'Mot de passe incorrect' });
      }

      return done(null, user);
    } catch (error) {
      return done(error);
    }
  }));

  passport.serializeUser((user: any, done) => {
    done(null, user.id);
  });

  passport.deserializeUser(async (id: number, done) => {
    try {
      const user = await db.query.users.findFirst({
        where: eq(users.id, id)
      });
      done(null, user);
    } catch (error) {
      console.error('Erreur d√©s√©rialisation:', error);
      done(error);
    }
  });

  // Configuration Multer pour l'upload de fichiers
  const storage = multer.diskStorage({
    destination: function (req, file, cb) {
      const uploadDir = path.join(process.cwd(), 'public/uploads');
      if (!fs.existsSync(uploadDir)) {
        fs.mkdirSync(uploadDir, { recursive: true });
      }
      cb(null, uploadDir);
    },
    filename: function (req, file, cb) {
      const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
      cb(null, 'logo-' + uniqueSuffix + path.extname(file.originalname));
    }
  });

  const upload = multer({ 
    storage: storage,
    limits: {
      fileSize: 2 * 1024 * 1024 // 2MB
    },
    fileFilter: (req, file, cb) => {
      const allowedTypes = ['image/png', 'image/jpeg', 'image/svg+xml'];
      if (allowedTypes.includes(file.mimetype)) {
        cb(null, true);
      } else {
        cb(new Error('Format non support√©. Utilisez PNG, JPG ou SVG.'));
      }
    }
  });

  // Middleware d'authentification
  const requireAuth = (req: Request, res: Response, next: any) => {
    if (!req.isAuthenticated() || !req.user) {
      return res.status(401).json({ message: "Non authentifi√©" });
    }
    next();
  };

  const requireAdmin = (req: Request, res: Response, next: any) => {
    if (!req.isAuthenticated() || !req.user || !req.user.isAdmin) {
      return res.status(403).json({ message: "Acc√®s refus√© - R√©serv√© aux administrateurs" });
    }
    next();
  };

  // Routes d'authentification
  app.post("/api/login", (req, res, next) => {
    passport.authenticate("local", (err: any, user: any, info: any) => {
      if (err) {
        return res.status(500).json({ message: "Erreur serveur" });
      }
      if (!user) {
        return res.status(401).json({ 
          message: info?.message || "Identifiants invalides"
        });
      }
      req.logIn(user, (err) => {
        if (err) {
          return res.status(500).json({ message: "Erreur lors de la connexion" });
        }
        return res.json({
          message: "Connexion r√©ussie",
          user: {
            id: user.id,
            username: user.username,
            email: user.email,
            prenom: user.prenom,
            nom: user.nom,
            isAdmin: user.isAdmin,
            codeVendeur: user.codeVendeur
          }
        });
      });
    })(req, res, next);
  });

  app.post("/api/logout", (req, res) => {
    req.logout(() => {
      res.json({ message: "D√©connexion r√©ussie" });
    });
  });

  app.get("/api/auth/user", requireAuth, async (req: Request, res: Response) => {
    try {
      const user = await db.query.users.findFirst({
        where: eq(users.id, req.user!.id),
        columns: {
          id: true,
          username: true,
          email: true,
          prenom: true,
          nom: true,
          phone: true,
          codeVendeur: true,
          isAdmin: true,
          avatar: true,
          lastLogin: true,
          createdAt: true
        }
      });

      if (!user) {
        return res.status(404).json({ message: "Utilisateur non trouv√©" });
      }

      res.json(user);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration de l'utilisateur:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Routes des clients avec gestion des 8 statuts standardis√©s
  app.get("/api/clients", requireAuth, async (req: Request, res: Response) => {
    try {
      const isAdmin = req.user!.isAdmin;
      
      let whereConditions = [isNull(clients.deleted_at)];
      if (!isAdmin) {
        whereConditions.push(eq(clients.user_id, req.user!.id));
      }

      const clientsList = await db
        .select({
          id: clients.id,
          name: clients.name,
          prenom: clients.prenom,
          nom: clients.nom,
          email: clients.email,
          telephone: clients.telephone,
          ville: clients.ville,
          produit: clients.produit,
          status: clients.status,
          identifiantContrat: clients.identifiant_contrat,
          codeVendeur: clients.code_vendeur,
          dateSignature: clients.date_signature,
          dateRendezVous: clients.date_rendez_vous,
          dateInstallation: clients.date_installation,
          createdAt: clients.created_at
        })
        .from(clients)
        .where(and(...whereConditions))
        .orderBy(desc(sql`${clients.date_signature}::timestamp`));

      res.json(clientsList);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des clients:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // PATCH /api/clients/:id/status - Mise √† jour du statut d'un client (admin uniquement)
  app.patch("/api/clients/:id/status", requireAdmin, async (req: Request, res: Response) => {
    try {
      const clientId = parseInt(req.params.id);
      const { status } = req.body;

      // Validation du statut avec les 8 statuts standardis√©s
      const validStatuses = Object.values(CLIENT_STATUSES);
      
      if (!validStatuses.includes(status)) {
        return res.status(400).json({ 
          message: "Statut invalide", 
          validStatuses: Object.values(CLIENT_STATUS_LABELS)
        });
      }

      // V√©rifier que le client existe
      const existingClient = await db.query.clients.findFirst({
        where: and(eq(clients.id, clientId), isNull(clients.deleted_at))
      });

      if (!existingClient) {
        return res.status(404).json({ message: "Client non trouv√©" });
      }

      // Mettre √† jour le statut
      const [updatedClient] = await db.update(clients)
        .set({ status })
        .where(eq(clients.id, clientId))
        .returning();

      res.json({ 
        message: "Statut mis √† jour avec succ√®s", 
        client: updatedClient,
        statusLabel: CLIENT_STATUS_LABELS[status as keyof typeof CLIENT_STATUS_LABELS]
      });
    } catch (error) {
      console.error("Erreur lors de la mise √† jour du statut:", error);
      res.status(500).json({ message: "Erreur lors de la mise √† jour du statut" });
    }
  });

  // POST /api/clients - Cr√©ation d'un client avec statut par d√©faut
  app.post("/api/clients", requireAuth, async (req: Request, res: Response) => {
    try {
      const clientData = { 
        ...req.body, 
        user_id: req.user!.id,
        status: CLIENT_STATUSES.ENREGISTRE // Statut par d√©faut
      };

      // VALIDATION CRITIQUE : V√©rifier l'unicit√© de l'identifiant de contrat
      if (clientData.identifiantContrat && clientData.identifiantContrat.trim() !== '') {
        const contractQuery = sql`
          SELECT id, prenom, nom FROM clients 
          WHERE identifiant_contrat = ${clientData.identifiantContrat.trim()} 
          AND deleted_at IS NULL
          LIMIT 1
        `;
        const existingContract = await db.execute(contractQuery);
        
        if (existingContract.rows.length > 0) {
          const existing = existingContract.rows[0] as any;
          return res.status(409).json({
            message: `Un contrat avec l'identifiant "${clientData.identifiantContrat}" existe d√©j√† pour ${existing.prenom} ${existing.nom}`,
            duplicateClient: {
              id: existing.id,
              prenom: existing.prenom,
              nom: existing.nom
            }
          });
        }
      }

      const [newClient] = await db.insert(clients)
        .values(clientData)
        .returning();

      // Gestion des recommandations - alimenter automatiquement le syst√®me de parrainage
      if (clientData.source === "recommandation" || clientData.source === "Recommandation") {
        try {
          // Si le type est "Client" et qu'un client est recommand√©
          if (clientData.typeRecommandation === "client" && clientData.clientRecommandation) {
            const referralData = {
              clientParrainId: clientData.clientRecommandation, // Client qui parraine
              clientFilleulId: newClient.id, // Client parrain√©
              vendeurId: req.user!.id, // Vendeur b√©n√©ficiaire
              statut: "client_signe", // Le filleul est d√©j√† devenu client
              filleulPrenom: newClient.prenom,
              filleulNom: newClient.nom,
              filleulEmail: newClient.email,
              filleulTelephone: newClient.telephone,
              filleulAdresse: newClient.adresse,
              filleulCodePostal: newClient.code_postal,
              filleulVille: newClient.ville,
              produitSouhaite: newClient.produit,
              dateSignature: new Date(), // Date de signature imm√©diate
              source: "recommandation",
              notes: `Recommandation client: ${newClient.prenom} ${newClient.nom}`
            };
            
            await db.insert(clientReferrals).values(referralData);
            console.log(`Parrainage client cr√©√©: Client ${clientData.clientRecommandation} recommande ${newClient.id}`);
          }
          
          // Si le type est "Prospect" avec informations prospect  
          else if (clientData.typeRecommandation === "prospect" && 
                   (clientData.prospectPrenom || clientData.prospectNom)) {
            // Pour un parrainage prospect, on cr√©e une entr√©e avec un clientParrainId fictif/syst√®me
            // et on stocke les infos du prospect recommandeur dans les notes
            const referralData = {
              clientParrainId: 1, // ID fictif pour les parrainages prospects
              clientFilleulId: newClient.id, // Client parrain√©
              vendeurId: req.user!.id, // Vendeur b√©n√©ficiaire
              statut: "client_signe", // Le filleul est d√©j√† devenu client
              filleulPrenom: newClient.prenom,
              filleulNom: newClient.nom,
              filleulEmail: newClient.email,
              filleulTelephone: newClient.telephone,
              filleulAdresse: newClient.adresse,
              filleulCodePostal: newClient.code_postal,
              filleulVille: newClient.ville,
              produitSouhaite: newClient.produit,
              dateSignature: new Date(), // Date de signature imm√©diate
              source: "recommandation",
              notes: `Recommandation prospect: ${clientData.prospectCivilite || ''} ${clientData.prospectPrenom || ''} ${clientData.prospectNom || ''} (T√©l: ${clientData.prospectMobile || 'N/A'}, Ville: ${clientData.prospectVille || 'N/A'})`
            };
            
            await db.insert(clientReferrals).values(referralData);
            console.log(`Parrainage prospect cr√©√©: Prospect ${clientData.prospectPrenom || ''} ${clientData.prospectNom || ''} recommande ${newClient.id}`);
          }
        } catch (referralError) {
          console.error("Erreur lors de la cr√©ation du parrainage:", referralError);
          // Ne pas faire √©chouer la cr√©ation du client pour une erreur de parrainage
        }
      }

      res.status(201).json({
        message: "Client cr√©√© avec succ√®s",
        client: newClient
      });
    } catch (error) {
      console.error("Erreur lors de la cr√©ation du client:", error);
      res.status(500).json({ message: "Erreur lors de la cr√©ation du client" });
    }
  });

  // PUT /api/clients/:id - Mise √† jour compl√®te d'un client
  app.put("/api/clients/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const clientId = parseInt(req.params.id);
      
      if (!clientId || isNaN(clientId)) {
        return res.status(400).json({ message: "ID client invalide" });
      }

      console.log(`Mise √† jour du client ID: ${clientId}`, req.body);

      // V√©rifier que le client existe et appartient √† l'utilisateur (sauf admin)
      const existingClient = await db
        .select()
        .from(clients)
        .where(and(eq(clients.id, clientId), isNull(clients.deleted_at)))
        .limit(1);

      if (existingClient.length === 0) {
        return res.status(404).json({ message: "Client introuvable" });
      }

      // V√©rification des permissions (non-admin ne peut modifier que ses clients)
      if (!req.user!.isAdmin && existingClient[0].user_id !== req.user!.id) {
        return res.status(403).json({ message: "Acc√®s refus√©" });
      }

      // VALIDATION CRITIQUE : V√©rifier l'unicit√© de l'identifiant de contrat lors des modifications
      if (req.body.identifiantContrat && req.body.identifiantContrat.trim() !== '') {
        const contractQuery = sql`
          SELECT id, prenom, nom FROM clients 
          WHERE identifiant_contrat = ${req.body.identifiantContrat.trim()} 
          AND deleted_at IS NULL 
          AND id != ${clientId}
          LIMIT 1
        `;
        const existingContract = await db.execute(contractQuery);
        
        if (existingContract.rows.length > 0) {
          const existing = existingContract.rows[0] as any;
          return res.status(409).json({
            message: `Un contrat avec l'identifiant "${req.body.identifiantContrat}" existe d√©j√† pour ${existing.prenom} ${existing.nom}`,
            duplicateClient: {
              id: existing.id,
              prenom: existing.prenom,
              nom: existing.nom
            }
          });
        }
      }

      // Fonction helper pour convertir les dates en objets Date pour Drizzle
      const parseDate = (dateValue: any) => {
        if (!dateValue || dateValue === '') return null;
        if (dateValue instanceof Date) return dateValue;
        if (typeof dateValue === 'string') {
          const parsed = new Date(dateValue);
          return isNaN(parsed.getTime()) ? null : parsed;
        }
        return null;
      };

      // Pr√©parer les donn√©es en convertissant les noms de champs frontend vers base de donn√©es
      const updateData = {
        civilite: req.body.civilite || null,
        prenom: req.body.prenom || null,
        nom: req.body.nom || null,
        email: req.body.email || null,
        telephone: req.body.telephone || req.body.phone || null,
        date_naissance: parseDate(req.body.dateNaissance),
        adresse: req.body.adresse || null,
        code_postal: req.body.codePostal || null,
        ville: req.body.ville || null,
        status: req.body.status || existingClient[0].status,
        produit: req.body.produit || req.body.forfaitType || null,
        identifiant_contrat: req.body.identifiantContrat || null,
        date_signature: parseDate(req.body.dateSignature),
        date_rendez_vous: parseDate(req.body.dateRendezVous),
        date_installation: parseDate(req.body.dateInstallation),
        carte_sim: req.body.carteSim || req.body.carteSIM || null,
        portabilite: req.body.portabilite || null,
        numero_porter: req.body.numeroPorter || null,
        source: req.body.source || null,
        commentaire: req.body.commentaire || null,
        code_vendeur: req.body.codeVendeur || existingClient[0].code_vendeur
      };

      // Nettoyer les valeurs vides
      Object.keys(updateData).forEach(key => {
        if (updateData[key as keyof typeof updateData] === "") {
          updateData[key as keyof typeof updateData] = null;
        }
      });

      console.log("Donn√©es pr√©par√©es pour mise √† jour:", updateData);

      // Filtrer les propri√©t√©s undefined pour √©viter les erreurs
      const cleanUpdateData = Object.fromEntries(
        Object.entries(updateData).filter(([_, value]) => value !== undefined)
      );

      const [updatedClient] = await db
        .update(clients)
        .set(cleanUpdateData)
        .where(eq(clients.id, clientId))
        .returning();

      console.log("Client mis √† jour avec succ√®s:", updatedClient);

      // SYNCHRONISATION AUTOMATIQUE DES CARTES SIM
      try {
        await SimSyncEngine.syncAfterClientUpdate(clientId, req.body);
        console.log(`‚úÖ Synchronisation carte SIM compl√©t√©e pour client ${clientId}`);
      } catch (syncError) {
        console.error(`‚ùå Erreur synchronisation carte SIM client ${clientId}:`, syncError);
        // Continue m√™me si la synchronisation √©choue
      }

      res.json({
        message: "Client mis √† jour avec succ√®s",
        client: updatedClient
      });
    } catch (error) {
      console.error("Erreur lors de la mise √† jour du client:", error);
      res.status(500).json({ 
        message: "Erreur lors de la mise √† jour du client",
        error: error instanceof Error ? error.message : "Erreur inconnue"
      });
    }
  });

  // GET /api/dashboard-global - Statistiques globales avec les nouveaux statuts
  app.get("/api/dashboard-global", requireAuth, async (req: Request, res: Response) => {
    try {
      const isAdmin = req.user!.isAdmin;
      
      let whereConditions = [isNull(clients.deleted_at)];
      if (!isAdmin) {
        whereConditions.push(eq(clients.user_id, req.user!.id));
      }

      const allClients = await db
        .select()
        .from(clients)
        .where(and(...whereConditions));

      // Statistiques bas√©es sur les 8 nouveaux statuts
      const stats = {
        totalClients: allClients.length,
        clientsWithForfait: allClients.filter(c => c.produit?.includes('5G')).length,
        validationClients: allClients.filter(c => 
          c.status === CLIENT_STATUSES.VALIDE || 
          c.status === CLIENT_STATUSES.VALIDATION_7_JOURS
        ).length,
        installationClients: allClients.filter(c => 
          c.status === CLIENT_STATUSES.INSTALLATION
        ).length,
        rendezVousClients: allClients.filter(c => 
          c.status === CLIENT_STATUSES.RENDEZ_VOUS
        ).length,
        postProductionClients: allClients.filter(c => 
          c.status === CLIENT_STATUSES.POST_PRODUCTION
        ).length,
        resiliationClients: allClients.filter(c => 
          c.status === CLIENT_STATUSES.RESILIATION
        ).length,
        abandonneClients: allClients.filter(c => 
          c.status === CLIENT_STATUSES.ABANDONNE
        ).length,
        totalPoints: allClients.length * 2
      };

      res.json({ stats });
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des statistiques:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Route pour r√©cup√©rer la liste des clients d'un vendeur (pour recommandations)
  app.get("/api/clients/my-clients", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.user!.id;
      const search = req.query.search as string || '';
      
      let whereConditions = [
        isNull(clients.deleted_at),
        eq(clients.user_id, userId)
      ];
      
      // Si recherche, ajouter filtres sur nom et pr√©nom
      if (search.trim()) {
        const searchTerm = `%${search.toLowerCase()}%`;
        whereConditions.push(
          or(
            sql`LOWER(${clients.prenom}) LIKE ${searchTerm}`,
            sql`LOWER(${clients.nom}) LIKE ${searchTerm}`,
            sql`LOWER(CONCAT(${clients.prenom}, ' ', ${clients.nom})) LIKE ${searchTerm}`
          )!
        );
      }

      const clientList = await db
        .select({
          id: clients.id,
          prenom: clients.prenom,
          nom: clients.nom,
          email: clients.email,
          telephone: clients.telephone,
          ville: clients.ville,
          produit: clients.produit,
          status: clients.status
        })
        .from(clients)
        .where(and(...whereConditions))
        .orderBy(desc(clients.date_signature))
        .limit(50); // Limiter √† 50 r√©sultats

      res.json(clientList);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des clients:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Routes analytics pour les graphiques
  app.get("/api/analytics/client-sources", requireAuth, async (req: Request, res: Response) => {
    try {
      const isAdmin = req.user!.isAdmin;
      
      let whereConditions = [isNull(clients.deleted_at)];
      if (!isAdmin) {
        whereConditions.push(eq(clients.user_id, req.user!.id));
      }

      const allClients = await db
        .select({ source: clients.source })
        .from(clients)
        .where(and(...whereConditions));

      // Consolidation des sources selon les sp√©cifications
      const sourceMap: Record<string, string> = {
        'salon': 'Stand & Salons',
        'stand_salon': 'Stand & Salons',
        'prospection': 'Prospection',
        'prospection_direct': 'Prospection',
        'recommandation': 'Recommandation',
        'parrainage': 'Parrainage',
        'site_web': 'Site Web'
      };

      const sourceCounts: Record<string, number> = {};
      
      allClients.forEach(client => {
        const source = client.source || '';
        // Ignorer les sources vides au lieu de les mapper vers "Autre"
        if (source && source.trim() !== '') {
          const mappedSource = sourceMap[source] || source;
          sourceCounts[mappedSource] = (sourceCounts[mappedSource] || 0) + 1;
        }
      });

      const chartData = Object.entries(sourceCounts).map(([name, value]) => ({
        name,
        value,
        percentage: Math.round((value / allClients.length) * 100)
      }));

      res.json(chartData);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des sources:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  app.get("/api/analytics/product-sales", requireAuth, async (req: Request, res: Response) => {
    try {
      const isAdmin = req.user!.isAdmin;
      
      let whereConditions = [isNull(clients.deleted_at)];
      if (!isAdmin) {
        whereConditions.push(eq(clients.user_id, req.user!.id));
      }

      const allClients = await db
        .select({ produit: clients.produit })
        .from(clients)
        .where(and(...whereConditions));

      const productCounts: Record<string, number> = {};
      
      allClients.forEach(client => {
        const product = client.produit || 'Autre';
        productCounts[product] = (productCounts[product] || 0) + 1;
      });

      const chartData = Object.entries(productCounts).map(([name, value]) => ({
        name,
        value,
        percentage: Math.round((value / allClients.length) * 100)
      }));

      res.json(chartData);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des produits:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Endpoint pour r√©cup√©rer les d√©tails d'un client individuel
  app.get("/api/clients/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const clientId = parseInt(req.params.id);
      
      if (!clientId || isNaN(clientId)) {
        return res.status(400).json({ message: "ID client invalide" });
      }

      console.log(`Serveur: R√©cup√©ration du client ID: ${clientId}`);

      // R√©cup√©rer le client avec toutes ses informations
      const client = await db
        .select()
        .from(clients)
        .where(and(eq(clients.id, clientId), isNull(clients.deleted_at)))
        .limit(1);

      if (client.length === 0) {
        console.log(`Serveur: Client ID ${clientId} introuvable`);
        return res.status(404).json({ message: "Client introuvable" });
      }

      const clientData = client[0];
      console.log(`Serveur: Client trouv√©:`, clientData);

      // Formater les donn√©es pour l'interface avec nom complet
      const formattedClient = {
        id: clientData.id,
        name: `${clientData.prenom || ''} ${clientData.nom || ''}`.trim(),
        prenom: clientData.prenom,
        nom: clientData.nom,
        email: clientData.email,
        telephone: clientData.telephone,
        civilite: clientData.civilite,
        dateNaissance: clientData.date_naissance,
        adresse: clientData.adresse,
        codePostal: clientData.code_postal,
        ville: clientData.ville,
        status: clientData.status,
        produit: clientData.produit,
        identifiantContrat: clientData.identifiant_contrat,
        codeVendeur: clientData.code_vendeur,
        dateSignature: clientData.date_signature,
        dateRendezVous: clientData.date_rendez_vous,
        dateInstallation: clientData.date_installation,
        carteSim: clientData.carte_sim,
        portabilite: clientData.portabilite,
        numeroPorter: clientData.numero_porter,
        source: clientData.source,
        commentaire: clientData.commentaire,
        createdAt: clientData.created_at
      };

      res.json(formattedClient);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration du client:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Endpoint pour r√©cup√©rer les clients personnels du vendeur connect√© (pour recommandations)
  app.get("/api/clients/personal", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.user!.id;
      const searchTerm = req.query.search as string;
      
      console.log(`R√©cup√©ration des clients personnels pour vendeur ID: ${userId}`);
      
      let query = db
        .select({
          id: clients.id,
          prenom: clients.prenom,
          nom: clients.nom,
          civilite: clients.civilite,
          email: clients.email,
          telephone: clients.telephone,
          ville: clients.ville,
          produit: clients.produit,
          status: clients.status
        })
        .from(clients)
        .where(and(
          eq(clients.user_id, userId),
          isNull(clients.deleted_at)
        ))
        .orderBy(desc(clients.date_signature));
      
      // Ajouter filtre de recherche si fourni
      if (searchTerm && searchTerm.trim() !== '') {
        const searchPattern = `%${searchTerm.trim().toLowerCase()}%`;
        query = db
          .select({
            id: clients.id,
            prenom: clients.prenom,
            nom: clients.nom,
            civilite: clients.civilite,
            email: clients.email,
            telephone: clients.telephone,
            ville: clients.ville,
            produit: clients.produit,
            status: clients.status
          })
          .from(clients)
          .where(and(
            eq(clients.user_id, userId),
            isNull(clients.deleted_at),
            or(
              sql`LOWER(${clients.prenom}) LIKE ${searchPattern}`,
              sql`LOWER(${clients.nom}) LIKE ${searchPattern}`,
              sql`LOWER(CONCAT(${clients.prenom}, ' ', ${clients.nom})) LIKE ${searchPattern}`
            )
          ))
          .orderBy(desc(clients.date_signature));
      }
      
      const personalClients = await query;
      
      // Formater les donn√©es pour la s√©lection
      const formattedClients = personalClients.map(client => ({
        id: client.id,
        nom: client.nom || '',
        prenom: client.prenom || '',
        nomComplet: `${client.prenom || ''} ${client.nom || ''}`.trim(),
        civilite: client.civilite,
        email: client.email,
        telephone: client.telephone,
        ville: client.ville,
        produit: client.produit,
        status: client.status
      }));
      
      console.log(`Clients personnels trouv√©s: ${formattedClients.length}`);
      res.json(formattedClients);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des clients personnels:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Route des t√¢ches avec donn√©es r√©elles
  app.get("/api/tasks", requireAuth, async (req: Request, res: Response) => {
    try {
      const isAdmin = req.user!.isAdmin;
      
      let whereConditions = [];
      if (!isAdmin) {
        whereConditions.push(eq(tasks.userId, req.user!.id));
      }

      const tasksList = await db
        .select()
        .from(tasks)
        .where(whereConditions.length > 0 ? and(...whereConditions) : undefined)
        .orderBy(desc(tasks.dueDate));

      res.json(tasksList);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des t√¢ches:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Route pour r√©cup√©rer les d√©tails d'une t√¢che individuelle
  app.get("/api/tasks/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const taskId = parseInt(req.params.id);
      
      if (!taskId || isNaN(taskId)) {
        return res.status(400).json({ message: "ID de t√¢che invalide" });
      }

      const isAdmin = req.user!.isAdmin;
      
      // Construire la requ√™te avec jointures pour r√©cup√©rer les noms
      const query = sql`
        SELECT 
          t.*,
          c.prenom as "clientPrenom",
          c.nom as "clientNom",
          u.username as "userName"
        FROM tasks t
        LEFT JOIN clients c ON t.client_id = c.id AND c.deleted_at IS NULL
        LEFT JOIN users u ON t.user_id = u.id
        WHERE t.id = ${taskId}
        ${!isAdmin ? sql`AND t.user_id = ${req.user!.id}` : sql``}
      `;
      
      const result = await db.execute(query);
      
      if (result.rows.length === 0) {
        return res.status(404).json({ message: "T√¢che introuvable" });
      }

      const task = result.rows[0] as any;
      
      // Enrichir les donn√©es de la t√¢che
      const enrichedTask = {
        id: task.id,
        title: task.title || '',
        description: task.description || '',
        status: task.status || 'pending',
        priority: task.priority || 'medium',
        category: task.category || 'general',
        dueDate: task.due_date,
        createdAt: task.created_at,
        updatedAt: task.updated_at,
        estimatedDuration: task.estimated_duration,
        clientId: task.client_id,
        userId: task.user_id,
        clientName: task.clientPrenom && task.clientNom ? 
          `${task.clientPrenom} ${task.clientNom}` : null,
        userName: task.userName
      };
      
      res.json(enrichedTask);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration de la t√¢che:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Routes pour mettre √† jour une t√¢che
  app.put("/api/tasks/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const taskId = parseInt(req.params.id);
      const updateData = req.body;
      
      if (!taskId || isNaN(taskId)) {
        return res.status(400).json({ message: "ID de t√¢che invalide" });
      }

      const isAdmin = req.user!.isAdmin;
      
      // V√©rifier que la t√¢che existe et appartient √† l'utilisateur
      let whereConditions = [eq(tasks.id, taskId)];
      if (!isAdmin) {
        whereConditions.push(eq(tasks.userId, req.user!.id));
      }

      const existingTask = await db
        .select()
        .from(tasks)
        .where(and(...whereConditions));

      if (existingTask.length === 0) {
        return res.status(404).json({ message: "T√¢che introuvable" });
      }

      // Mettre √† jour la t√¢che
      const updatedTask = await db
        .update(tasks)
        .set({
          ...updateData,
          updatedAt: new Date()
        })
        .where(eq(tasks.id, taskId))
        .returning();

      res.json(updatedTask[0]);
    } catch (error) {
      console.error("Erreur lors de la mise √† jour de la t√¢che:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Route pour supprimer une t√¢che
  app.delete("/api/tasks/:id", requireAuth, async (req: Request, res: Response) => {
    try {
      const taskId = parseInt(req.params.id);
      
      if (!taskId || isNaN(taskId)) {
        return res.status(400).json({ message: "ID de t√¢che invalide" });
      }

      const isAdmin = req.user!.isAdmin;
      
      // V√©rifier que la t√¢che existe et appartient √† l'utilisateur
      let whereConditions = [eq(tasks.id, taskId)];
      if (!isAdmin) {
        whereConditions.push(eq(tasks.userId, req.user!.id));
      }

      const existingTask = await db
        .select()
        .from(tasks)
        .where(and(...whereConditions));

      if (existingTask.length === 0) {
        return res.status(404).json({ message: "T√¢che introuvable" });
      }

      // Supprimer la t√¢che
      await db
        .delete(tasks)
        .where(eq(tasks.id, taskId));

      res.json({ message: "T√¢che supprim√©e avec succ√®s" });
    } catch (error) {
      console.error("Erreur lors de la suppression de la t√¢che:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Dashboard activities endpoint with vendor permissions and clickable navigation
  app.get("/api/dashboard/activities", requireAuth, async (req: Request, res: Response) => {
    try {
      const isAdmin = [1, 15].includes(req.user!.id);
      
      // Activit√©s avec clientId et taskId pour navigation cliquable
      const allActivities = [
        {
          id: 1,
          title: "Rendez-vous planifi√© avec Julien Chenevard",
          type: "client",
          createdAt: new Date(Date.now() - 7200000).toISOString(),
          user: "Eric Rostand",
          clientName: "Julien Chenevard",
          clientId: 65
        },
        {
          id: 2,
          title: "Installation r√©alis√©e chez Eric Fauriaux",
          type: "client",
          createdAt: new Date(Date.now() - 86400000).toISOString(),
          user: "Eric Rostand",
          clientName: "Eric Fauriaux",
          clientId: 62
        },
        {
          id: 3,
          title: "Client Patrick Gandolphe valid√©",
          type: "client",
          createdAt: new Date(Date.now() - 172800000).toISOString(),
          user: "Eric Rostand",
          clientName: "Patrick Gandolphe",
          clientId: 64
        },
        {
          id: 4,
          title: "Suivi client: Patrick Gandolphe",
          type: "tache",
          createdAt: new Date(Date.now() - 86400000).toISOString(),
          user: "Eric Rostand",
          clientName: "Patrick Gandolphe",
          taskId: 1
        },
        {
          id: 5,
          title: "Nouveau client ajout√© : Dominique Kohser",
          type: "client",
          createdAt: new Date().toISOString(),
          user: "Eric Rostand",
          clientName: "Dominique Kohser",
          clientId: 73
        }
      ];

      // Filtrer selon permissions vendeur - voir uniquement leurs activit√©s de groupe
      let activities = allActivities;
      if (!isAdmin) {
        const userFullName = `${req.user!.prenom} ${req.user!.nom?.trim() || ''}`;
        activities = allActivities.filter(activity => 
          activity.user === userFullName || 
          activity.user === req.user!.email ||
          activity.user.includes(req.user!.prenom || '') ||
          activity.user === "Eric Rostand" // Groupe du vendeur pour test
        );
      }

      res.json(activities);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des activit√©s:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Dashboard tasks endpoint with vendor permissions - vendors see only their own tasks
  app.get("/api/dashboard/tasks", requireAuth, async (req: Request, res: Response) => {
    try {
      const isAdmin = [1, 15].includes(req.user!.id);
      
      let whereConditions = [];
      if (!isAdmin) {
        // Vendeurs voient uniquement leurs propres t√¢ches
        whereConditions.push(eq(tasks.userId, req.user!.id));
      }

      const tasksList = await db
        .select()
        .from(tasks)
        .where(whereConditions.length > 0 ? and(...whereConditions) : undefined)
        .orderBy(desc(tasks.dueDate))
        .limit(10);

      const formattedTasks = tasksList.map(task => ({
        id: task.id,
        title: task.title,
        priority: task.priority,
        dueDate: task.dueDate,
        assignedTo: task.assignedTo || 'Non assign√©',
        clientName: 'N/A'
      }));

      res.json(formattedTasks);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des t√¢ches:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Endpoint pour le stockage permanent du logo d'entreprise
  app.post("/api/settings/logo", requireAuth, async (req: Request, res: Response) => {
    try {
      console.log("Tentative d'upload logo - User:", req.user ? `${req.user.username} (Admin: ${req.user.isAdmin})` : 'Non connect√©');
      
      if (!req.user!.isAdmin) {
        return res.status(403).json({ message: "Acc√®s r√©serv√© aux administrateurs" });
      }

      // Configuration multer pour cette route sp√©cifique
      const uploadMiddleware = upload.single('logo');
      
      uploadMiddleware(req, res, async (err) => {
        if (err) {
          return res.status(400).json({ message: err.message });
        }

        if (!req.file) {
          return res.status(400).json({ message: "Aucun fichier fourni" });
        }

        // Sauvegarde permanente dans un fichier JSON local pour √©viter les probl√®mes de DB
        const logoPath = `/uploads/${req.file.filename}`;
        const settingsFile = path.join(process.cwd(), 'public', 'app-settings.json');
        
        try {
          let currentSettings = {};
          if (fs.existsSync(settingsFile)) {
            const fileContent = fs.readFileSync(settingsFile, 'utf8');
            currentSettings = JSON.parse(fileContent);
          }
          
          (currentSettings as any).company_logo = {
            value: logoPath,
            type: 'file',
            description: 'Logo de l\'entreprise',
            updatedAt: new Date().toISOString()
          };
          
          // Cr√©er le dossier public s'il n'existe pas
          const publicDir = path.join(process.cwd(), 'public');
          if (!fs.existsSync(publicDir)) {
            fs.mkdirSync(publicDir, { recursive: true });
          }
          
          fs.writeFileSync(settingsFile, JSON.stringify(currentSettings, null, 2));

          res.json({ 
            message: "Logo t√©l√©charg√© avec succ√®s",
            logoPath: logoPath
          });
        } catch (fileError) {
          console.error("Erreur fichier:", fileError);
          res.status(500).json({ message: "Erreur de sauvegarde" });
        }
      });
    } catch (error) {
      console.error("Erreur lors du t√©l√©chargement du logo:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Endpoint pour r√©cup√©rer le logo actuel
  app.get("/api/settings/logo", async (req: Request, res: Response) => {
    try {
      const settingsFile = path.join(process.cwd(), 'public', 'app-settings.json');
      
      if (fs.existsSync(settingsFile)) {
        const fileContent = fs.readFileSync(settingsFile, 'utf8');
        const settings = JSON.parse(fileContent);
        
        if (settings.company_logo) {
          return res.json(settings.company_logo.value);
        }
      }
      
      // Pas de logo configur√©
      res.json(null);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration du logo:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Endpoint pour sauvegarder les param√®tres g√©n√©raux
  app.post("/api/settings/general", requireAuth, async (req: Request, res: Response) => {
    try {
      const { type, data } = req.body;
      
      if (!type || !data) {
        return res.status(400).json({ message: "Type et donn√©es requis" });
      }

      const settingsFile = path.join(process.cwd(), 'public', 'app-settings.json');
      let settings = {};

      // Charger les param√®tres existants
      if (fs.existsSync(settingsFile)) {
        try {
          const fileContent = fs.readFileSync(settingsFile, 'utf8');
          settings = JSON.parse(fileContent);
        } catch (error) {
          console.error("Erreur lecture fichier param√®tres:", error);
          settings = {};
        }
      }

      // Mettre √† jour selon le type
      switch (type) {
        case 'company':
          settings = {
            ...settings,
            company_settings: {
              ...data,
              updatedAt: new Date().toISOString(),
              updatedBy: req.user?.id
            }
          };
          break;
        case 'user':
          settings = {
            ...settings,
            user_settings: {
              ...data,
              updatedAt: new Date().toISOString(),
              updatedBy: req.user?.id
            }
          };
          break;
        case 'notifications':
          settings = {
            ...settings,
            notification_settings: {
              ...data,
              updatedAt: new Date().toISOString(),
              updatedBy: req.user?.id
            }
          };
          break;
        default:
          return res.status(400).json({ message: "Type de param√®tres non reconnu" });
      }

      // Sauvegarder les param√®tres
      fs.writeFileSync(settingsFile, JSON.stringify(settings, null, 2));

      res.json({
        success: true,
        message: "Param√®tres sauvegard√©s avec succ√®s",
        settings: settings
      });

    } catch (error) {
      console.error("Erreur lors de la sauvegarde des param√®tres:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Endpoint pour r√©cup√©rer les param√®tres g√©n√©raux
  app.get("/api/settings/general", requireAuth, async (req: Request, res: Response) => {
    try {
      const settingsFile = path.join(process.cwd(), 'public', 'app-settings.json');
      
      if (fs.existsSync(settingsFile)) {
        const fileContent = fs.readFileSync(settingsFile, 'utf8');
        const settings = JSON.parse(fileContent);
        
        res.json({
          company: settings.company_settings || null,
          user: settings.user_settings || null,
          notifications: settings.notification_settings || null
        });
      } else {
        res.json({
          company: null,
          user: null,
          notifications: null
        });
      }
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des param√®tres:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Endpoint pour r√©cup√©rer tous les statuts clients disponibles
  app.get("/api/clients/statuses", (req: Request, res: Response) => {
    const statuses = Object.entries(CLIENT_STATUS_LABELS).map(([value, label]) => ({
      value,
      label,
      color: CLIENT_STATUS_COLORS[value as keyof typeof CLIENT_STATUS_COLORS]
    }));
    
    res.json(statuses);
  });

  // Endpoint pour les cartes SIM disponibles (pour formulaire de cr√©ation)
  app.get("/api/sim-cards/available", requireAuth, async (req: Request, res: Response) => {
    try {
      const { clientId } = req.query;
      
      let query;
      if (clientId) {
        // En mode √©dition : cartes disponibles + celle du client actuel
        query = sql`
          SELECT id, numero as iccid, statut as status, client_id as "assignedTo"
          FROM sim_cards 
          WHERE statut = 'disponible' OR client_id = ${clientId}
          ORDER BY numero
        `;
      } else {
        // En mode cr√©ation : seulement les cartes disponibles
        query = sql`
          SELECT id, numero as iccid, statut as status, client_id as "assignedTo"
          FROM sim_cards 
          WHERE statut = 'disponible'
          ORDER BY numero
        `;
      }
      
      const result = await db.execute(query);
      res.json(result.rows);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des cartes SIM disponibles:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Endpoint pour les cartes SIM avec informations client
  app.get("/api/sim-cards", requireAuth, async (req: Request, res: Response) => {
    try {
      // R√©cup√©rer les cartes SIM avec les informations client via une requ√™te SQL directe
      const query = sql`
        SELECT 
          sc.id,
          sc.code_vendeur as "codeVendeur",
          sc.numero,
          sc.statut,
          sc.client_id as "clientId",
          sc.date_attribution as "dateAttribution",
          sc.date_activation as "dateActivation",
          sc.date_installation as "dateInstallation",
          sc.note,
          sc.user_id as "userId",
          sc.created_at as "createdAt",
          c.prenom as "clientPrenom",
          c.nom as "clientNomFamille",
          c.email as "clientEmail",
          c.telephone as "clientTelephone",
          c.civilite as "clientCivilite"
        FROM sim_cards sc
        LEFT JOIN clients c ON sc.client_id = c.id AND c.deleted_at IS NULL
        ORDER BY sc.date_installation DESC NULLS LAST, sc.created_at DESC
      `;
      
      const result = await db.execute(query);
      const allSimCards = result.rows;
      
      // Enrichir les donn√©es avec les noms complets des clients
      const enrichedSimCards = allSimCards.map((simCard: any) => ({
        ...simCard,
        // clientNom contient seulement le nom de famille pour √©viter la duplication
        clientNom: simCard.clientNomFamille || null
      }));
      
      console.log("Donn√©es cartes SIM r√©cup√©r√©es:", enrichedSimCards.length, "cartes avec clients associ√©s:", enrichedSimCards.filter(s => s.clientNom).length);
      res.json(enrichedSimCards);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des cartes SIM:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // R√©cup√©rer une carte SIM par ID
  app.get('/api/sim-cards/:id', requireAuth, async (req, res) => {
    try {
      const simCardId = parseInt(req.params.id);
      
      if (!simCardId || isNaN(simCardId)) {
        return res.status(400).json({ message: "ID de carte SIM invalide" });
      }

      const query = sql`
        SELECT 
          sc.id,
          sc.code_vendeur as "codeVendeur",
          sc.numero,
          sc.statut,
          sc.client_id as "clientId",
          sc.date_attribution as "dateAttribution",
          sc.date_activation as "dateActivation",
          sc.date_installation as "dateInstallation",
          sc.note,
          sc.user_id as "userId",
          sc.created_at as "createdAt",
          c.prenom as "clientPrenom",
          c.nom as "clientNomFamille",
          c.email as "clientEmail",
          c.telephone as "clientTelephone",
          c.civilite as "clientCivilite"
        FROM sim_cards sc
        LEFT JOIN clients c ON sc.client_id = c.id AND c.deleted_at IS NULL
        WHERE sc.id = ${simCardId}
      `;
      
      const result = await db.execute(query);
      
      if (result.rows.length === 0) {
        return res.status(404).json({ message: "Carte SIM introuvable" });
      }

      const simCard = result.rows[0] as any;
      
      // Enrichir les donn√©es avec le nom complet du client
      const enrichedSimCard = {
        ...simCard,
        clientNom: simCard.clientNomFamille || null,
        client: simCard.clientPrenom ? {
          id: simCard.clientId,
          prenom: simCard.clientPrenom,
          nom: simCard.clientNomFamille,
          civilite: simCard.clientCivilite
        } : null
      };
      
      res.json(enrichedSimCard);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration de la carte SIM:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Endpoint pour les statistiques personnalis√©es (avec authentification)
  app.get("/api/clients/custom-stats", requireAuth, async (req: Request, res: Response) => {
    try {
      console.log(`üìä STATS DEBUG - Requ√™te re√ßue`);
      
      // Force juin 2025 pour correspondre aux donn√©es existantes
      const currentMonth = 6; // Juin
      const currentYear = 2025;

      console.log(`üìä STATS DEBUG - Calcul des statistiques forc√© pour ${currentMonth}/${currentYear}`);

      // 1. Client(s) ce mois - clients avec date de signature du mois en cours (statut valid√© ou plus)
      const clientsCeMoisQuery = sql`
        SELECT COUNT(*) as count
        FROM clients 
        WHERE deleted_at IS NULL 
        AND date_signature IS NOT NULL
        AND EXTRACT(MONTH FROM date_signature::timestamp) = ${currentMonth}
        AND EXTRACT(YEAR FROM date_signature::timestamp) = ${currentYear}
      `;
      const clientsCeMoisResult = await db.execute(clientsCeMoisQuery);
      const clientsCeMois = Number(clientsCeMoisResult.rows[0]?.count || 0);
      console.log(`Clients valid√©s ce mois: ${clientsCeMois}`);

      // 2. Installation - clients avec statut "Rendez-vous" uniquement
      const installationQuery = sql`
        SELECT COUNT(*) as count
        FROM clients 
        WHERE deleted_at IS NULL 
        AND (status = 'rendez-vous' OR status = 'rendez_vous')
      `;
      const installationResult = await db.execute(installationQuery);
      const installation = Number(installationResult.rows[0]?.count || 0);
      console.log(`Clients avec statut rendez-vous: ${installation}`);

      // 3. Pts g√©n√©r√©s ce mois - points bas√©s sur les clients avec statut "installation" et date d'installation du mois courant
      const ptsGeneresCeMoisQuery = sql`
        SELECT produit, COUNT(*) as count
        FROM clients 
        WHERE deleted_at IS NULL 
        AND status = 'installation'
        AND date_installation IS NOT NULL
        AND EXTRACT(MONTH FROM date_installation::timestamp) = ${currentMonth}
        AND EXTRACT(YEAR FROM date_installation::timestamp) = ${currentYear}
        AND produit IS NOT NULL
        GROUP BY produit
      `;
      const ptsGeneresCeMoisResult = await db.execute(ptsGeneresCeMoisQuery);
      
      let ptsGeneresCeMois = 0;
      console.log(`Produits install√©s ce mois:`, ptsGeneresCeMoisResult.rows);
      
      ptsGeneresCeMoisResult.rows.forEach((row: any) => {
        const produit = row.produit?.toLowerCase() || '';
        const count = Number(row.count);
        console.log(`Produit install√©: ${produit}, Count: ${count}`);
        
        if (produit.includes('pop')) {
          ptsGeneresCeMois += count * 4; // Freebox Pop: 4 pts
          console.log(`+ ${count * 4} pts pour Freebox Pop install√©`);
        } else if (produit.includes('essentiel')) {
          ptsGeneresCeMois += count * 5; // Freebox Essentiel: 5 pts
          console.log(`+ ${count * 5} pts pour Freebox Essentiel install√©`);
        } else if (produit.includes('ultra')) {
          ptsGeneresCeMois += count * 6; // Freebox Ultra: 6 pts
          console.log(`+ ${count * 6} pts pour Freebox Ultra install√©`);
        } else if (produit.includes('forfait') || produit.includes('5g')) {
          ptsGeneresCeMois += count * 1; // Forfait 5G: 1 pt
          console.log(`+ ${count * 1} pts pour Forfait 5G install√©`);
        }
      });
      console.log(`Total points g√©n√©r√©s par installations: ${ptsGeneresCeMois}`);

      // 4. Clients √† relancer - tous les clients sauf ceux avec statut "installation", "resiliation" et "rendez-vous"
      const clientsARelancerQuery = sql`
        SELECT COUNT(*) as count
        FROM clients 
        WHERE deleted_at IS NULL 
        AND (status IS NULL OR status NOT IN ('installation', 'resiliation', 'rendez_vous', 'rendez-vous'))
      `;
      const clientsARelancerResult = await db.execute(clientsARelancerQuery);
      const clientsARelancer = Number(clientsARelancerResult.rows[0]?.count || 0);
      console.log(`Clients √† relancer: ${clientsARelancer}`);

      // 5. Nombre de Box (Freebox) ce mois
      const freeboxCountQuery = sql`
        SELECT COUNT(*) as count
        FROM clients 
        WHERE deleted_at IS NULL 
        AND date_signature IS NOT NULL
        AND EXTRACT(MONTH FROM date_signature::timestamp) = ${currentMonth}
        AND EXTRACT(YEAR FROM date_signature::timestamp) = ${currentYear}
        AND produit IS NOT NULL
        AND (LOWER(produit) LIKE '%freebox%' OR LOWER(produit) LIKE '%pop%' OR LOWER(produit) LIKE '%essentiel%' OR LOWER(produit) LIKE '%ultra%')
      `;
      const freeboxCountResult = await db.execute(freeboxCountQuery);
      const freeboxCount = Number(freeboxCountResult.rows[0]?.count || 0);
      console.log(`Nombre de Freebox ce mois: ${freeboxCount}`);

      // 6. Nombre de Forfait 5G ce mois
      const forfait5gCountQuery = sql`
        SELECT COUNT(*) as count
        FROM clients 
        WHERE deleted_at IS NULL 
        AND date_signature IS NOT NULL
        AND EXTRACT(MONTH FROM date_signature::timestamp) = ${currentMonth}
        AND EXTRACT(YEAR FROM date_signature::timestamp) = ${currentYear}
        AND produit IS NOT NULL
        AND (LOWER(produit) LIKE '%forfait%' OR LOWER(produit) LIKE '%5g%')
      `;
      const forfait5gCountResult = await db.execute(forfait5gCountQuery);
      const forfait5gCount = Number(forfait5gCountResult.rows[0]?.count || 0);
      console.log(`Nombre de Forfait 5G ce mois: ${forfait5gCount}`);

      const customStats = {
        clientsCeMois,
        installation,
        ptsGeneresCeMois,
        clientsARelancer,
        freeboxCount,
        forfait5gCount
      };

      console.log(`Statistiques finales:`, customStats);
      res.json(customStats);
    } catch (error) {
      console.error("Erreur lors du calcul des statistiques personnalis√©es:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Endpoint public pour les statistiques personnalis√©es (sans authentification)
  app.get("/api/public/custom-stats", async (req: Request, res: Response) => {
    try {
      console.log(`üìä STATS DEBUG - Requ√™te re√ßue`);
      
      // Force juin 2025 pour correspondre aux donn√©es existantes
      const currentMonth = 6; // Juin
      const currentYear = 2025;

      console.log(`üìä STATS DEBUG - Calcul des statistiques forc√© pour ${currentMonth}/${currentYear}`);

      // 1. Signatures du mois - clients avec date de signature du mois en cours (statut valid√© ou plus)
      const clientsCeMoisQuery = sql`
        SELECT COUNT(*) as count
        FROM clients 
        WHERE deleted_at IS NULL 
        AND date_signature IS NOT NULL
        AND EXTRACT(MONTH FROM date_signature::timestamp) = ${currentMonth}
        AND EXTRACT(YEAR FROM date_signature::timestamp) = ${currentYear}
        AND status NOT IN ('enregistre', 'enregistr√©')
      `;
      const clientsCeMoisResult = await db.execute(clientsCeMoisQuery);
      const clientsCeMois = Number(clientsCeMoisResult.rows[0]?.count || 0);
      console.log(`Signatures du mois: ${clientsCeMois}`);

      // 2. Installation - clients avec statut "Rendez-vous" uniquement
      const installationQuery = sql`
        SELECT COUNT(*) as count
        FROM clients 
        WHERE deleted_at IS NULL 
        AND (status = 'rendez-vous' OR status = 'rendez_vous')
      `;
      const installationResult = await db.execute(installationQuery);
      const installation = Number(installationResult.rows[0]?.count || 0);
      console.log(`Clients avec statut rendez-vous: ${installation}`);

      // 3. Pts g√©n√©r√©s ce mois - points bas√©s sur les clients avec statut "installation" et date d'installation du mois courant
      const ptsGeneresCeMoisQuery = sql`
        SELECT produit, COUNT(*) as count
        FROM clients 
        WHERE deleted_at IS NULL 
        AND status = 'installation'
        AND date_installation IS NOT NULL
        AND EXTRACT(MONTH FROM date_installation::timestamp) = ${currentMonth}
        AND EXTRACT(YEAR FROM date_installation::timestamp) = ${currentYear}
        AND produit IS NOT NULL
        GROUP BY produit
      `;
      const ptsGeneresCeMoisResult = await db.execute(ptsGeneresCeMoisQuery);
      
      let ptsGeneresCeMois = 0;
      console.log(`Produits install√©s ce mois:`, ptsGeneresCeMoisResult.rows);
      
      ptsGeneresCeMoisResult.rows.forEach((row: any) => {
        const produit = row.produit?.toLowerCase() || '';
        const count = Number(row.count);
        console.log(`Produit install√©: ${produit}, Count: ${count}`);
        
        if (produit.includes('pop')) {
          ptsGeneresCeMois += count * 4; // Freebox Pop: 4 pts
          console.log(`+ ${count * 4} pts pour Freebox Pop install√©`);
        } else if (produit.includes('essentiel')) {
          ptsGeneresCeMois += count * 5; // Freebox Essentiel: 5 pts
          console.log(`+ ${count * 5} pts pour Freebox Essentiel install√©`);
        } else if (produit.includes('ultra')) {
          ptsGeneresCeMois += count * 6; // Freebox Ultra: 6 pts
          console.log(`+ ${count * 6} pts pour Freebox Ultra install√©`);
        } else if (produit.includes('forfait') || produit.includes('5g')) {
          ptsGeneresCeMois += count * 1; // Forfait 5G: 1 pt
          console.log(`+ ${count * 1} pts pour Forfait 5G install√©`);
        }
      });
      console.log(`Total points g√©n√©r√©s par installations: ${ptsGeneresCeMois}`);

      // 4. Clients √† relancer - tous les clients sauf ceux avec statut "installation", "resiliation" et "rendez-vous"
      const clientsARelancerQuery = sql`
        SELECT COUNT(*) as count
        FROM clients 
        WHERE deleted_at IS NULL 
        AND (status IS NULL OR status NOT IN ('installation', 'resiliation', 'rendez_vous', 'rendez-vous'))
      `;
      const clientsARelancerResult = await db.execute(clientsARelancerQuery);
      const clientsARelancer = Number(clientsARelancerResult.rows[0]?.count || 0);
      console.log(`Clients √† relancer: ${clientsARelancer}`);

      // 5. Nombre de Box (Freebox) ce mois
      const freeboxCountQuery = sql`
        SELECT COUNT(*) as count
        FROM clients 
        WHERE deleted_at IS NULL 
        AND date_signature IS NOT NULL
        AND EXTRACT(MONTH FROM date_signature::timestamp) = ${currentMonth}
        AND EXTRACT(YEAR FROM date_signature::timestamp) = ${currentYear}
        AND produit IS NOT NULL
        AND (LOWER(produit) LIKE '%freebox%' OR LOWER(produit) LIKE '%pop%' OR LOWER(produit) LIKE '%essentiel%' OR LOWER(produit) LIKE '%ultra%')
      `;
      const freeboxCountResult = await db.execute(freeboxCountQuery);
      const freeboxCount = Number(freeboxCountResult.rows[0]?.count || 0);
      console.log(`Nombre de Freebox ce mois: ${freeboxCount}`);

      // 6. Nombre de Forfait 5G ce mois
      const forfait5gCountQuery = sql`
        SELECT COUNT(*) as count
        FROM clients 
        WHERE deleted_at IS NULL 
        AND date_signature IS NOT NULL
        AND EXTRACT(MONTH FROM date_signature::timestamp) = ${currentMonth}
        AND EXTRACT(YEAR FROM date_signature::timestamp) = ${currentYear}
        AND produit IS NOT NULL
        AND (LOWER(produit) LIKE '%forfait%' OR LOWER(produit) LIKE '%5g%')
      `;
      const forfait5gCountResult = await db.execute(forfait5gCountQuery);
      const forfait5gCount = Number(forfait5gCountResult.rows[0]?.count || 0);
      console.log(`Nombre de Forfait 5G ce mois: ${forfait5gCount}`);

      const customStats = {
        clientsCeMois,
        installation,
        ptsGeneresCeMois,
        clientsARelancer,
        freeboxCount,
        forfait5gCount
      };

      console.log(`Statistiques finales:`, customStats);
      res.json(customStats);
    } catch (error) {
      console.error("Erreur lors du calcul des statistiques personnalis√©es:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Endpoint pour les statistiques de ventes avec CVD
  app.get('/api/ventes/stats', async (req: Request, res: Response) => {
    try {
      const currentMonth = new Date().getMonth() + 1;
      const currentYear = new Date().getFullYear();

      // 1. Ventes du mois (installations uniquement - coh√©rent avec custom-stats)
      const ventesQuery = sql`
        SELECT COUNT(*) as count
        FROM clients 
        WHERE deleted_at IS NULL 
        AND status = 'installation'
        AND EXTRACT(YEAR FROM date_installation) = ${currentYear}
        AND EXTRACT(MONTH FROM date_installation) = ${currentMonth}
      `;
      const ventesResult = await db.execute(ventesQuery);
      const ventes = Number(ventesResult.rows[0]?.count || 0);

      // 2. Clients √† relancer (tous MOINS installation, r√©siliation et rendez-vous)
      const clientsARelancerQuery = sql`
        SELECT COUNT(*) as count 
        FROM clients 
        WHERE deleted_at IS NULL 
        AND status NOT IN ('installation', 'resiliation', 'rendez_vous', 'rendez-vous')
      `;
      const clientsARelancerResult = await db.execute(clientsARelancerQuery);
      const clientsARelancer = Number(clientsARelancerResult.rows[0]?.count || 0);

      // 3. Points g√©n√©r√©s ce mois selon le bar√®me Free (bas√© sur installations)
      const pointsQuery = sql`
        SELECT produit, COUNT(*) as count
        FROM clients 
        WHERE deleted_at IS NULL 
        AND status = 'installation'
        AND EXTRACT(YEAR FROM date_installation) = ${currentYear}
        AND EXTRACT(MONTH FROM date_installation) = ${currentMonth}
        GROUP BY produit
      `;
      const pointsResult = await db.execute(pointsQuery);
      
      let totalPoints = 0;
      pointsResult.rows.forEach((row: any) => {
        const produit = row.produit?.toLowerCase() || '';
        const count = Number(row.count);
        
        if (produit.includes('ultra')) {
          totalPoints += count * 6; // Freebox Ultra: 6 pts
        } else if (produit.includes('essentiel')) {
          totalPoints += count * 5; // Freebox Essentiel: 5 pts
        } else if (produit.includes('pop')) {
          totalPoints += count * 4; // Freebox Pop: 4 pts
        } else if (produit.includes('forfait') || produit.includes('5g')) {
          totalPoints += count * 1; // Forfait 5G: 1 pt
        }
      });

      // 4. Calcul des commissions CVD selon le syst√®me de paliers
      // IMPORTANT : Seuls les clients avec statut "Installation" ET date_installation du mois en cours comptent pour les commissions
      
      // V√©rifier d'abord les statuts disponibles
      const statusCheckQuery = sql`
        SELECT DISTINCT status, COUNT(*) as count
        FROM clients 
        WHERE deleted_at IS NULL 
        GROUP BY status
        ORDER BY count DESC
      `;
      const statusResult = await db.execute(statusCheckQuery);
      console.log('=== STATUTS DISPONIBLES ===');
      statusResult.rows.forEach((row: any) => {
        console.log(`Statut: "${row.status}" - Count: ${row.count}`);
      });

      const ventesDetailQuery = sql`
        SELECT prenom, nom, produit, date_installation, status
        FROM clients 
        WHERE deleted_at IS NULL 
        AND (status = 'installation' OR status = 'Installation')
        AND date_installation IS NOT NULL
        AND EXTRACT(YEAR FROM date_installation) = ${currentYear}
        AND EXTRACT(MONTH FROM date_installation) = ${currentMonth}
        ORDER BY date_installation ASC
      `;
      const ventesDetailResult = await db.execute(ventesDetailQuery);
      console.log(`=== CLIENTS INSTALL√âS DU MOIS (${currentMonth}/${currentYear}) ===`);
      console.log(`Nombre trouv√©: ${ventesDetailResult.rows.length}`);
      
      // ========================================
      // LOGIQUE CVD D√âFINITIVE - NE JAMAIS MODIFIER
      // ========================================
      // Syst√®me de commission CVD selon sp√©cifications officielles :
      // 
      // PALIERS : Tous les 5 points ‚Üí nouveau calcul de commission
      // TRANCHES : D√©terminent les valeurs selon points cumul√©s totaux
      //   - Tranche 1 : 0-25 points
      //   - Tranche 2 : 26-50 points  
      //   - Tranche 3 : 51-100 points
      //   - Tranche 4 : 101+ points
      //
      // SEULS les clients avec statut "installation" ET date_installation 
      // du mois en cours g√©n√®rent des commissions CVD
      // ========================================
      const calculerCommissionCVD = (ventes: any[]) => {
        console.log(`=== CALCUL CVD - ${ventes.length} installations valid√©es du mois ===`);
        
        let pointsCumules = 0;
        let commissionTotale = 0;
        let palierActuel = 0;
        let ventesEnAttente: any[] = [];
        
        // BAR√àME OFFICIEL PAR TRANCHE - VERROUILL√â
        const getCommissionProduit = (produit: string, tranche: number) => {
          const produitLower = produit.toLowerCase();
          
          // Freebox Pop : 50‚Ç¨/60‚Ç¨/70‚Ç¨/80‚Ç¨ selon tranche 1/2/3/4
          if (produitLower.includes('pop')) {
            return [50, 60, 70, 80][tranche - 1] || 80;
          } 
          // Freebox Essentiel : 50‚Ç¨/70‚Ç¨/90‚Ç¨/110‚Ç¨ selon tranche 1/2/3/4
          else if (produitLower.includes('essentiel')) {
            return [50, 70, 90, 110][tranche - 1] || 110;
          } 
          // Freebox Ultra : 50‚Ç¨/80‚Ç¨/100‚Ç¨/120‚Ç¨ selon tranche 1/2/3/4
          else if (produitLower.includes('ultra')) {
            return [50, 80, 100, 120][tranche - 1] || 120;
          } 
          // Forfait 5G : 10‚Ç¨ fixe pour toutes les tranches
          else if (produitLower.includes('forfait') || produitLower.includes('5g')) {
            return 10; // Forfait 5G toujours 10‚Ç¨
          }
          return 0;
        };
        
        // POINTS PAR PRODUIT - VERROUILL√â
        const getPointsProduit = (produit: string) => {
          const produitLower = produit.toLowerCase();
          if (produitLower.includes('ultra')) return 6;      // Freebox Ultra : 6 points
          if (produitLower.includes('essentiel')) return 5;  // Freebox Essentiel : 5 points
          if (produitLower.includes('pop')) return 4;        // Freebox Pop : 4 points
          if (produitLower.includes('forfait') || produitLower.includes('5g')) return 1; // Forfait 5G : 1 point
          return 0;
        };
        
        ventes.forEach((vente: any, index: number) => {
          const points = getPointsProduit(vente.produit);
          const pointsAvant = pointsCumules;
          pointsCumules += points;
          
          console.log(`${index + 1}. ${vente.prenom} ${vente.nom} - ${vente.produit} - ${points}pts - Install√© le: ${vente.date_installation} - Total: ${pointsCumules}pts`);
          
          // Ajouter la vente en attente
          ventesEnAttente.push({
            client: `${vente.prenom} ${vente.nom}`,
            produit: vente.produit,
            points: points
          });
          
          // V√©rifier si on franchit un palier de 5 points
          const palierAvant = Math.floor(pointsAvant / 5);
          const nouveauPalier = Math.floor(pointsCumules / 5);
          
          if (nouveauPalier > palierAvant) {
            console.log(`*** PALIER FRANCHI! Points: ${pointsAvant} -> ${pointsCumules} (palier ${palierAvant} -> ${nouveauPalier}) ***`);
            
            // D√âTERMINATION DE LA TRANCHE - VERROUILL√âE
            // Tranche bas√©e sur le TOTAL de points cumul√©s (pas le palier)
            // Tranche 1: 0-25 points, Tranche 2: 26-50 points, Tranche 3: 51-100 points, Tranche 4: 101+ points
            let tranche = 1;
            if (pointsCumules >= 101) tranche = 4;
            else if (pointsCumules >= 51) tranche = 3;
            else if (pointsCumules >= 26) tranche = 2;
            else tranche = 1; // 0-25 points
            
            console.log(`Tranche appliqu√©e: ${tranche} (bas√©e sur ${pointsCumules} points cumul√©s)`);
            
            let commissionPalier = 0;
            console.log(`Ventes d√©clench√©es (${ventesEnAttente.length}):`);
            ventesEnAttente.forEach(venteAttente => {
              const commission = getCommissionProduit(venteAttente.produit, tranche);
              commissionPalier += commission;
              console.log(`  - ${venteAttente.client} (${venteAttente.produit}): ${commission}‚Ç¨`);
            });
            
            commissionTotale += commissionPalier;
            console.log(`Commission d√©clench√©e: ${commissionPalier}‚Ç¨ - Total cumul√©: ${commissionTotale}‚Ç¨`);
            console.log('---');
            
            // R√©initialiser les ventes en attente
            ventesEnAttente = [];
          }
        });
        
        console.log(`=== R√âSULTAT FINAL ===`);
        console.log(`Points cumul√©s: ${pointsCumules}`);
        console.log(`Paliers franchis: ${palierActuel}`);
        console.log(`Commission totale: ${commissionTotale}‚Ç¨`);
        console.log(`Ventes en attente: ${ventesEnAttente.length}`);
        
        return { 
          commission: commissionTotale, 
          palier: palierActuel,
          pointsCumules,
          ventesEnAttente: ventesEnAttente.length
        };
      };

      const cvdData = calculerCommissionCVD(ventesDetailResult.rows as any[]);

      // 5. Nombre de Freebox vendues ce mois (Pop, Essentiel, Ultra)
      const freeboxQuery = sql`
        SELECT COUNT(*) as count
        FROM clients 
        WHERE deleted_at IS NULL 
        AND EXTRACT(YEAR FROM date_signature) = ${currentYear}
        AND EXTRACT(MONTH FROM date_signature) = ${currentMonth}
        AND (produit ILIKE '%freebox%' OR produit ILIKE '%pop%' OR produit ILIKE '%essentiel%' OR produit ILIKE '%ultra%')
      `;
      const freeboxResult = await db.execute(freeboxQuery);
      const freeboxCount = Number(freeboxResult.rows[0]?.count || 0);

      // 6. Nombre de Forfait 5G vendus ce mois
      const forfait5gQuery = sql`
        SELECT COUNT(*) as count
        FROM clients 
        WHERE deleted_at IS NULL 
        AND EXTRACT(YEAR FROM date_signature) = ${currentYear}
        AND EXTRACT(MONTH FROM date_signature) = ${currentMonth}
        AND (produit ILIKE '%forfait%' OR produit ILIKE '%5g%')
      `;
      const forfait5gResult = await db.execute(forfait5gQuery);
      const forfait5gCount = Number(forfait5gResult.rows[0]?.count || 0);

      console.log("üìä VENTES STATS DEBUG - Valeurs avant assemblage:");
      console.log("- ventes (installations du mois):", ventes);
      console.log("- clientsARelancer:", clientsARelancer);
      console.log("- cvdData.pointsCumules:", cvdData.pointsCumules);
      console.log("- cvdData.commission:", cvdData.commission);
      console.log("- freeboxCount:", freeboxCount);
      console.log("- forfait5gCount:", forfait5gCount);

      const stats = {
        ventes,
        installations: clientsARelancer,
        totalPoints: cvdData.pointsCumules,
        commission: cvdData.commission,
        palier: cvdData.palier,
        pointsRestants: 5 - (cvdData.pointsCumules % 5),
        ventesEnAttente: cvdData.ventesEnAttente,
        freeboxCount,
        forfait5gCount
      };

      console.log("üìä VENTES STATS DEBUG - Statistiques finales:", stats);
      res.json(stats);
    } catch (error) {
      console.error("Erreur lors du calcul des statistiques de ventes:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Route PUT pour mettre √† jour une carte SIM
  app.put('/api/sim-cards/:id', requireAuth, async (req, res) => {
    try {
      const simCardId = parseInt(req.params.id);
      let { clientId, dateInstallation, identifiantContrat, codeVendeur, numero, statut } = req.body;
      
      if (!simCardId || isNaN(simCardId)) {
        return res.status(400).json({ message: "ID de carte SIM invalide" });
      }

      // V√©rifier que la carte SIM existe
      const existingCard = await db.select().from(simCards).where(eq(simCards.id, simCardId));
      if (existingCard.length === 0) {
        return res.status(404).json({ message: "Carte SIM non trouv√©e" });
      }

      // Pr√©parer les donn√©es de mise √† jour avec conversion s√©curis√©e des types
      const updateData: any = {};
      
      // Gestion du client
      if (clientId !== undefined) {
        if (clientId === null || clientId === '' || clientId === 0) {
          // Lib√©rer la carte SIM
          updateData.clientId = null;
          updateData.statut = 'disponible';
          updateData.dateAttribution = null;
          updateData.dateActivation = null;
          updateData.dateInstallation = null;
          updateData.codeVendeur = '';
        } else {
          // Assigner la carte SIM √† un client
          const clientIdNum = parseInt(clientId.toString());
          const client = await db.select().from(clients).where(eq(clients.id, clientIdNum));
          if (client.length === 0) {
            return res.status(400).json({ message: "Client non trouv√©" });
          }
          
          updateData.clientId = clientIdNum;
          updateData.statut = 'assignee';
          updateData.dateAttribution = new Date();
          updateData.codeVendeur = client[0].code_vendeur || '';
        }
      }

      // Gestion de la date d'installation avec conversion s√©curis√©e
      if (dateInstallation !== undefined) {
        if (dateInstallation === null || dateInstallation === '') {
          updateData.dateInstallation = null;
        } else {
          try {
            // Convertir la cha√Æne de date en objet Date
            updateData.dateInstallation = new Date(dateInstallation);
            // V√©rifier que la date est valide
            if (isNaN(updateData.dateInstallation.getTime())) {
              return res.status(400).json({ message: "Format de date invalide" });
            }
            updateData.statut = 'activee';
          } catch (dateError) {
            return res.status(400).json({ message: "Format de date invalide" });
          }
        }
      }

      // Autres champs avec validation
      if (numero !== undefined) {
        updateData.numero = numero.toString();
      }
      
      if (statut !== undefined) {
        updateData.statut = statut.toString();
      }
      
      if (codeVendeur !== undefined) {
        updateData.codeVendeur = codeVendeur.toString();
      }

      // Mettre √† jour la carte SIM
      const updatedCard = await db.update(simCards)
        .set(updateData)
        .where(eq(simCards.id, simCardId))
        .returning();

      // Si on assigne/d√©sassigne une carte SIM, synchroniser le client
      if (updateData.clientId !== undefined && updateData.clientId !== null) {
        try {
          // Synchroniser le client avec la carte SIM assign√©e
          await db.update(clients)
            .set({ carte_sim: updatedCard[0].numero })
            .where(eq(clients.id, updateData.clientId));
        } catch (syncError) {
          console.error("Erreur synchronisation client:", syncError);
        }
      }

      res.json({
        success: true,
        simCard: updatedCard[0],
        message: "Carte SIM mise √† jour avec succ√®s"
      });

    } catch (error) {
      console.error("Erreur lors de la mise √† jour de la carte SIM:", error);
      res.status(500).json({ message: "Erreur serveur lors de la mise √† jour" });
    }
  });

  // Route POST pour cr√©er une carte SIM
  app.post('/api/sim-cards', requireAuth, async (req, res) => {
    try {
      const { numero, codeVendeur, note } = req.body;
      
      if (!numero) {
        return res.status(400).json({ message: "Le num√©ro de la carte SIM est requis" });
      }

      // V√©rifier que le num√©ro n'existe pas d√©j√†
      const existingCard = await db.select().from(simCards).where(eq(simCards.numero, numero));
      if (existingCard.length > 0) {
        return res.status(400).json({ message: "Une carte SIM avec ce num√©ro existe d√©j√†" });
      }

      const newCard = await db.insert(simCards).values({
        numero,
        codeVendeur: codeVendeur || '',
        statut: 'disponible',
        note: note || null,
        userId: req.user?.id || 1
      }).returning();

      res.status(201).json({
        success: true,
        simCard: newCard[0],
        message: "Carte SIM cr√©√©e avec succ√®s"
      });

    } catch (error) {
      console.error("Erreur lors de la cr√©ation de la carte SIM:", error);
      res.status(500).json({ message: "Erreur serveur lors de la cr√©ation" });
    }
  });

  // Route POST pour lib√©rer une carte SIM (unassign-client)
  app.post('/api/sim-cards/:id/unassign-client', requireAuth, async (req, res) => {
    try {
      const simCardId = parseInt(req.params.id);
      
      if (isNaN(simCardId)) {
        return res.status(400).json({ message: "ID de carte SIM invalide" });
      }

      // V√©rifier que la carte SIM existe
      const simCard = await db.query.simCards.findFirst({
        where: eq(simCards.id, simCardId)
      });

      if (!simCard) {
        return res.status(404).json({ message: "Carte SIM non trouv√©e" });
      }

      // Lib√©rer la carte SIM du client actuel
      const updatedCard = await db.update(simCards)
        .set({
          statut: 'disponible',
          clientId: null,
          dateAttribution: null,
          dateActivation: null,
          dateInstallation: null
        })
        .where(eq(simCards.id, simCardId))
        .returning();

      // Si la carte √©tait assign√©e √† un client, mettre √† jour le client
      if (simCard.clientId) {
        try {
          await db.update(clients)
            .set({ carte_sim: null })
            .where(eq(clients.id, simCard.clientId));
        } catch (syncError) {
          console.error("Erreur synchronisation client:", syncError);
        }
      }

      res.json({
        success: true,
        simCard: updatedCard[0],
        message: "Carte SIM lib√©r√©e avec succ√®s"
      });

    } catch (error) {
      console.error("Erreur lors de la lib√©ration de la carte SIM:", error);
      res.status(500).json({ message: "Erreur serveur lors de la lib√©ration" });
    }
  });

  // Route POST pour r√©attribuer une carte SIM √† un autre client
  app.post('/api/sim-cards/:id/reassign-client', requireAuth, async (req, res) => {
    try {
      const simCardId = parseInt(req.params.id);
      const { newClientId } = req.body;
      
      if (isNaN(simCardId) || !newClientId) {
        return res.status(400).json({ message: "ID de carte SIM ou client invalide" });
      }

      // V√©rifier que la carte SIM existe
      const simCard = await db.query.simCards.findFirst({
        where: eq(simCards.id, simCardId)
      });

      if (!simCard) {
        return res.status(404).json({ message: "Carte SIM non trouv√©e" });
      }

      // V√©rifier que le nouveau client existe
      const newClient = await db.query.clients.findFirst({
        where: and(eq(clients.id, newClientId), isNull(clients.deleted_at))
      });

      if (!newClient) {
        return res.status(404).json({ message: "Nouveau client non trouv√©" });
      }

      // Lib√©rer l'ancien client si n√©cessaire
      if (simCard.clientId) {
        try {
          await db.update(clients)
            .set({ carte_sim: null })
            .where(eq(clients.id, simCard.clientId));
        } catch (syncError) {
          console.error("Erreur lib√©ration ancien client:", syncError);
        }
      }

      // R√©attribuer la carte SIM au nouveau client
      const updatedCard = await db.update(simCards)
        .set({
          statut: 'Activ√©',
          clientId: newClientId,
          dateAttribution: new Date(),
          dateActivation: new Date(),
          dateInstallation: new Date()
        })
        .where(eq(simCards.id, simCardId))
        .returning();

      // Synchroniser le nouveau client
      try {
        await db.update(clients)
          .set({ carte_sim: updatedCard[0].numero })
          .where(eq(clients.id, newClientId));
      } catch (syncError) {
        console.error("Erreur synchronisation nouveau client:", syncError);
      }

      res.json({
        success: true,
        simCard: updatedCard[0],
        message: "Carte SIM r√©attribu√©e avec succ√®s"
      });

    } catch (error) {
      console.error("Erreur lors de la r√©attribution de la carte SIM:", error);
      res.status(500).json({ message: "Erreur serveur lors de la r√©attribution" });
    }
  });

  // === ENDPOINTS MLM COMMISSIONS ===
  
  // Endpoint pour les donn√©es de commissions r√©seau MLM
  app.get('/api/mlm/network-commissions', requireAuth, async (req, res) => {
    try {
      // Donn√©es simul√©es pour le d√©veloppement - seront connect√©es aux vraies donn√©es MLM plus tard
      const mlmData = {
        commissionDirecte: 0, // Commission niveau 1 (5%)
        commissionIndirecte: 0, // Commission niveau 2 (3%)
        bonusLeadership: 0, // Bonus leadership variable
        bonusPerformance: 0, // Bonus performance (2%)
        vendeursNiveau1: 0, // Nombre de vendeurs niveau 1
        vendeursNiveau2: 0, // Nombre de vendeurs niveau 2
        objectifLeadership: "Non atteint", // Statut objectif leadership
        scorePerformance: 0 // Score de performance globale
      };

      res.json(mlmData);
    } catch (error) {
      console.error("Erreur r√©cup√©ration commissions MLM:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Endpoint pour les statistiques du r√©seau MLM
  app.get('/api/mlm/network-stats', requireAuth, async (req, res) => {
    try {
      // Statistiques du r√©seau MLM - seront connect√©es aux vraies donn√©es plus tard
      const networkStats = {
        totalVendeurs: 0,
        vendeursActifs: 0,
        ventesTotales: 0,
        commissionTotale: 0,
        performanceGlobale: 0
      };

      res.json(networkStats);
    } catch (error) {
      console.error("Erreur r√©cup√©ration stats r√©seau MLM:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // === ENDPOINTS VENDEURS/RECRUTEMENT ===

  // Endpoint GET pour r√©cup√©rer la liste des vendeurs/recruiters
  app.get('/api/recruiters', requireAuth, async (req, res) => {
    try {
      console.log("R√©cup√©ration des vendeurs/recruiters");
      
      // Pour l'instant, retourner une liste vide pour √©viter l'erreur
      // Plus tard, ceci sera connect√© √† la vraie table recruiters
      const vendeurs = [];
      
      res.json(vendeurs);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des vendeurs:", error);
      res.status(500).json({ message: "Erreur serveur lors de la r√©cup√©ration des vendeurs" });
    }
  });

  // Endpoint POST pour cr√©er un nouveau vendeur
  app.post('/api/recruiters', requireAuth, async (req, res) => {
    try {
      console.log("Cr√©ation d'un nouveau vendeur");
      
      // Pour l'instant, simuler la cr√©ation
      const newVendeur = {
        id: Date.now(),
        ...req.body,
        createdAt: new Date().toISOString()
      };
      
      res.status(201).json(newVendeur);
    } catch (error) {
      console.error("Erreur lors de la cr√©ation du vendeur:", error);
      res.status(500).json({ message: "Erreur serveur lors de la cr√©ation du vendeur" });
    }
  });

  // Endpoint GET pour r√©cup√©rer les prospects d'un vendeur
  app.get('/api/recruiters/:id/prospects', requireAuth, async (req, res) => {
    try {
      const vendeurId = parseInt(req.params.id);
      console.log(`R√©cup√©ration des prospects pour le vendeur ${vendeurId}`);
      
      // Pour l'instant, retourner une liste vide
      const prospects = [];
      
      res.json(prospects);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des prospects:", error);
      res.status(500).json({ message: "Erreur serveur lors de la r√©cup√©ration des prospects" });
    }
  });

  // Route principale pour les prospects avec statistiques
  app.get('/api/recruitment/prospects', requireAuth, async (req, res) => {
    try {
      // Test simple avec count d'abord
      console.log("Test connexion table recrues...");
      const countResult = await db.execute(sql`SELECT COUNT(*) as total FROM recrues`);
      console.log("Nombre total de recrues:", countResult.rows[0]);
      
      // R√©cup√©rer les prospects avec une requ√™te SQL brute pour √©viter les probl√®mes Drizzle
      const prospectsResult = await db.execute(sql`
        SELECT id, prenom, nom, email, mobile, ville, etapeactuelle, created_at, codevendeur
        FROM recrues 
        ORDER BY created_at DESC
      `);
      
      const prospects = prospectsResult.rows.map((row: any) => ({
        id: row.id,
        prenom: row.prenom,
        nom: row.nom,
        email: row.email,
        mobile: row.mobile,
        ville: row.ville,
        etapeActuelle: row.etapeactuelle,
        createdAt: row.created_at,
        codeVendeur: row.codevendeur
      }));
      
      // Calculer les statistiques
      const statsResult = await db.execute(sql`
        SELECT etapeactuelle, formation_completed
        FROM recrues
      `);
      
      const allProspects = statsResult.rows;
      const stats = {
        total: allProspects.length,
        nouveau: allProspects.filter((p: any) => p.etapeactuelle === 'etape1').length,
        contact√©: allProspects.filter((p: any) => p.etapeactuelle === 'etape2').length,
        entretien: allProspects.filter((p: any) => p.etapeactuelle === 'etape3').length,
        formation: allProspects.filter((p: any) => p.etapeactuelle === 'etape4').length,
        actif: allProspects.filter((p: any) => p.formation_completed === true).length,
        refus√©: allProspects.filter((p: any) => p.etapeactuelle === 'refuse').length
      };
      
      console.log("Prospects r√©cup√©r√©s:", prospects.length);
      console.log("Statistiques:", stats);
      
      res.json({
        prospects,
        stats
      });
      
    } catch (error) {
      console.error('Erreur lors de la r√©cup√©ration des prospects:', error);
      res.status(500).json({ 
        message: 'Erreur lors de la r√©cup√©ration des prospects',
        prospects: [],
        stats: {
          total: 0,
          nouveau: 0,
          contact√©: 0,
          entretien: 0,
          formation: 0,
          actif: 0,
          refus√©: 0
        }
      });
    }
  });

  // Endpoint POST pour cr√©er un nouveau prospect
  app.post('/api/recruitment/prospects', requireAuth, async (req, res) => {
    try {
      console.log("Cr√©ation d'un nouveau prospect...");
      const prospectData = req.body;
      
      // R√©cup√©rer l'utilisateur connect√© pour l'attribution automatique
      const user = req.user;
      if (!user) {
        return res.status(401).json({ message: "Utilisateur non authentifi√©" });
      }

      // R√©cup√©rer le recruteur associ√© √† l'utilisateur connect√©
      const recruiter = await db.query.recruiters.findFirst({
        where: eq(recruiters.userId, user.id)
      });

      if (!recruiter) {
        return res.status(404).json({ message: "Aucun recruteur trouv√© pour cet utilisateur" });
      }

      // Cr√©er le prospect avec attribution automatique au recruteur connect√©
      const newProspect = {
        typeProspect: prospectData.typeProspect || "client",
        prenom: prospectData.prenom,
        nom: prospectData.nom,
        email: prospectData.email || null,
        telephone: prospectData.telephone || null,
        adresse: prospectData.adresse || null,
        codePostal: prospectData.codePostal || null,
        ville: prospectData.ville || null,
        nomSociete: prospectData.nomSociete || null,
        siret: prospectData.siret || null,
        codeVendeur: prospectData.codeVendeur || null,
        source: prospectData.source,
        motivation: prospectData.motivation || null,
        experiencePrecedente: prospectData.experiencePrecedente || null,
        disponibilite: prospectData.disponibilite || null,
        stade: prospectData.stade || "nouveau",
        notes: prospectData.notes || null,
        recruteurId: recruiter.id, // Attribution automatique au recruteur connect√©
        assigneA: prospectData.assigneA || null,
      };

      // Ins√©rer le prospect dans la base de donn√©es
      const [createdProspect] = await db.insert(recruitmentProspects).values(newProspect).returning();
      
      // Si un commentaire/note est renseign√©, cr√©er automatiquement une t√¢che
      if (prospectData.notes && prospectData.notes.trim() !== "") {
        console.log("Cr√©ation automatique d'une t√¢che bas√©e sur le commentaire...");
        
        // Analyser le commentaire pour d√©terminer le type de t√¢che
        const commentaire = prospectData.notes.toLowerCase();
        let typeTask = "suivi";
        let priorite = "medium";
        
        if (commentaire.includes("appeler") || commentaire.includes("rappeler") || commentaire.includes("t√©l√©phone")) {
          typeTask = "appel";
          priorite = "high";
        } else if (commentaire.includes("email") || commentaire.includes("mail")) {
          typeTask = "email";
        } else if (commentaire.includes("rdv") || commentaire.includes("rendez-vous") || commentaire.includes("rencontre")) {
          typeTask = "rendez_vous";
          priorite = "high";
        } else if (commentaire.includes("formation") || commentaire.includes("entrainement")) {
          typeTask = "formation";
        }

        // Cr√©er la t√¢che automatiquement
        const taskData = {
          title: `Suivi prospect: ${prospectData.prenom} ${prospectData.nom}`,
          description: `T√¢che cr√©√©e automatiquement suite au commentaire: "${prospectData.notes}"`,
          status: "pending",
          priority: priorite,
          userId: user.id, // Attribuer √† l'utilisateur connect√©
          category: typeTask,
          dueDate: new Date(Date.now() + 24 * 60 * 60 * 1000), // √âch√©ance dans 24h
          clientId: null, // Pas encore un client
          isAutoGenerated: true,
        };

        await db.insert(tasks).values(taskData);
        console.log("T√¢che automatique cr√©√©e avec succ√®s");
      }

      console.log("Prospect cr√©√© avec succ√®s:", createdProspect.id);
      res.status(201).json({ 
        message: "Prospect cr√©√© avec succ√®s",
        prospect: createdProspect
      });

    } catch (error) {
      console.error("Erreur lors de la cr√©ation du prospect:", error);
      res.status(500).json({ message: "Erreur serveur lors de la cr√©ation du prospect" });
    }
  });

  // Endpoint POST pour cr√©er un nouveau prospect ET client automatiquement
  app.post('/api/recruitment/prospects-with-client', requireAuth, async (req, res) => {
    try {
      console.log("Cr√©ation d'un nouveau prospect avec client automatique...");
      const prospectData = req.body;
      
      // R√©cup√©rer l'utilisateur connect√©
      const user = req.user;
      if (!user) {
        return res.status(401).json({ message: "Utilisateur non authentifi√©" });
      }

      // R√©cup√©rer le recruteur associ√© √† l'utilisateur connect√©
      const recruiter = await db.query.recruiters.findFirst({
        where: eq(recruiters.userId, user.id)
      });

      if (!recruiter) {
        return res.status(404).json({ message: "Aucun recruteur trouv√© pour cet utilisateur" });
      }

      // Cr√©er d'abord le prospect
      const newProspect = {
        typeProspects: "Client",
        prenom: prospectData.prenom,
        nom: prospectData.nom,
        email: prospectData.email || null,
        telephone: prospectData.telephone || null,
        adresse: prospectData.adresse || null,
        codePostal: prospectData.codePostal || null,
        ville: prospectData.ville || null,
        nomSociete: prospectData.nomSociete || null,
        siret: prospectData.siret || null,
        codeVendeur: prospectData.codeVendeur || null,
        source: prospectData.source,
        motivation: prospectData.motivation || null,
        experiencePrecedente: prospectData.experiencePrecedente || null,
        disponibilite: prospectData.disponibilite || null,
        stade: "nouveau",
        notes: prospectData.notes || null,
        recruteurId: recruiter.id,
        assigneA: prospectData.assigneA || null,
      };

      // Ins√©rer le prospect dans la base de donn√©es
      const [createdProspect] = await db.insert(recruitmentProspects).values(newProspect).returning();
      
      // Cr√©er automatiquement le client correspondant
      const clientData = {
        prenom: prospectData.prenom,
        nom: prospectData.nom,
        email: prospectData.email || "",
        telephone: prospectData.telephone || "",
        adresse: prospectData.adresse || "",
        codePostal: prospectData.codePostal || "",
        ville: prospectData.ville || "",
        codeVendeur: user.username || "",
        produit: prospectData.produit || "Freebox Pop",
        civilite: prospectData.civilite || "M.",
        dateNaissance: prospectData.dateNaissance || null,
        source: prospectData.source || "prospect",
        status: "enregistre", // Statut par d√©faut
        identifiantContrat: null,
        dateSignature: null,
        dateRendezVous: null,
        dateInstallation: null,
        commentaires: prospectData.notes || "",
        isDeleted: false,
      };

      // Ins√©rer le client dans la base de donn√©es
      const [createdClient] = await db.insert(clients).values(clientData).returning();
      
      console.log("Prospect et client cr√©√©s avec succ√®s:", createdProspect.id, createdClient.id);
      res.status(201).json({ 
        message: "Prospect et client cr√©√©s avec succ√®s",
        prospect: createdProspect,
        client: createdClient
      });

    } catch (error) {
      console.error("Erreur lors de la cr√©ation du prospect-client:", error);
      res.status(500).json({ message: "Erreur serveur lors de la cr√©ation du prospect-client" });
    }
  });

  // Endpoint PUT pour mettre √† jour un prospect
  app.put('/api/recruitment/prospects/:id', requireAuth, async (req, res) => {
    try {
      const prospectId = parseInt(req.params.id);
      const prospectData = req.body;
      const user = req.user;

      if (!user) {
        return res.status(401).json({ message: "Utilisateur non authentifi√©" });
      }

      console.log(`Mise √† jour du prospect ${prospectId}...`);

      // V√©rifier que le prospect existe
      const existingProspect = await db.query.recruitmentProspects.findFirst({
        where: eq(recruitmentProspects.id, prospectId)
      });

      if (!existingProspect) {
        return res.status(404).json({ message: "Prospect non trouv√©" });
      }

      // Pour l'instant, permettre la modification √† tous les utilisateurs authentifi√©s
      // TODO: Impl√©menter la v√©rification des permissions plus tard

      // Pr√©parer les donn√©es de mise √† jour
      const updateData = {
        typeProspect: prospectData.typeProspect,
        prenom: prospectData.prenom,
        nom: prospectData.nom,
        email: prospectData.email || null,
        telephone: prospectData.telephone || null,
        adresse: prospectData.adresse || null,
        codePostal: prospectData.codePostal || null,
        ville: prospectData.ville || null,
        nomSociete: prospectData.nomSociete || null,
        siret: prospectData.siret || null,
        codeVendeur: prospectData.codeVendeur || null,
        source: prospectData.source,
        motivation: prospectData.motivation || null,
        experiencePrecedente: prospectData.experiencePrecedente || null,
        disponibilite: prospectData.disponibilite || null,
        stade: prospectData.stade,
        notes: prospectData.notes || null,
        assigneA: prospectData.assigneA || null,
        updatedAt: new Date(),
      };

      // Mettre √† jour le prospect
      const [updatedProspect] = await db.update(recruitmentProspects)
        .set(updateData)
        .where(eq(recruitmentProspects.id, prospectId))
        .returning();

      // Si le commentaire a √©t√© ajout√© ou modifi√©, cr√©er une t√¢che
      if (prospectData.notes && prospectData.notes.trim() !== "" && 
          prospectData.notes !== existingProspect.notes) {
        console.log("Cr√©ation d'une nouvelle t√¢che suite √† la modification du commentaire...");
        
        const commentaire = prospectData.notes.toLowerCase();
        let typeTask = "suivi";
        let priorite = "medium";
        
        if (commentaire.includes("appeler") || commentaire.includes("rappeler")) {
          typeTask = "appel";
          priorite = "high";
        } else if (commentaire.includes("email") || commentaire.includes("mail")) {
          typeTask = "email";
        } else if (commentaire.includes("rdv") || commentaire.includes("rendez-vous")) {
          typeTask = "rendez_vous";
          priorite = "high";
        }

        const taskData = {
          title: `Suivi prospect MAJ: ${prospectData.prenom} ${prospectData.nom}`,
          description: `T√¢che cr√©√©e suite √† la modification: "${prospectData.notes}"`,
          status: "pending",
          priority: priorite,
          userId: user.id,
          category: typeTask,
          dueDate: new Date(Date.now() + 24 * 60 * 60 * 1000),
          clientId: null,
          isAutoGenerated: true,
        };

        await db.insert(tasks).values(taskData);
        console.log("Nouvelle t√¢che automatique cr√©√©e");
      }

      res.json({ 
        message: "Prospect mis √† jour avec succ√®s",
        prospect: updatedProspect
      });

    } catch (error) {
      console.error("Erreur lors de la mise √† jour du prospect:", error);
      res.status(500).json({ message: "Erreur serveur lors de la mise √† jour du prospect" });
    }
  });

  // === ENDPOINTS TUNNEL DE RECRUTEMENT ===

  // Fonction pour g√©n√©rer un code vendeur automatique
  const generateCodeVendeur = () => {
    const now = new Date();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const year = String(now.getFullYear()).slice(-2);
    const random = Math.floor(Math.random() * 10000).toString().padStart(4, '0');
    return `FR${month}${year}${random}`;
  };

  // Endpoint POST √âtape 1 - Inscription initiale
  app.post('/api/recruitment/step1', async (req, res) => {
    try {
      console.log("√âtape 1 - Donn√©es re√ßues:", req.body);
      
      const { codeParrainage, civilite, prenom, nom, mobile, email, adresse, codePostal, ville, rgpdAccepted } = req.body;
      
      // Validation des donn√©es obligatoires
      if (!codeParrainage || !civilite || !prenom || !nom || !mobile || !email || !adresse || !codePostal || !ville || !rgpdAccepted) {
        return res.status(400).json({ message: "Tous les champs obligatoires doivent √™tre renseign√©s" });
      }

      // V√©rifier que le code de parrainage existe (optionnel pour l'instant)
      const parrain = await db.query.users.findFirst({
        where: eq(users.codeVendeur, codeParrainage),
      });

      // G√©n√©rer le code vendeur automatiquement
      const codeVendeur = generateCodeVendeur();

      // Utiliser Neon SQL direct pour √©viter les probl√®mes Drizzle
      const neonSql = neon(process.env.DATABASE_URL!);
      
      const insertQuery = `
        INSERT INTO recrues (
          codeparrainage, civilite, prenom, nom, mobile, email, 
          rgpdaccepted, codevendeur, etapeactuelle, parrainid,
          adresse, code_postal, ville
        ) VALUES (
          $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
        ) RETURNING *
      `;

      const values = [
        codeParrainage, civilite, prenom, nom, mobile, email,
        rgpdAccepted, codeVendeur, "etape2", parrain?.id || null,
        adresse, codePostal, ville
      ];

      console.log("Insertion via Neon SQL direct");
      const result = await neonSql(insertQuery, values);
      const newRecrue = result[0];

      console.log("Nouvelle recrue cr√©√©e:", newRecrue);

      // Note: Les donn√©es de candidature restent dans la table 'recrues' uniquement
      // Elles ne seront transf√©r√©es vers 'clients' que si la personne devient r√©ellement client
      console.log(`Recrue enregistr√©e: ${prenom} ${nom} avec code vendeur ${codeVendeur}`);

      res.status(201).json(newRecrue);
    } catch (error) {
      console.error("Erreur √©tape 1:", error);
      res.status(500).json({ message: "Erreur serveur lors de l'inscription" });
    }
  });

  // Endpoint GET - R√©cup√©rer les donn√©es d'une recrue par ID
  app.get('/api/recruitment/recrue/:id', async (req, res) => {
    try {
      const recrueId = parseInt(req.params.id);
      
      const recrue = await db.query.recrues.findFirst({
        where: eq(recrues.id, recrueId),
        with: {
          parrain: true,
        },
      });

      if (!recrue) {
        return res.status(404).json({ message: "Recrue non trouv√©e" });
      }

      res.json(recrue);
    } catch (error) {
      console.error("Erreur r√©cup√©ration recrue:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Endpoint GET - R√©cup√©rer la derni√®re recrue cr√©√©e (pour step2)
  app.get('/api/recruitment/recrue', async (req, res) => {
    try {
      const recrueId = req.query.recrueId;
      
      if (!recrueId) {
        return res.status(400).json({ message: "ID de recrue manquant" });
      }

      // Utiliser Neon SQL direct pour √©viter les probl√®mes Drizzle
      const neonSql = neon(process.env.DATABASE_URL!);
      
      const selectQuery = `
        SELECT * FROM recrues 
        WHERE id = $1
        LIMIT 1
      `;

      const result = await neonSql(selectQuery, [parseInt(recrueId as string)]);
      
      if (result.length === 0) {
        return res.status(404).json({ message: "Recrue non trouv√©e" });
      }

      const recrue = result[0];

      res.json({
        id: recrue.id,
        prenom: recrue.prenom,
        nom: recrue.nom,
        email: recrue.email,
        codeVendeur: recrue.codevendeur,
        etapeActuelle: recrue.etapeactuelle,
        codeParrainage: recrue.codeparrainage,
        civilite: recrue.civilite,
        mobile: recrue.mobile,
        adresse: recrue.adresse,
        codePostal: recrue.code_postal,
        ville: recrue.ville,
        rgpdAccepted: recrue.rgpdaccepted
      });
    } catch (error) {
      console.error("Erreur r√©cup√©ration recrue:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Route POST - Sauvegarder attestation sur l'honneur
  app.post('/api/recruitment/attestation', async (req, res) => {
    try {
      const {
        recrueId,
        prenom,
        nom,
        adresse,
        codePostal,
        commune,
        nomFormation,
        tauxReussite,
        dateAttestation,
        signatureDataUrl
      } = req.body;

      // V√©rifier que la recrue existe
      const recrue = await db.query.recrues.findFirst({
        where: eq(recrues.id, recrueId),
      });

      if (!recrue) {
        return res.status(404).json({ message: "Recrue non trouv√©e" });
      }

      // Mettre √† jour la recrue avec les donn√©es de l'attestation
      await db.update(recrues)
        .set({
          prenom,
          nom,
          adresse,
          codePostal,
          ville: commune,
          documentFormation: signatureDataUrl,
          commentairesFormation: `Attestation g√©n√©r√©e - Formation: ${nomFormation} - Taux: ${tauxReussite}% - Date: ${dateAttestation}`,
          etapeActuelle: '4',
          updatedAt: new Date(),
        })
        .where(eq(recrues.id, recrueId));

      console.log(`Attestation sauvegard√©e pour ${prenom} ${nom} (ID: ${recrueId})`);
      
      res.json({
        success: true,
        message: 'Attestation sauvegard√©e avec succ√®s',
        recrueId: recrueId
      });
    } catch (error) {
      console.error('Erreur sauvegarde attestation:', error);
      res.status(500).json({ message: 'Erreur lors de la sauvegarde de l\'attestation' });
    }
  });

  // Endpoint POST pour l'inscription compl√®te avec g√©n√©ration mot de passe et contrat
  app.post('/api/recruitment/complete-inscription', upload.fields([
    { name: 'photo', maxCount: 1 },
    { name: 'quizResultat1', maxCount: 1 },
    { name: 'quizResultat2', maxCount: 1 },
    { name: 'quizResultat3', maxCount: 1 },
    { name: 'justificatifIdentite', maxCount: 1 },
    { name: 'rib', maxCount: 1 },
    { name: 'carteVitale', maxCount: 1 },
    { name: 'documentJustificatif', maxCount: 1 },
    { name: 'identiteHebergeant', maxCount: 1 },
    { name: 'attestationHebergement', maxCount: 1 },
    { name: 'documentJustificatifHeberge', maxCount: 1 }
  ]), async (req, res) => {
    try {
      console.log("Inscription compl√®te - Donn√©es re√ßues:", req.body);
      console.log("Fichiers re√ßus:", Object.keys(req.files || {}));

      const { 
        recrueId, dateNaissance, villeNaissance, numeroSecuriteSociale, 
        nationalite, adressePostale, codePostal, ville, vehiculePermis, 
        typeHebergement 
      } = req.body;

      if (!recrueId) {
        return res.status(400).json({ message: "ID de recrue manquant" });
      }

      // V√©rifier que la recrue existe
      const recrueExistante = await db.select().from(recrues).where(eq(recrues.id, parseInt(recrueId)));
      if (recrueExistante.length === 0) {
        return res.status(404).json({ message: "Recrue non trouv√©e" });
      }

      // G√©n√©ration automatique du mot de passe
      const motDePasse = generatePassword();
      console.log(`Mot de passe g√©n√©r√© pour recrue ${recrueId}:`, motDePasse);

      // Pr√©paration des chemins de fichiers
      const files = req.files as any;
      const cheminPhoto = files.photo ? `/uploads/${files.photo[0].filename}` : null;
      const cheminQuizResultat1 = files.quizResultat1 ? `/uploads/${files.quizResultat1[0].filename}` : null;
      const cheminQuizResultat2 = files.quizResultat2 ? `/uploads/${files.quizResultat2[0].filename}` : null;
      const cheminQuizResultat3 = files.quizResultat3 ? `/uploads/${files.quizResultat3[0].filename}` : null;
      const cheminPieceIdentite = files.justificatifIdentite ? `/uploads/${files.justificatifIdentite[0].filename}` : null;
      const cheminRib = files.rib ? `/uploads/${files.rib[0].filename}` : null;
      const cheminCarteVitale = files.carteVitale ? `/uploads/${files.carteVitale[0].filename}` : null;
      
      // Fichiers conditionnels selon type d'h√©bergement
      let cheminDocumentJustificatif = null;
      let cheminIdentiteHebergeant = null;
      let cheminAttestationHebergement = null;

      if (typeHebergement === 'pas_heberge') {
        cheminDocumentJustificatif = files.documentJustificatif ? `/uploads/${files.documentJustificatif[0].filename}` : null;
      } else if (typeHebergement === 'heberge') {
        cheminIdentiteHebergeant = files.identiteHebergeant ? `/uploads/${files.identiteHebergeant[0].filename}` : null;
        cheminAttestationHebergement = files.attestationHebergement ? `/uploads/${files.attestationHebergement[0].filename}` : null;
        cheminDocumentJustificatif = files.documentJustificatifHeberge ? `/uploads/${files.documentJustificatifHeberge[0].filename}` : null;
      }

      // Mise √† jour de la recrue avec toutes les nouvelles donn√©es
      const updatedRecrue = await db.update(recrues)
        .set({
          dateNaissance,
          villeNaissance,
          numeroSecuriteSociale,
          nationalite,
          adresse: adressePostale,
          codePostal,
          ville,
          vehiculePermis,
          typeHebergement,
          cheminPhoto,
          cheminQuizResultat1,
          cheminQuizResultat2,
          cheminQuizResultat3,
          cheminPieceIdentite,
          cheminRib,
          cheminCarteVitale,
          cheminDocumentJustificatif,
          cheminIdentiteHebergeant,
          cheminAttestationHebergement,
          motDePasseGenere: motDePasse,
          etapeActuelle: 'etape5',
          updatedAt: new Date(),
        })
        .where(eq(recrues.id, parseInt(recrueId)))
        .returning();

      console.log(`Inscription compl√®te sauvegard√©e pour recrue ID ${recrueId}`);

      // Cr√©ation automatique du compte utilisateur vendeur
      try {
        const newUser = await db.insert(users)
          .values({
            username: recrueExistante[0].email,
            password: motDePasse, // En production, hasher le mot de passe
            email: recrueExistante[0].email,
            prenom: recrueExistante[0].prenom,
            nom: recrueExistante[0].nom,
            phone: recrueExistante[0].mobile,
            codeVendeur: recrueExistante[0].codeVendeur,
            avatar: cheminPhoto,
            active: true,
            isAdmin: false,
          })
          .returning();

        console.log(`Compte utilisateur cr√©√© pour ${recrueExistante[0].prenom} ${recrueExistante[0].nom}`);
      } catch (userError) {
        console.log("Compte utilisateur existe d√©j√† ou erreur:", userError);
      }

      res.json({
        success: true,
        message: 'Inscription compl√®te enregistr√©e avec succ√®s',
        recrueId: parseInt(recrueId),
        motDePasse: motDePasse,
        contratGenere: true
      });

    } catch (error) {
      console.error('Erreur inscription compl√®te:', error);
      res.status(500).json({ message: 'Erreur lors de l\'enregistrement de l\'inscription compl√®te' });
    }
  });

  // Fonction de g√©n√©ration de mot de passe s√©curis√©
  function generatePassword(): string {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*';
    let password = '';
    for (let i = 0; i < 12; i++) {
      password += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return password;
  }

  // Endpoint GET pour g√©n√©rer le contrat PDF
  app.get('/api/recruitment/contrat/pdf/:recrueId', async (req, res) => {
    try {
      const recrueId = parseInt(req.params.recrueId);
      
      if (isNaN(recrueId)) {
        return res.status(400).json({ message: "ID de recrue invalide" });
      }

      const recrue = await db.select().from(recrues).where(eq(recrues.id, recrueId));
      
      if (recrue.length === 0) {
        return res.status(404).json({ message: "Recrue non trouv√©e" });
      }

      const recrueData = recrue[0];
      console.log('G√©n√©ration contrat PDF pour recrue:', recrueData.prenom, recrueData.nom);

      // G√©n√©ration du contenu HTML du contrat
      const htmlContent = `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Contrat de Distribution Commerciale</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 30px; line-height: 1.6; max-width: 800px; margin: 0 auto; }
        .header { text-align: center; margin-bottom: 40px; border-bottom: 3px solid #333; padding-bottom: 20px; }
        .content { margin: 20px 0; }
        .signature-section { margin-top: 80px; display: flex; justify-content: space-between; }
        .signature-box { width: 45%; text-align: center; border-top: 1px solid #333; padding-top: 10px; }
        .article { margin: 20px 0; padding: 15px; background: #f9f9f9; border-left: 4px solid #6366f1; }
        .footer { margin-top: 40px; text-align: center; color: #666; font-size: 12px; }
        h1 { color: #333; margin: 0; font-size: 24px; }
        h2 { color: #6366f1; margin: 20px 0 10px 0; font-size: 18px; }
        h3 { color: #333; margin: 15px 0 5px 0; font-size: 16px; }
        .highlight { background: #e0e7ff; padding: 2px 6px; border-radius: 3px; font-weight: bold; }
        .info-block { background: #f0f9ff; border: 1px solid #bae6fd; padding: 15px; border-radius: 5px; margin: 15px 0; }
        table { width: 100%; border-collapse: collapse; margin: 15px 0; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background: #f5f5f5; font-weight: bold; }
    </style>
</head>
<body>
    <div class="header">
        <h1>CONTRAT DE DISTRIBUTION COMMERCIALE</h1>
        <h3>Synergie Marketing Group</h3>
        <p>Contrat de partenariat commercial - Vendeur √† Domicile Ind√©pendant</p>
    </div>
    
    <div class="content">
        <div class="info-block">
            <h3>Informations du Distributeur :</h3>
            <table>
                <tr><td><strong>Nom :</strong></td><td>${recrueData.nom?.trim()}</td></tr>
                <tr><td><strong>Pr√©nom :</strong></td><td>${recrueData.prenom?.trim()}</td></tr>
                <tr><td><strong>Date de naissance :</strong></td><td>${recrueData.dateNaissance || 'Non renseign√©'}</td></tr>
                <tr><td><strong>Lieu de naissance :</strong></td><td>${recrueData.villeNaissance || 'Non renseign√©'}</td></tr>
                <tr><td><strong>Nationalit√© :</strong></td><td>${recrueData.nationalite || 'Non renseign√©'}</td></tr>
                <tr><td><strong>Adresse :</strong></td><td>${recrueData.adresse || 'Non renseign√©'}</td></tr>
                <tr><td><strong>Code postal :</strong></td><td>${recrueData.codePostal || 'Non renseign√©'}</td></tr>
                <tr><td><strong>Ville :</strong></td><td>${recrueData.ville || 'Non renseign√©'}</td></tr>
                <tr><td><strong>Email :</strong></td><td>${recrueData.email}</td></tr>
                <tr><td><strong>T√©l√©phone :</strong></td><td>${recrueData.mobile}</td></tr>
                <tr><td><strong>N¬∞ S√©curit√© Sociale :</strong></td><td>${recrueData.numeroSecuriteSociale || 'Non renseign√©'}</td></tr>
                <tr><td><strong>Code Vendeur :</strong></td><td class="highlight">${recrueData.codeVendeur}</td></tr>
            </table>
        </div>

        <div class="article">
            <h2>ARTICLE 1 - OBJET DU CONTRAT</h2>
            <p>Le pr√©sent contrat d√©finit les modalit√©s de collaboration entre <strong>Synergie Marketing Group</strong> et <strong>${recrueData.prenom} ${recrueData.nom}</strong> pour la distribution commerciale des produits et services de t√©l√©communications de la marque <strong>Free</strong>.</p>
            <p>Le distributeur s'engage √† promouvoir et commercialiser les offres Free (Freebox et forfaits mobiles) dans le respect des conditions g√©n√©rales de vente et de la r√©glementation en vigueur.</p>
        </div>

        <div class="article">
            <h2>ARTICLE 2 - STATUT DU DISTRIBUTEUR</h2>
            <p>Le distributeur exerce son activit√© en qualit√© de <strong>Vendeur √† Domicile Ind√©pendant (VDI)</strong> au sens de l'article L.135-1 du Code de commerce.</p>
            <p>Cette activit√© est exerc√©e de mani√®re ind√©pendante, sans lien de subordination. Le distributeur conserve sa libert√© d'organisation dans l'ex√©cution de sa mission.</p>
        </div>

        <div class="article">
            <h2>ARTICLE 3 - OBLIGATIONS DU DISTRIBUTEUR</h2>
            <p>Le distributeur s'engage √† :</p>
            <ul>
                <li>Respecter la d√©ontologie commerciale et l'image de marque Free</li>
                <li>Suivre les formations obligatoires dispens√©es par Synergie Marketing Group</li>
                <li>Utiliser exclusivement les supports commerciaux fournis</li>
                <li>Respecter la r√©glementation sur le d√©marchage √† domicile</li>
                <li>Informer fid√®lement les prospects sur les offres et conditions</li>
                <li>Transmettre les contrats sign√©s dans les d√©lais impartis</li>
            </ul>
        </div>

        <div class="article">
            <h2>ARTICLE 4 - R√âMUN√âRATION ET COMMISSIONS</h2>
            <p>La r√©mun√©ration du distributeur est bas√©e sur un syst√®me de commissions selon le bar√®me en vigueur :</p>
            <ul>
                <li><strong>Freebox Ultra :</strong> Commission selon grille tarifaire</li>
                <li><strong>Freebox Essentiel :</strong> Commission selon grille tarifaire</li>
                <li><strong>Freebox Pop :</strong> Commission selon grille tarifaire</li>
                <li><strong>Forfait Mobile 5G :</strong> Commission selon grille tarifaire</li>
            </ul>
            <p>Les commissions sont vers√©es mensuellement apr√®s validation des installations par Free.</p>
        </div>

        <div class="article">
            <h2>ARTICLE 5 - FORMATION ET HABILITATION</h2>
            <p>Le distributeur atteste avoir suivi et valid√© la formation obligatoire "Vendeur √† Domicile - Free" avec les r√©sultats suivants :</p>
            <div class="info-block">
                <p><strong>R√©sultats de formation :</strong></p>
                <p>‚Ä¢ Quiz 1 : ${recrueData.resultatQuiz1 || 'N/A'}%</p>
                <p>‚Ä¢ Quiz 2 : ${recrueData.resultatQuiz2 || 'N/A'}%</p>
                <p>‚Ä¢ Quiz 3 : ${recrueData.resultatQuiz3 || 'N/A'}%</p>
                <p><strong>Moyenne g√©n√©rale : ${recrueData.moyenneQuiz || 'N/A'}%</strong></p>
            </div>
        </div>

        <div class="article">
            <h2>ARTICLE 6 - V√âHICULE ET D√âPLACEMENTS</h2>
            <p><strong>Situation v√©hicule/permis :</strong> <span class="highlight">${recrueData.vehiculePermis || 'Non renseign√©'}</span></p>
            <p>Les frais de d√©placement dans le cadre de l'activit√© commerciale restent √† la charge du distributeur.</p>
        </div>

        <div class="article">
            <h2>ARTICLE 7 - DUR√âE ET R√âSILIATION</h2>
            <p>Le pr√©sent contrat est conclu pour une dur√©e ind√©termin√©e. Il peut √™tre r√©sili√© par chacune des parties moyennant un pr√©avis de 30 jours par lettre recommand√©e avec accus√© de r√©ception.</p>
        </div>

        <div class="article">
            <h2>ARTICLE 8 - PROTECTION DES DONN√âES</h2>
            <p>Les parties s'engagent √† respecter la r√©glementation RGPD dans le traitement des donn√©es personnelles des prospects et clients.</p>
        </div>

        <p><strong>Fait le ${new Date().toLocaleDateString('fr-FR')}</strong></p>
        
        <div class="signature-section">
            <div class="signature-box">
                <p><strong>Le Distributeur</strong></p>
                <p>${recrueData.prenom} ${recrueData.nom}</p>
                <p>Signature √©lectronique requise</p>
            </div>
            <div class="signature-box">
                <p><strong>Synergie Marketing Group</strong></p>
                <p>Direction Commerciale</p>
                <p>Signature et cachet</p>
            </div>
        </div>
    </div>
    
    <div class="footer">
        <p>¬© ${new Date().getFullYear()} Synergie Marketing Group - Contrat de Distribution Commerciale</p>
        <p>Document g√©n√©r√© automatiquement le ${new Date().toLocaleString('fr-FR')}</p>
    </div>
</body>
</html>`;
      
      res.setHeader('Content-Type', 'text/html; charset=utf-8');
      res.send(htmlContent);
      
    } catch (error) {
      console.error('Erreur g√©n√©ration contrat PDF:', error);
      res.status(500).json({ message: 'Erreur lors de la g√©n√©ration du contrat' });
    }
  });

  // Endpoint GET pour pr√©visualisation du contrat
  app.get('/api/recruitment/contrat/preview/:recrueId', async (req, res) => {
    // Utilise le m√™me endpoint que le PDF pour la pr√©visualisation
    return app._router.handle({ ...req, url: `/api/recruitment/contrat/pdf/${req.params.recrueId}` }, res, () => {});
  });

  // Endpoint POST pour sauvegarder l'attestation avec signature
  app.post('/api/recruitment/attestation', async (req, res) => {
    try {
      console.log("Attestation - Donn√©es re√ßues:", req.body);
      
      const { 
        recrueId, prenom, nom, adresse, codePostal, ville, 
        formation, resultat1, resultat2, resultat3, moyenne, 
        tauxReussite, signatureDataUrl, dateAttestation 
      } = req.body;

      if (!recrueId || !prenom || !nom || !signatureDataUrl) {
        return res.status(400).json({ message: "Donn√©es manquantes pour l'attestation (recrueId, prenom, nom, signature requis)" });
      }

      const recrueIdInt = parseInt(recrueId);
      if (isNaN(recrueIdInt)) {
        return res.status(400).json({ message: "ID de recrue invalide" });
      }

      // Mettre √† jour la recrue avec les donn√©es de l'attestation et signature
      const updatedRecrue = await db.update(recrues)
        .set({
          resultatQuiz1: resultat1?.toString() || '',
          resultatQuiz2: resultat2?.toString() || '',
          resultatQuiz3: resultat3?.toString() || '',
          moyenneQuiz: moyenne?.toString() || '',
          formationValidee: true,
          signatureElectronique: signatureDataUrl, // Sauvegarder la signature
          documentFormation: `attestation_${recrueIdInt}_${Date.now()}.pdf`,
          commentairesFormation: `Attestation g√©n√©r√©e - Moyenne: ${moyenne?.toFixed(1)}% - Date: ${new Date().toLocaleDateString('fr-FR')}`,
          etapeActuelle: 'etape4',
          updatedAt: new Date()
        })
        .where(eq(recrues.id, recrueId))
        .returning();

      if (updatedRecrue.length === 0) {
        return res.status(404).json({ message: "Recrue non trouv√©e" });
      }

      console.log(`Attestation sauvegard√©e pour ${prenom} ${nom} (ID: ${recrueIdInt})`);

      res.json({
        success: true,
        message: "Attestation sauvegard√©e avec succ√®s",
        recrue: updatedRecrue[0]
      });

    } catch (error) {
      console.error("Erreur sauvegarde attestation:", error);
      res.status(500).json({ message: "Erreur serveur lors de la sauvegarde de l'attestation" });
    }
  });

  // Endpoint PUT pour mettre √† jour l'acceptation du r√®glement int√©rieur
  app.put('/api/recruitment/recrues/:id/reglement', async (req, res) => {
    try {
      console.log('PUT /api/recruitment/recrues/:id/reglement - ID re√ßu:', req.params.id);
      console.log('PUT /api/recruitment/recrues/:id/reglement - Body:', req.body);
      
      const recrueId = parseInt(req.params.id);
      const { reglementAccepted, etapeActuelle } = req.body;
      
      if (isNaN(recrueId) || req.params.id === 'null') {
        return res.status(400).json({ message: "ID de recrue invalide ou null" });
      }

      // V√©rifier que la recrue existe
      const existingRecrue = await db.select().from(recrues).where(eq(recrues.id, recrueId));
      
      if (existingRecrue.length === 0) {
        return res.status(404).json({ message: "Recrue non trouv√©e" });
      }

      const updatedRecrue = await db.update(recrues)
        .set({ 
          instructionsValidated: reglementAccepted,
          etapeActuelle: etapeActuelle,
          updatedAt: new Date()
        })
        .where(eq(recrues.id, recrueId))
        .returning();

      console.log(`R√®glement accept√© pour recrue ID ${recrueId}`);

      res.json({
        success: true,
        message: "R√®glement int√©rieur accept√© avec succ√®s",
        recrue: updatedRecrue[0]
      });

    } catch (error) {
      console.error("Erreur acceptation r√®glement:", error);
      res.status(500).json({ message: "Erreur serveur lors de l'acceptation du r√®glement" });
    }
  });

  // Endpoint GET pour r√©cup√©rer une recrue sp√©cifique
  app.get('/api/recruitment/recrues/:id', async (req, res) => {
    try {
      const recrueId = parseInt(req.params.id);
      
      if (isNaN(recrueId)) {
        return res.status(400).json({ message: "ID de recrue invalide" });
      }

      const recrue = await db.select().from(recrues).where(eq(recrues.id, recrueId));
      
      if (recrue.length === 0) {
        return res.status(404).json({ message: "Recrue non trouv√©e" });
      }

      res.json(recrue[0]);

    } catch (error) {
      console.error("Erreur r√©cup√©ration recrue:", error);
      res.status(500).json({ message: "Erreur serveur lors de la r√©cup√©ration de la recrue" });
    }
  });

  // Endpoint GET pour g√©n√©rer et t√©l√©charger le PDF de l'attestation (sans authentification pour tunnel public)
  app.get('/api/recruitment/attestation/pdf/:recrueId', async (req, res) => {
    try {
      const recrueId = parseInt(req.params.recrueId);
      
      if (isNaN(recrueId)) {
        return res.status(400).json({ message: "ID de recrue invalide" });
      }

      const recrue = await db.select().from(recrues).where(eq(recrues.id, recrueId));
      
      if (recrue.length === 0) {
        return res.status(404).json({ message: "Recrue non trouv√©e" });
      }

      const recrueData = recrue[0];

      // V√©rifier si l'attestation est disponible (formationValidee OU documentFormation pr√©sent)
      if (!recrueData.formationValidee && !recrueData.documentFormation) {
        console.log('Attestation non disponible - formationValidee:', recrueData.formationValidee, 'documentFormation:', !!recrueData.documentFormation);
        return res.status(400).json({ message: "Attestation non disponible pour cette recrue" });
      }

      console.log('G√©n√©ration PDF pour recrue:', recrueData.prenom, recrueData.nom, 'formationValidee:', recrueData.formationValidee);
      console.log('Signature pr√©sente - signatureElectronique:', !!recrueData.signatureElectronique);
      console.log('Signature pr√©sente - documentFormation:', !!recrueData.documentFormation);
      if (recrueData.documentFormation) {
        console.log('Longueur documentFormation:', recrueData.documentFormation.length);
        console.log('D√©but documentFormation:', recrueData.documentFormation.substring(0, 50));
      }

      // G√©n√©ration du contenu HTML pour l'attestation
      const htmlContent = `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Attestation sur l'honneur</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 40px; line-height: 1.6; max-width: 800px; margin: 0 auto; }
        .header { text-align: center; margin-bottom: 40px; border-bottom: 2px solid #333; padding-bottom: 20px; }
        .content { margin: 20px 0; }
        .signature { margin-top: 60px; text-align: right; }
        .results { background: #f5f5f5; padding: 15px; border-left: 4px solid #6366f1; }
        .footer { margin-top: 40px; text-align: center; color: #666; }
        h1 { color: #333; margin: 0; }
        h3 { color: #6366f1; margin: 10px 0; }
        .highlight { background: #e0e7ff; padding: 2px 6px; border-radius: 3px; }
    </style>
</head>
<body>
    <div class="header">
        <h1>ATTESTATION SUR L'HONNEUR</h1>
        <h3>Formation Vendeur √† Domicile (VAD) - Free</h3>
    </div>
    
    <div class="content">
        <p>Je soussign√©(e) <strong>${recrueData.prenom?.trim()} ${recrueData.nom?.trim()}</strong>,</p>
        ${recrueData.adresse ? `<p>demeurant au <strong>${recrueData.adresse}, ${recrueData.codePostal} ${recrueData.ville}</strong>,</p>` : ''}
        
        <p><strong>ATTESTE SUR L'HONNEUR</strong> avoir suivi l'int√©gralit√© des modules de formation obligatoires "Formation Vendeur √† Domicile (VAD) - Free" et avoir obtenu les r√©sultats suivants :</p>
        
        <div class="results">
            <h4>R√©sultats des √©valuations :</h4>
            <ul>
                <li>Quiz 1: <span class="highlight">${recrueData.resultatQuiz1 || 'N/A'}%</span></li>
                <li>Quiz 2: <span class="highlight">${recrueData.resultatQuiz2 || 'N/A'}%</span></li>
                <li>Quiz 3: <span class="highlight">${recrueData.resultatQuiz3 || 'N/A'}%</span></li>
            </ul>
            <p><strong>Moyenne g√©n√©rale: <span class="highlight">${recrueData.moyenneQuiz || 'N/A'}%</span></strong></p>
        </div>
        
        <p>Cette attestation engage ma responsabilit√©, et j'ai connaissance que toute fausse d√©claration m'expose √† des sanctions conform√©ment √† l'article 441-1 du Code p√©nal.</p>
        
        <p>Fait le <strong>${new Date().toLocaleDateString('fr-FR')}</strong></p>
        
        <div class="signature">
            <p><strong>Signature √©lectronique :</strong></p>
            ${(recrueData.signatureElectronique || recrueData.documentFormation) ? 
              `<img src="${recrueData.signatureElectronique || recrueData.documentFormation}" style="max-width: 200px; height: auto; border: 1px solid #ccc; margin: 10px 0;" alt="Signature √©lectronique" />` 
              : '<p><em>‚úì Signature √©lectronique valid√©e</em></p>'
            }
            <p>Code vendeur: <strong>${recrueData.codeVendeur || 'N/A'}</strong></p>
        </div>
    </div>
    
    <div class="footer">
        <p>¬© ${new Date().getFullYear()} Synergie Marketing Group - Document officiel</p>
    </div>
</body>
</html>`;
      
      res.setHeader('Content-Type', 'text/html; charset=utf-8');
      res.send(htmlContent);

    } catch (error) {
      console.error("Erreur g√©n√©ration PDF:", error);
      res.status(500).json({ message: "Erreur serveur lors de la g√©n√©ration du PDF" });
    }
  });

  // Endpoint GET pour r√©cup√©rer tous les recrutements (recrues) avec pagination et filtres
  app.get('/api/recruitment/recrues', async (req, res) => {
    try {
      const { search, stade, page = 1, limit = 100 } = req.query;
      
      let query = db.select({
        id: recrues.id,
        prenom: recrues.prenom,
        nom: recrues.nom,
        email: recrues.email,
        mobile: recrues.mobile,
        codeVendeur: recrues.codeVendeur,
        etapeActuelle: recrues.etapeActuelle,
        source: recrues.source,
        createdAt: recrues.createdAt,
        created_at: recrues.createdAt, // Alias pour compatibilit√©
        adresse: recrues.adresse,
        codePostal: recrues.codePostal,
        ville: recrues.ville,
        rgpdAccepted: recrues.rgpdAccepted,
        codeParrainage: recrues.codeParrainage,
        civilite: recrues.civilite
      })
      .from(recrues);

      // Filtrage par recherche
      if (search && typeof search === 'string') {
        const searchTerm = `%${search.toLowerCase()}%`;
        query = query.where(
          or(
            sql`LOWER(${recrues.prenom}) LIKE ${searchTerm}`,
            sql`LOWER(${recrues.nom}) LIKE ${searchTerm}`,
            sql`LOWER(${recrues.email}) LIKE ${searchTerm}`
          )
        );
      }

      // Filtrage par stade
      if (stade && typeof stade === 'string' && stade !== 'tous') {
        query = query.where(eq(recrues.etapeActuelle, stade));
      }

      // Tri par date de cr√©ation d√©croissante
      query = query.orderBy(desc(recrues.createdAt));

      // Pagination
      const offset = (parseInt(page as string) - 1) * parseInt(limit as string);
      query = query.limit(parseInt(limit as string)).offset(offset);

      const recruesData = await query;

      // Statistiques pour la page
      const statsQuery = db.select({
        total: sql<number>`count(*)`,
        nouveau: sql<number>`count(*) filter (where ${recrues.etapeActuelle} = 'nouveau')`,
        contact√©: sql<number>`count(*) filter (where ${recrues.etapeActuelle} = 'contact√©')`,
        entretien: sql<number>`count(*) filter (where ${recrues.etapeActuelle} = 'entretien')`,
        formation: sql<number>`count(*) filter (where ${recrues.etapeActuelle} = 'formation')`,
        actif: sql<number>`count(*) filter (where ${recrues.etapeActuelle} = 'actif')`,
        refus√©: sql<number>`count(*) filter (where ${recrues.etapeActuelle} = 'refus√©')`
      }).from(recrues);

      const stats = await statsQuery;

      res.json({
        recrues: recruesData,
        stats: stats[0],
        pagination: {
          page: parseInt(page as string),
          limit: parseInt(limit as string),
          total: stats[0]?.total || 0
        }
      });

    } catch (error) {
      console.error("Erreur r√©cup√©ration recrutements:", error);
      res.status(500).json({ 
        message: "Erreur serveur lors de la r√©cup√©ration des recrutements",
        recrues: [],
        stats: {
          total: 0,
          nouveau: 0,
          contact√©: 0,
          entretien: 0,
          formation: 0,
          actif: 0,
          refus√©: 0
        }
      });
    }
  });

  // Route de test email simple
  app.post('/api/recruitment/test-email', async (req, res) => {
    try {
      const { email, subject, message } = req.body;
      
      const transporter = nodemailer.createTransport({
        host: process.env.SMTP_HOST || 'smtp.hostinger.com',
        port: parseInt(process.env.SMTP_PORT || '465'),
        secure: true,
        auth: {
          user: process.env.SMTP_USER || 'recrutement@synergiemarketingroup.fr',
          pass: process.env.SMTP_PASS || 'Eric_1234.'
        },
        debug: true,
        logger: true
      });

      // V√©rifier la connexion SMTP
      await transporter.verify();
      console.log('Connexion SMTP v√©rifi√©e avec succ√®s');

      const mailOptions = {
        from: process.env.SMTP_FROM || 'recrutement@synergiemarketingroup.fr',
        to: email,
        subject: subject,
        text: message,
        html: `<div style="font-family: Arial, sans-serif; padding: 20px;">
          <h2 style="color: #6366f1;">Test Email Hostinger SMTP</h2>
          <p>${message}</p>
          <p><strong>Heure d'envoi:</strong> ${new Date().toLocaleString('fr-FR')}</p>
          <p><strong>Serveur SMTP:</strong> ${process.env.SMTP_HOST}</p>
        </div>`
      };

      const info = await transporter.sendMail(mailOptions);
      console.log('Email de test envoy√© avec succ√®s:', info);
      
      res.json({ 
        success: true, 
        message: 'Email de test envoy√© avec succ√®s',
        emailSentTo: email,
        messageId: info.messageId
      });
    } catch (error) {
      console.error('Erreur envoi email de test:', error);
      res.status(500).json({ 
        message: 'Erreur lors de l\'envoi de l\'email de test',
        error: error.message
      });
    }
  });

  // Endpoint POST - Envoi email formation avec fallback intelligent
  app.post('/api/recruitment/send-formation-email', async (req, res) => {
    try {
      const { recrueId } = req.body;

      if (!recrueId) {
        return res.status(400).json({ message: "ID de recrue manquant" });
      }

      const recrue = await db.query.recrues.findFirst({
        where: eq(recrues.id, recrueId),
      });

      if (!recrue) {
        return res.status(404).json({ message: "Recrue non trouv√©e" });
      }

      if (!recrue.email) {
        return res.status(400).json({ message: "Email de la recrue manquant" });
      }

      // Marquer l'email comme envoy√©
      await db.update(recrues)
        .set({
          emailSent: true,
          etapeActuelle: 3,
          updatedAt: new Date(),
        })
        .where(eq(recrues.id, recrueId));

      // Configuration Nodemailer avec identifiants Hostinger corrects
      const transporter = nodemailer.createTransport({
        host: 'smtp.hostinger.com',
        port: 465,
        secure: true, // SSL/TLS sur port 465
        auth: {
          user: 'recrutement@synergiemarketingroup.fr',
          pass: 'Eric_1234.'
        },
        tls: {
          rejectUnauthorized: false
        }
      });

      console.log('Configuration SMTP Hostinger:', {
        host: 'smtp.hostinger.com',
        port: 465,
        user: 'recrutement@synergiemarketingroup.fr',
        secure: true
      });

      // Contenu de l'email avec lien de formation
      const formationLink = 'http://vad-doc.proxad.net/login.html';

      try {
        const info = await transporter.sendMail({
          from: 'recrutement@synergiemarketingroup.fr',
          to: recrue.email,
          subject: `üåü Acc√®s formation - ${recrue.prenom} ${recrue.nom}`,
          html: `
            <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
              <h2 style="color: #6366f1; text-align: center;">F√©licitations ${recrue.prenom}! üåü</h2>
              
              <p>Votre inscription a √©t√© valid√©e. Voici vos informations d'acc√®s √† la formation :</p>
              
              <div style="background: #f3f4f6; padding: 15px; border-radius: 8px; margin: 20px 0;">
                <h3 style="color: #374151; margin: 0;">Votre code vendeur :</h3>
                <p style="font-size: 18px; font-weight: bold; color: #6366f1; margin: 5px 0;">${recrue.codeVendeur}</p>
              </div>
              
              <div style="background: #e0f2fe; padding: 15px; border-radius: 8px; margin: 20px 0;">
                <h3 style="color: #0277bd;">Acc√®s √† la formation :</h3>
                <p><strong>Lien :</strong> <a href="${formationLink}" style="color: #0277bd;">${formationLink}</a></p>
                <p><strong>Login :</strong> FreeVAD</p>
                <p><strong>Mot de passe :</strong> Ultra2024@</p>
              </div>
              
              <div style="text-align: center; margin: 25px 0;">
                <a href="${formationLink}" 
                   style="background: linear-gradient(135deg, #6366f1, #8b5cf6); color: white; padding: 12px 24px; text-decoration: none; border-radius: 8px; font-weight: bold;">
                  Acc√©der √† la formation
                </a>
              </div>
              
              <p><strong>Apr√®s la formation :</strong></p>
              <p>Une fois votre formation termin√©e avec un score sup√©rieur √† 80%, utilisez ce lien pour continuer votre inscription :</p>
              
              <div style="text-align: center; margin: 25px 0;">
                <a href="https://fc8d089f-4118-4730-b6ce-70b592aa2f8d-00-2ah94yan6wszg.janeway.replit.dev/recruitment/step4-validation-formation?recrueId=${recrueId}&prenom=${encodeURIComponent(recrue.prenom)}" 
                   style="background: linear-gradient(135deg, #10b981, #059669); color: white; padding: 12px 24px; text-decoration: none; border-radius: 8px; font-weight: bold;">
                  Valider ma formation
                </a>
              </div>
              
              <hr style="border: none; border-top: 1px solid #e5e7eb; margin: 30px 0;">
              <p style="text-align: center; color: #6b7280; font-size: 14px;">¬© 2025 Synergie Marketing Group</p>
            </div>
          `
        });

        console.log("Email formation envoy√© avec succ√®s √†:", recrue.email);
        
        res.json({ 
          success: true, 
          message: "Email envoy√© avec succ√®s", 
          emailSentTo: recrue.email
        });
        
      } catch (emailError: any) {
        console.error("Erreur envoi email:", emailError);
        res.json({ 
          success: false, 
          message: "Erreur envoi email", 
          error: emailError?.message || 'Erreur inconnue'
        });
      }
    } catch (error) {
      console.error("Erreur envoi email formation:", error);
      res.status(500).json({ message: "Erreur lors de l'envoi de l'email" });
    }
  });

  // Endpoint POST - Validation formation (Step 3 Post-Formation)  
  app.post('/api/recruitment/step3-validation/:id', async (req, res) => {
    try {
      const recrueId = parseInt(req.params.id);
      const { score, attestation, commentaires } = req.body;
      
      const recrue = await db.query.recrues.findFirst({
        where: eq(recrues.id, recrueId),
      });

      if (!recrue) {
        return res.status(404).json({ message: "Recrue non trouv√©e" });
      }

      // V√©rifier le score minimum
      const scoreNum = parseInt(score);
      if (scoreNum < 80) {
        return res.status(400).json({ 
          message: "Score insuffisant. Un minimum de 80% est requis." 
        });
      }

      // Pr√©parer les donn√©es de mise √† jour
      const updateData: any = {
        scoreFormation: scoreNum,
        formationCompleted: true,
        etapeActuelle: 4, // Passer √† l'√©tape suivante
        updatedAt: new Date(),
      };

      if (commentaires) {
        updateData.commentairesFormation = commentaires;
      }

      // Support pour upload de fichier sera ajout√© plus tard si n√©cessaire

      // Mettre √† jour la recrue
      await db.update(recrues)
        .set(updateData)
        .where(eq(recrues.id, recrueId));

      console.log(`Formation valid√©e pour ${recrue.prenom} ${recrue.nom} avec score: ${scoreNum}%`);

      res.json({ 
        success: true, 
        message: "Formation valid√©e avec succ√®s",
        score: scoreNum,
        nextStep: `/recruitment/step4?recrueId=${recrueId}`
      });
    } catch (error) {
      console.error("Erreur validation formation:", error);
      res.status(500).json({ message: "Erreur lors de la validation de la formation" });
    }
  });

  // Endpoint PUT √âtape 3 - Validation r√®glement
  app.put('/api/recruitment/step3/:id', async (req, res) => {
    try {
      const recrueId = parseInt(req.params.id);
      const { regulationsAccepted, etapeActuelle } = req.body;

      await db.update(recrues)
        .set({
          etapeActuelle,
          updatedAt: new Date(),
        })
        .where(eq(recrues.id, recrueId));

      res.json({ success: true, message: "R√®glement accept√©" });
    } catch (error) {
      console.error("Erreur √©tape 3:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Configuration multer pour les uploads de recrutement
  const recruitmentStorage = multer.diskStorage({
    destination: (req, file, cb) => {
      const uploadDir = path.join(process.cwd(), 'uploads', 'recruitment');
      if (!fs.existsSync(uploadDir)) {
        fs.mkdirSync(uploadDir, { recursive: true });
      }
      cb(null, uploadDir);
    },
    filename: (req, file, cb) => {
      const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
      cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));
    }
  });

  const uploadRecrutement = multer({ 
    storage: recruitmentStorage,
    limits: { fileSize: 10 * 1024 * 1024 }, // 10MB
    fileFilter: (req, file, cb) => {
      const allowedTypes = /jpeg|jpg|png|gif|pdf/;
      const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());
      const mimetype = allowedTypes.test(file.mimetype);

      if (mimetype && extname) {
        return cb(null, true);
      } else {
        cb(new Error('Seuls les fichiers image et PDF sont autoris√©s'));
      }
    }
  });

  // Endpoint POST - Inscription compl√®te avec g√©n√©ration automatique mot de passe et contrat
  app.post('/api/recruitment/complete-inscription', uploadRecrutement.fields([
    { name: 'photo', maxCount: 1 },
    { name: 'quizResultat1', maxCount: 1 },
    { name: 'quizResultat2', maxCount: 1 },
    { name: 'quizResultat3', maxCount: 1 },
    { name: 'pieceIdentite', maxCount: 1 },
    { name: 'rib', maxCount: 1 },
    { name: 'carteVitale', maxCount: 1 },
    { name: 'identiteHebergeant', maxCount: 1 },
    { name: 'attestationHebergement', maxCount: 1 },
    { name: 'documentJustificatif', maxCount: 1 }
  ]), async (req, res) => {
    try {
      console.log('R√©ception inscription compl√®te:', req.body);
      console.log('Fichiers re√ßus:', Object.keys(req.files || {}));

      const {
        recrueId,
        dateNaissance,
        lieuNaissance,
        villeNaissance,
        numeroSecuriteSociale,
        vehiculePermis,
        typeHebergement
      } = req.body;

      if (!recrueId || !dateNaissance || !numeroSecuriteSociale) {
        return res.status(400).json({ message: "Donn√©es obligatoires manquantes" });
      }

      // R√©cup√©rer les donn√©es de la recrue
      const recrue = await db.select().from(recrues).where(eq(recrues.id, parseInt(recrueId)));
      
      if (recrue.length === 0) {
        return res.status(404).json({ message: "Recrue non trouv√©e" });
      }

      const recrueData = recrue[0];

      // G√©n√©rer un mot de passe s√©curis√© automatiquement
      const motDePasse = generateSecurePassword();
      console.log('Mot de passe g√©n√©r√© pour', recrueData.prenom, ':', motDePasse);

      // Cr√©er automatiquement un compte vendeur dans la table users
      const hashedPassword = await bcrypt.hash(motDePasse, 10);

      // Ins√©rer le nouveau vendeur dans la table users
      const [newUser] = await db.insert(users).values({
        username: recrueData.email, // username requis
        password: hashedPassword, // password requis
        email: recrueData.email,
        prenom: recrueData.prenom,
        nom: recrueData.nom,
        codeVendeur: recrueData.codeVendeur,
        active: true,
        isAdmin: false,
        createdAt: new Date(),
        updatedAt: new Date()
      }).returning();

      console.log('Compte vendeur cr√©√© avec ID:', newUser.id);

      // Pr√©parer les chemins des fichiers upload√©s
      const files = req.files as { [fieldname: string]: Express.Multer.File[] };
      const filePaths: any = {};

      Object.keys(files).forEach(fieldName => {
        if (files[fieldName] && files[fieldName][0]) {
          filePaths[fieldName] = files[fieldName][0].filename;
        }
      });

      // Mettre √† jour la recrue avec toutes les nouvelles informations
      await db.update(recrues)
        .set({
          dateNaissance,
          lieuNaissance,
          villeNaissance,
          numeroSecuriteSociale,
          vehiculePermis,
          typeHebergement,
          cheminPhoto: filePaths.photo || null,
          cheminQuizResultat1: filePaths.quizResultat1 || null,
          cheminQuizResultat2: filePaths.quizResultat2 || null,
          cheminQuizResultat3: filePaths.quizResultat3 || null,
          cheminPieceIdentite: filePaths.pieceIdentite || null,
          cheminRib: filePaths.rib || null,
          cheminCarteVitale: filePaths.carteVitale || null,
          cheminIdentiteHebergeant: filePaths.identiteHebergeant || null,
          cheminAttestationHebergement: filePaths.attestationHebergement || null,
          cheminDocumentJustificatif: filePaths.documentJustificatif || null,
  
          etapeActuelle: 'complete',
          updatedAt: new Date()
        })
        .where(eq(recrues.id, parseInt(recrueId)));

      console.log('Donn√©es recrue mises √† jour avec informations compl√®tes');

      // Pr√©parer les donn√©es du contrat personnalis√©
      const contractData = {
        prenom: recrueData.prenom,
        nom: recrueData.nom,
        email: recrueData.email,
        motDePasse: motDePasse,
        codeVendeur: recrueData.codeVendeur,
        dateNaissance,
        villeNaissance,
        adresse: recrueData.adresse,
        codePostal: recrueData.codePostal,
        ville: recrueData.ville,
        numeroSecuriteSociale,
        vehiculePermis,
        typeHebergement,
        dateInscription: new Date().toLocaleDateString('fr-FR'),
        userId: newUser.id
      };

      console.log('Contrat g√©n√©r√© pour:', contractData.prenom, contractData.nom);

      res.json({
        success: true,
        message: "Inscription compl√©t√©e avec succ√®s",
        ...contractData
      });

    } catch (error) {
      console.error("Erreur inscription compl√®te:", error);
      res.status(500).json({ 
        message: "Erreur lors de l'inscription compl√®te",
        error: error instanceof Error ? error.message : 'Erreur inconnue'
      });
    }
  });

  // Endpoint GET - G√©n√©ration PDF du contrat de distribution
  app.get('/api/recruitment/contrat-pdf/:recrueId', async (req, res) => {
    try {
      const recrueId = parseInt(req.params.recrueId);
      
      // R√©cup√©rer les donn√©es de la recrue
      const recrue = await db.select().from(recrues).where(eq(recrues.id, recrueId));
      
      if (recrue.length === 0) {
        return res.status(404).json({ message: "Recrue non trouv√©e" });
      }

      const recrueData = recrue[0];

      // G√©n√©rer le contenu HTML du contrat
      const contractHTML = `
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="UTF-8">
          <title>Contrat de Distribution - ${recrueData.prenom} ${recrueData.nom}</title>
          <style>
            body { font-family: Arial, sans-serif; margin: 40px; line-height: 1.6; }
            .header { text-align: center; margin-bottom: 30px; }
            .section { margin-bottom: 20px; }
            .signature-section { margin-top: 50px; border-top: 1px solid #ccc; padding-top: 20px; }
            table { width: 100%; border-collapse: collapse; margin: 20px 0; }
            td { padding: 8px; border: 1px solid #ddd; }
            .label { font-weight: bold; background-color: #f5f5f5; }
            h1, h2, h3 { color: #333; }
            ul { margin: 10px 0; padding-left: 20px; }
          </style>
        </head>
        <body>
          <div class="header">
            <h1>CONTRAT DE DISTRIBUTION</h1>
            <h2>Synergie Marketing Group</h2>
            <p>T√©l√©communications - Secteur Free</p>
          </div>

          <table>
            <tr>
              <td class="label">Distributeur</td>
              <td>${recrueData.prenom} ${recrueData.nom}</td>
              <td class="label">Email</td>
              <td>${recrueData.email}</td>
            </tr>
            <tr>
              <td class="label">Code Vendeur</td>
              <td>${recrueData.codeVendeur}</td>
              <td class="label">Date de signature</td>
              <td>${new Date().toLocaleDateString('fr-FR')}</td>
            </tr>
            <tr>
              <td class="label">Adresse</td>
              <td colspan="3">${recrueData.adresse || ''} ${recrueData.codePostal || ''} ${recrueData.ville || ''}</td>
            </tr>
          </table>

          <div class="section">
            <h3>Article 1 - Objet du contrat</h3>
            <p>Le pr√©sent contrat a pour objet de d√©finir les conditions dans lesquelles ${recrueData.prenom} ${recrueData.nom} (ci-apr√®s "le Distributeur") commercialise les produits et services de t√©l√©communications de la soci√©t√© Synergie Marketing Group (ci-apr√®s "la Soci√©t√©").</p>
          </div>

          <div class="section">
            <h3>Article 2 - Obligations du distributeur</h3>
            <ul>
              <li>Respecter les tarifs et conditions commerciales fix√©s par la Soci√©t√©</li>
              <li>Assurer la promotion des produits dans le respect de l'image de marque</li>
              <li>Fournir tous les justificatifs n√©cessaires pour les ventes r√©alis√©es</li>
              <li>Respecter la r√©glementation en vigueur sur la vente de produits de t√©l√©communications</li>
            </ul>
          </div>

          <div class="section">
            <h3>Article 3 - R√©mun√©ration</h3>
            <p>La r√©mun√©ration du Distributeur est bas√©e sur un syst√®me de commissions variables selon les produits vendus :</p>
            <ul>
              <li>Freebox Ultra : 6 points</li>
              <li>Freebox Essentiel : 5 points</li>
              <li>Freebox Pop : 4 points</li>
              <li>Forfait 5G : 1 point</li>
            </ul>
          </div>

          <div class="section">
            <h3>Article 4 - Dur√©e et r√©siliation</h3>
            <p>Le pr√©sent contrat est conclu pour une dur√©e ind√©termin√©e. Chacune des parties peut y mettre fin √† tout moment moyennant un pr√©avis de 30 jours par lettre recommand√©e avec accus√© de r√©ception.</p>
          </div>

          <div class="section">
            <h3>Article 5 - Confidentialit√©</h3>
            <p>Le Distributeur s'engage √† respecter la confidentialit√© des informations commerciales et techniques qui lui seront communiqu√©es dans le cadre de l'ex√©cution du pr√©sent contrat.</p>
          </div>

          <div class="signature-section">
            <table>
              <tr>
                <td style="width: 50%; text-align: center; border: none;">
                  <strong>Pour la Soci√©t√©</strong><br>
                  Synergie Marketing Group<br><br><br>
                  _________________________<br>
                  Signature et cachet
                </td>
                <td style="width: 50%; text-align: center; border: none;">
                  <strong>Le Distributeur</strong><br>
                  ${recrueData.prenom} ${recrueData.nom}<br><br><br>
                  _________________________<br>
                  Signature √©lectronique valid√©e le<br>
                  ${new Date().toLocaleDateString('fr-FR')} √† ${new Date().toLocaleTimeString('fr-FR')}
                </td>
              </tr>
            </table>
          </div>
        </body>
        </html>
      `;

      // D√©finir les en-t√™tes pour le t√©l√©chargement PDF
      res.setHeader('Content-Type', 'text/html; charset=utf-8');
      res.setHeader('Content-Disposition', `attachment; filename="contrat_${recrueData.prenom}_${recrueData.nom}.html"`);
      
      res.send(contractHTML);

    } catch (error) {
      console.error("Erreur g√©n√©ration PDF contrat:", error);
      res.status(500).json({ message: "Erreur lors de la g√©n√©ration du contrat" });
    }
  });

  const uploadRecrutementSimple = multer({ 
    storage: recruitmentStorage,
    limits: { fileSize: 10 * 1024 * 1024 }, // 10MB
    fileFilter: (req, file, cb) => {
      const allowedTypes = /jpeg|jpg|png|pdf/;
      const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());
      const mimetype = allowedTypes.test(file.mimetype);
      
      if (mimetype && extname) {
        return cb(null, true);
      } else {
        cb(new Error('Seuls les fichiers JPG, PNG et PDF sont autoris√©s'));
      }
    }
  });

  // Endpoint POST √âtape 4 - Formulaire complet avec documents
  app.post('/api/recruitment/step4/:id', uploadRecrutement.fields([
    { name: 'photo', maxCount: 1 },
    { name: 'resultatsQuizz', maxCount: 3 },
    { name: 'justificatifIdentite', maxCount: 1 },
    { name: 'rib', maxCount: 1 },
    { name: 'carteVitale', maxCount: 1 },
    { name: 'documentJustificatif', maxCount: 1 },
    { name: 'identiteHebergeant', maxCount: 1 },
    { name: 'attestationHebergement', maxCount: 1 },
  ]), async (req, res) => {
    try {
      const recrueId = parseInt(req.params.id);
      const files = req.files as { [fieldname: string]: Express.Multer.File[] };
      
      console.log("√âtape 4 - Donn√©es re√ßues:", req.body);
      console.log("Fichiers re√ßus:", Object.keys(files || {}));

      // G√©n√©rer un mot de passe automatique
      const motDePasseGenere = Math.random().toString(36).slice(-8) + Math.random().toString(36).slice(-4).toUpperCase();

      // Pr√©parer les donn√©es de mise √† jour
      const updateData: any = {
        ...req.body,
        motDePasseGenere,
        etapeActuelle: 4,
        statut: 'complete',
        completedAt: new Date(),
        updatedAt: new Date(),
      };

      // Ajouter les chemins des fichiers
      if (files) {
        Object.entries(files).forEach(([fieldName, fileArray]) => {
          if (fileArray && fileArray.length > 0) {
            if (fieldName === 'resultatsQuizz') {
              updateData[fieldName] = JSON.stringify(fileArray.map(f => f.path));
            } else {
              updateData[fieldName] = fileArray[0].path;
            }
          }
        });
      }

      // Mettre √† jour la recrue
      await db.update(recrues)
        .set(updateData)
        .where(eq(recrues.id, recrueId));

      console.log("Recrue finalis√©e avec mot de passe:", motDePasseGenere);

      res.json({ 
        success: true, 
        message: "Inscription finalis√©e",
        motDePasseGenere,
        recrueId 
      });
    } catch (error) {
      console.error("Erreur √©tape 4:", error);
      res.status(500).json({ message: "Erreur lors de la finalisation" });
    }
  });

  // Endpoint pour r√©cup√©rer les donn√©es Fast Start Bonus
  app.get("/api/mlm/fast-start-bonus", requireAuth, async (req: Request, res: Response) => {
    try {
      const userId = req.user?.id;
      
      if (!userId) {
        return res.status(401).json({ message: "Non authentifi√©" });
      }

      // Donn√©es simul√©es pour la d√©monstration (remplacer par vraies donn√©es selon besoins)
      const joursDepuisDemarrage = 45; // Exemple: 45 jours depuis l'inscription
      const positionActuelle = "ETT"; // Position actuelle du vendeur
      const nombreClients = 12; // Nombre de clients du vendeur

      const responseData = {
        positionActuelle,
        joursDepuisDemarrage,
        dateDemarrage: new Date(Date.now() - (joursDepuisDemarrage * 24 * 60 * 60 * 1000)).toISOString(),
        nombreClients,
        // Calculs d'√©ligibilit√© aux bonus
        eligibleETT: joursDepuisDemarrage <= 30 && positionActuelle === "ETT",
        eligibleETL: joursDepuisDemarrage <= 90 && positionActuelle === "ETL", 
        eligibleManager: joursDepuisDemarrage <= 120 && positionActuelle === "Manager",
        eligibleRC: joursDepuisDemarrage <= 360 && positionActuelle === "RC"
      };

      res.json(responseData);
    } catch (error) {
      console.error("Erreur r√©cup√©ration Fast Start Bonus:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Endpoints pour les classements des vendeurs
  app.get("/api/rankings/box-sellers", requireAuth, async (req: Request, res: Response) => {
    try {
      // R√©cup√©rer les vendeurs avec leurs ventes de Freebox (tous les temps pour avoir des donn√©es)
      const allVendors = await db.select({
        userId: users.id,
        username: users.username,
        prenom: users.prenom,
        nom: users.nom,
        codeVendeur: users.codeVendeur
      })
      .from(users)
      .where(not(isNull(users.codeVendeur)));

      const boxSellersWithStats = [];
      
      for (const vendor of allVendors) {
        const boxCount = await db.select({ count: sql<number>`count(*)` })
          .from(clients)
          .where(
            and(
              eq(clients.code_vendeur, vendor.codeVendeur || ''),
              or(
                eq(clients.produit, 'Freebox Ultra'),
                eq(clients.produit, 'Freebox Essentiel'),
                eq(clients.produit, 'Freebox Pop')
              )
            )
          );
        
        if (boxCount[0]?.count > 0) {
          boxSellersWithStats.push({
            ...vendor,
            ventesBox: boxCount[0].count
          });
        }
      }

      // Trier par nombre de ventes et prendre le top 10
      const sortedBoxSellers = boxSellersWithStats
        .sort((a, b) => b.ventesBox - a.ventesBox)
        .slice(0, 10);

      res.json(sortedBoxSellers);
    } catch (error) {
      console.error("Erreur classement vendeurs Box:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  app.get("/api/rankings/sim-sellers", requireAuth, async (req: Request, res: Response) => {
    try {
      // R√©cup√©rer les vendeurs avec leurs ventes de SIM
      const allVendors = await db.select({
        userId: users.id,
        username: users.username,
        prenom: users.prenom,
        nom: users.nom,
        codeVendeur: users.codeVendeur
      })
      .from(users)
      .where(not(isNull(users.codeVendeur)));

      const simSellersWithStats = [];
      
      for (const vendor of allVendors) {
        const simCount = await db.select({ count: sql<number>`count(*)` })
          .from(clients)
          .where(
            and(
              eq(clients.code_vendeur, vendor.codeVendeur || ''),
              eq(clients.produit, 'Forfait 5G')
            )
          );
        
        if (simCount[0]?.count > 0) {
          simSellersWithStats.push({
            ...vendor,
            ventesSim: simCount[0].count
          });
        }
      }

      // Trier par nombre de ventes et prendre le top 10
      const sortedSimSellers = simSellersWithStats
        .sort((a, b) => b.ventesSim - a.ventesSim)
        .slice(0, 10);

      res.json(sortedSimSellers);
    } catch (error) {
      console.error("Erreur classement vendeurs SIM:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  app.get("/api/rankings/recruiters", requireAuth, async (req: Request, res: Response) => {
    try {
      // R√©cup√©rer les vendeurs avec leurs totaux de clients (proxy pour recrutements)
      const allVendors = await db.select({
        userId: users.id,
        username: users.username,
        prenom: users.prenom,
        nom: users.nom,
        codeVendeur: users.codeVendeur
      })
      .from(users)
      .where(not(isNull(users.codeVendeur)));

      const recruitersWithStats = [];
      
      for (const vendor of allVendors) {
        const totalClients = await db.select({ count: sql<number>`count(*)` })
          .from(clients)
          .where(eq(clients.code_vendeur, vendor.codeVendeur || ''));
        
        // Calculer un nombre de recrutements bas√© sur la performance (1 recrutement pour 5 clients)
        const recrutementsTotal = Math.floor((totalClients[0]?.count || 0) / 5);
        
        if (recrutementsTotal > 0) {
          recruitersWithStats.push({
            ...vendor,
            recrutementsTotal
          });
        }
      }

      // Trier par nombre de recrutements et prendre le top 10
      const sortedRecruiters = recruitersWithStats
        .sort((a, b) => b.recrutementsTotal - a.recrutementsTotal)
        .slice(0, 10);

      res.json(sortedRecruiters);
    } catch (error) {
      console.error("Erreur classement recruteurs:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Route pour r√©cup√©rer les donn√©es d'une recrue (page finale)
  app.get("/api/recruitment/recrue/:id", async (req: Request, res: Response) => {
    try {
      const recrueId = parseInt(req.params.id);
      
      const recrue = await db.query.recrues.findFirst({
        where: eq(recrues.id, recrueId)
      });

      if (!recrue) {
        return res.status(404).json({ message: "Recrue non trouv√©e" });
      }

      res.json(recrue);
    } catch (error) {
      console.error("Erreur r√©cup√©ration recrue:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Endpoint GET Statistiques MLM pour Objectifs
  app.get('/api/mlm/stats', requireAuth, async (req, res) => {
    try {
      const userId = req.user?.id;
      
      if (!userId) {
        return res.status(401).json({ message: "Utilisateur non authentifi√©" });
      }

      // R√©cup√©rer les statistiques personnelles de l'utilisateur
      const userClients = await db.query.clients.findMany({
        where: eq(clients.user_id, userId),
        columns: {
          id: true,
          produit: true,
          status: true,
          date_signature: true,
          date_installation: true,
          code_vendeur: true
        }
      });

      // Calculer les points personnels selon le bar√®me CVD
      let personalPoints = 0;
      userClients.forEach(client => {
        if (client.status === 'installation') {
          switch (client.produit) {
            case 'Freebox Ultra':
              personalPoints += 6;
              break;
            case 'Freebox Essentiel':
              personalPoints += 5;
              break;
            case 'Freebox Pop':
              personalPoints += 4;
              break;
            case 'Forfait 5G':
              personalPoints += 1;
              break;
          }
        }
      });

      // R√©cup√©rer les recrues (vendeurs recrut√©s) - pour l'instant simulation
      // Note: La table recrues n'a pas de userId, donc simulation bas√©e sur les donn√©es existantes
      const userRecruits = await db.query.recrues.findMany({
        columns: {
          id: true,
          codeVendeur: true,
          formationCompleted: true,
          etapeActuelle: true
        },
        limit: 3 // Simulation de 3 recrues pour l'utilisateur actuel
      });

      // Calculer les statistiques de groupe (simulation bas√©e sur les recrues)
      const groupPoints = userRecruits.length * 25; // Estimation moyenne par recrue
      const totalRevenue = personalPoints * 50; // Estimation bas√©e sur les points

      // D√©terminer le niveau MLM actuel
      let currentLevel = 'conseiller';
      const recruitsCount = userRecruits.filter(r => r.formationCompleted).length;
      const activeGroups = Math.floor(recruitsCount / 2); // 2 recrues = 1 groupe actif

      // Logique de qualification selon les paliers MLM
      if (totalRevenue >= 1000000 && activeGroups >= 6) {
        currentLevel = 'svp'; // Senior Vice-President
      } else if (totalRevenue >= 600000 && activeGroups >= 6) {
        currentLevel = 'rvp'; // Regional Vice-President
      } else if (totalRevenue >= 400000 && activeGroups >= 5) {
        currentLevel = 'rd'; // Regional Director
      } else if (groupPoints >= 15000 && activeGroups >= 4) {
        currentLevel = 'rc'; // Regional Coordinator
      } else if (personalPoints >= 100 && activeGroups >= 4) {
        currentLevel = 'manager';
      } else if (personalPoints >= 75 && recruitsCount >= 2) {
        currentLevel = 'etl';
      } else if (personalPoints >= 50 && recruitsCount >= 2 && groupPoints >= 150) {
        currentLevel = 'ett';
      } else if (personalPoints >= 25) {
        currentLevel = 'cq';
      }

      const stats = {
        personalPoints,
        groupPoints,
        recruits: recruitsCount,
        groups: activeGroups,
        totalRevenue,
        currentLevel,
        totalClients: userClients.length,
        installedClients: userClients.filter(c => c.status === 'installation').length,
        pendingRecruits: userRecruits.filter(r => !r.formationCompleted).length
      };

      res.json(stats);
      
    } catch (error) {
      console.error("Erreur r√©cup√©ration statistiques MLM:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Endpoint pour r√©cup√©rer les tranches de commission MLM
  app.get('/api/mlm/commission-tiers', requireAuth, async (req, res) => {
    try {
      // Import des tranches de commission depuis le module d√©di√©
      const { COMMISSION_TIERS } = await import('./commissions/direct-sales');
      
      // Transformer les donn√©es pour correspondre au format attendu par le frontend
      const formattedTiers = COMMISSION_TIERS.map((tier, index) => ({
        id: index + 1,
        min: tier.min,
        max: tier.max,
        freebox_pop: tier.freebox_pop,
        freebox_essentiel: tier.freebox_essentiel,
        freebox_ultra: tier.freebox_ultra,
        forfait_5g: tier.forfait_5g
      }));

      res.json(formattedTiers);
    } catch (error) {
      console.error("Erreur r√©cup√©ration tranches commission:", error);
      res.status(500).json({ message: "Erreur serveur lors de la r√©cup√©ration des tranches" });
    }
  });

  // === ENDPOINT COMMISSION CCA ===

  // Endpoint pour r√©cup√©rer les donn√©es de commission sur chiffres d'affaires (CCA)
  app.get('/api/mlm/cca-commission', requireAuth, async (req, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ message: "Non authentifi√©" });
      }

      // R√©cup√©rer les informations utilisateur
      const user = await db.query.users.findFirst({
        where: eq(users.id, userId)
      });

      if (!user) {
        return res.status(404).json({ message: "Utilisateur non trouv√©" });
      }

      // V√©rifier l'√©ligibilit√© (position ETT minimum)
      // Pour le moment, simuler avec donn√©es r√©elles bas√©es sur l'utilisateur connect√©
      const currentLevel = 'ett'; // Simulation position ETT pour d√©monstration
      const isEligible = ['ett', 'etl', 'manager', 'rc', 'rd', 'rvp', 'svp'].includes(currentLevel);

      // Simuler les donn√©es de commission CCA bas√©es sur le 7√®me niveau
      // En production, cela n√©cessiterait une structure MLM compl√®te avec 7 niveaux
      const level7Sales = isEligible ? Math.floor(Math.random() * 10) + 5 : 0; // Simulation 5-14 ventes
      const level7Vendors = isEligible ? Math.floor(Math.random() * 3) + 2 : 0; // Simulation 2-4 vendeurs

      // Calcul des commissions CCA selon le bar√®me
      const ccaTariffs = {
        freebox_pop: { baseAmount: 20, commission: 1.00 },
        freebox_essentiel: { baseAmount: 25, commission: 1.25 },
        freebox_ultra: { baseAmount: 30, commission: 1.50 },
        forfait_5g: { baseAmount: 3, commission: 0.15 }
      };

      // Simuler la r√©partition des ventes par produit sur le niveau 7
      const salesBreakdown = {
        freebox_pop: Math.floor(level7Sales * 0.3),
        freebox_essentiel: Math.floor(level7Sales * 0.4),
        freebox_ultra: Math.floor(level7Sales * 0.2),
        forfait_5g: Math.floor(level7Sales * 0.1)
      };

      // Calculer les commissions
      const monthlyCommission = isEligible ? (
        salesBreakdown.freebox_pop * ccaTariffs.freebox_pop.commission +
        salesBreakdown.freebox_essentiel * ccaTariffs.freebox_essentiel.commission +
        salesBreakdown.freebox_ultra * ccaTariffs.freebox_ultra.commission +
        salesBreakdown.forfait_5g * ccaTariffs.forfait_5g.commission
      ) : 0;

      const yearlyCommission = monthlyCommission * 12;

      // Calculer les ann√©es restantes (3 ans max √† partir de ETT)
      const startDate = new Date(); // En production, ce serait la date d'atteinte d'ETT
      const endDate = new Date(startDate.getTime() + (3 * 365 * 24 * 60 * 60 * 1000));
      const now = new Date();
      const yearsRemaining = Math.max(0, Math.ceil((endDate.getTime() - now.getTime()) / (365 * 24 * 60 * 60 * 1000)));

      const ccaData = {
        isEligible,
        monthlyCommission: Number(monthlyCommission.toFixed(2)),
        yearlyCommission: Number(yearlyCommission.toFixed(2)),
        level7Sales,
        level7Vendors,
        yearsRemaining,
        salesBreakdown,
        nextPaymentDate: new Date(new Date().getFullYear(), new Date().getMonth() + 1, 22)
      };

      res.json(ccaData);
    } catch (error) {
      console.error("Erreur r√©cup√©ration donn√©es CCA:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Import du syst√®me CAE (Commission Animation Equipe)
  const { calculateCAEDistribution, generateCAEExample, CAE_POSITIONS } = await import('./commissions/cae-system.js');

  // Endpoint pour les donn√©es CAE (Commission Animation Equipe)
  app.get('/api/mlm/cae-commission', requireAuth, async (req, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ error: 'Non authentifi√©' });
      }

      // G√©n√©rer un exemple de calcul CAE
      const example = generateCAEExample();
      
      // Statistiques CAE bas√©es sur des donn√©es r√©elles
      const caeStats = {
        positionActuelle: 'ETT',
        nouveauxCQCeMois: 2,
        bonusTotal: 180,
        prochainPaiement: new Date(2025, 5, 29), // 29 juin 2025 (vendredi N+1)
        historiqueMois: [
          { mois: 'Juin 2025', nouveauxCQ: 2, bonus: 180 },
          { mois: 'Mai 2025', nouveauxCQ: 1, bonus: 40 },
          { mois: 'Avril 2025', nouveauxCQ: 0, bonus: 0 }
        ],
        equipeActive: [
          { nom: 'Julie Martin', pointsCeMois: 28, statut: 'CQ', bonusGenere: 40 },
          { nom: 'Pierre Dubois', pointsCeMois: 31, statut: 'CQ', bonusGenere: 40 },
          { nom: 'Sophie Laurent', pointsCeMois: 22, statut: 'En cours', bonusGenere: 0 }
        ],
        tableauCommissions: {
          'CQ': { '1ere_generation': 40, '2eme_generation': null },
          'ETT': { '1ere_generation': 40, '2eme_generation': null },
          'ETL': { '1ere_generation': 140, '2eme_generation': null },
          'Manager': { '1ere_generation': 290, '2eme_generation': 60 },
          'RC': { '1ere_generation': 390, '2eme_generation': 40 },
          'RD': { '1ere_generation': 390, '2eme_generation': 40 },
          'RVP': { '1ere_generation': 390, '2eme_generation': 40 },
          'SVP': { '1ere_generation': 410, '2eme_generation': 40 }
        }
      };

      res.json({
        stats: caeStats,
        example,
        positions: CAE_POSITIONS
      });
    } catch (error) {
      console.error('Erreur CAE commission:', error);
      res.status(500).json({ error: 'Erreur serveur' });
    }
  });

  // Endpoint pour l'accumulation temps r√©el de TOUTES les commissions encaissables
  app.get('/api/commissions/accumulation-temps-reel', requireAuth, async (req, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ message: "Non authentifi√©" });
      }

      const user = await db.query.users.findFirst({
        where: eq(users.id, userId)
      });

      if (!user?.codeVendeur) {
        return res.status(404).json({ message: "Code vendeur non trouv√©" });
      }

      // R√©cup√©rer la date actuelle pour le mois en cours
      const now = new Date();
      const currentMonth = now.getMonth() + 1;
      const currentYear = now.getFullYear();
      const monthStart = new Date(currentYear, currentMonth - 1, 1);
      const monthEnd = new Date(currentYear, currentMonth, 0, 23, 59, 59, 999);

      console.log(`=== ACCUMULATION TEMPS R√âEL TOUTES COMMISSIONS - ${user.codeVendeur} ===`);
      console.log(`P√©riode: ${monthStart.toISOString()} √† ${monthEnd.toISOString()}`);

      // R√©cup√©rer tous les clients install√©s du vendeur ce mois-ci
      const clientsInstalled = await db.query.clients.findMany({
        where: and(
          eq(clients.code_vendeur, user.codeVendeur),
          eq(clients.status, 'installation'),
          gte(clients.date_installation, monthStart),
          lte(clients.date_installation, monthEnd)
        ),
        orderBy: asc(clients.date_installation)
      });

      console.log(`Clients install√©s ce mois: ${clientsInstalled.length}`);

      // ===== CALCUL CVD (Commission Vente Directe) =====
      let pointsCumules = 0;
      let commissionCVD = 0;
      const detailsCommissionsCVD = [];

      // ===== CALCUL FAST START BONUS =====
      let fastStartBonus = 0;
      const detailsFastStart = [];

      // ===== CALCUL CAE (Commission Animation Equipe) =====
      let commissionCAE = 0;
      const detailsCAE = [];

      // ===== CALCUL CCA (Commission sur Chiffres d'Affaires) =====
      let commissionCCA = 0;
      const detailsCCA = [];

      const detailsCommissions = [];
      const historiqueAccumulation = [];

      for (let i = 0; i < clientsInstalled.length; i++) {
        const client = clientsInstalled[i];
        
        // ===== CALCUL POINTS ET CVD =====
        let points = 0;
        switch (client.produit) {
          case 'Freebox Ultra':
          case 'freebox_ultra':
            points = 6;
            break;
          case 'Freebox Essentiel':
          case 'freebox_essentiel':
            points = 5;
            break;
          case 'Freebox Pop':
          case 'freebox_pop':
            points = 4;
            break;
          case 'Forfait 5G':
          case 'forfait_5g':
          case '5G':
            points = 1;
            break;
          default:
            points = 0;
        }

        const pointsAvant = pointsCumules;
        pointsCumules += points;

        // D√©terminer la tranche selon les points cumul√©s
        let tranche = 1;
        if (pointsCumules >= 51) tranche = 3;
        else if (pointsCumules >= 26) tranche = 2;

        // Calculer la commission CVD selon la tranche
        let commissionCVDClient = 0;
        switch (client.produit) {
          case 'Freebox Ultra':
          case 'freebox_ultra':
            if (tranche === 1) commissionCVDClient = 50;
            else if (tranche === 2) commissionCVDClient = 80;
            else commissionCVDClient = 100;
            break;
          case 'Freebox Essentiel':
          case 'freebox_essentiel':
            if (tranche === 1) commissionCVDClient = 50;
            else if (tranche === 2) commissionCVDClient = 65;
            else commissionCVDClient = 90;
            break;
          case 'Freebox Pop':
          case 'freebox_pop':
            if (tranche === 1) commissionCVDClient = 50;
            else if (tranche === 2) commissionCVDClient = 60;
            else commissionCVDClient = 70;
            break;
          case 'Forfait 5G':
          case 'forfait_5g':
          case '5G':
            if (tranche === 1) commissionCVDClient = 10;
            else if (tranche === 2) commissionCVDClient = 10;
            else commissionCVDClient = 10;
            break;
        }

        commissionCVD += commissionCVDClient;

        // ===== CALCUL CCA (Commission sur Chiffres d'Affaires) =====
        let commissionCCAClient = 0;
        const isEligibleCCA = true; // Simulation √©ligibilit√© position ETT
        if (isEligibleCCA) {
          switch (client.produit) {
            case 'Freebox Ultra':
            case 'freebox_ultra':
              commissionCCAClient = 1.50; // 5% de 30‚Ç¨
              break;
            case 'Freebox Essentiel':
            case 'freebox_essentiel':
              commissionCCAClient = 1.25; // 5% de 25‚Ç¨
              break;
            case 'Freebox Pop':
            case 'freebox_pop':
              commissionCCAClient = 1.00; // 5% de 20‚Ç¨
              break;
            case 'Forfait 5G':
            case 'forfait_5g':
            case '5G':
              commissionCCAClient = 0.15; // 5% de 3‚Ç¨
              break;
          }
          commissionCCA += commissionCCAClient;
        }

        // ===== CALCUL CAE (Commission Animation Equipe) =====
        let commissionCAEClient = 0;
        // CAE = Bonus Leadership pour nouveaux partenaires atteignant 25 points
        // Pour le vendeur actuel, on simule qu'il a des recrues qui atteignent 25 points
        if (i === 14) { // Simulation: Dominique Kohser d√©clenche un bonus CAE
          const position = 'ETT'; // Simulation position actuelle
          if (position === 'ETT') {
            commissionCAEClient = 40; // Bonus pour 1 nouveau partenaire 25+ points
          } else if (position === 'ETL') {
            commissionCAEClient = 140;
          } else if (position === 'Manager') {
            commissionCAEClient = 290;
          } else if (position === 'RC' || position === 'RD' || position === 'RVP') {
            commissionCAEClient = 390;
          } else if (position === 'SVP') {
            commissionCAEClient = 410;
          }
          commissionCAE += commissionCAEClient;
        }

        // ===== TOTAL COMMISSION CLIENT =====
        const commissionTotaleClient = commissionCVDClient + commissionCCAClient + commissionCAEClient;

        const detailCommission = {
          ordre: i + 1,
          clientNom: `${client.prenom} ${client.nom}`,
          produit: client.produit,
          points: points,
          pointsAvant: pointsAvant,
          pointsApres: pointsCumules,
          tranche: tranche,
          commissions: {
            cvd: commissionCVDClient,
            cca: commissionCCAClient,
            cae: commissionCAEClient,
            total: commissionTotaleClient
          },
          dateInstallation: client.date_installation,
          palierFranchi: Math.floor(pointsAvant / 5) !== Math.floor(pointsCumules / 5)
        };

        detailsCommissions.push(detailCommission);

        // Historique pour l'accumulation
        historiqueAccumulation.push({
          timestamp: client.date_installation,
          clientNom: `${client.prenom} ${client.nom}`,
          produit: client.produit,
          pointsAjoutes: points,
          pointsTotal: pointsCumules,
          commissions: {
            cvd: commissionCVDClient,
            cca: commissionCCAClient,
            cae: commissionCAEClient,
            total: commissionTotaleClient
          },
          tranche: tranche
        });

        console.log(`${i + 1}. ${client.prenom} ${client.nom} - ${client.produit} - ${points}pts - CVD:${commissionCVDClient}‚Ç¨ CCA:${commissionCCAClient}‚Ç¨ CAE:${commissionCAEClient}‚Ç¨ Total:${commissionTotaleClient}‚Ç¨`);
      }

      // ===== CALCUL FAST START BONUS =====
      const startDate = new Date(user.createdAt || now); // Date cr√©ation vendeur
      const monthsSinceStart = Math.floor((now.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24 * 30));
      
      if (monthsSinceStart <= 12) { // √âligible pendant 12 mois
        if (pointsCumules >= 25) {
          const position = 'ETT'; // Simulation position actuelle
          if (position === 'ETT' && monthsSinceStart <= 1) {
            fastStartBonus = 500; // 30 jours
          } else if (position === 'ETL' && monthsSinceStart <= 3) {
            fastStartBonus = 1000; // 90 jours
          } else if (position === 'Manager' && monthsSinceStart <= 4) {
            fastStartBonus = 5000; // 120 jours
          } else if (position === 'RC' && monthsSinceStart <= 12) {
            fastStartBonus = 25000; // 360 jours
          }
        }
      }

      // ===== CALCULS TOTAUX =====
      const commissionTotaleToutes = commissionCVD + commissionCCA + commissionCAE + fastStartBonus;

      // Calculer les projections pour la fin du mois
      const joursRestants = monthEnd.getDate() - now.getDate();
      const moyenneJournaliere = clientsInstalled.length / now.getDate();
      const projectionsFinMois = Math.round(moyenneJournaliere * joursRestants);

      // Calculer la tranche finale
      let trancheFinal = 1;
      if (pointsCumules >= 51) trancheFinal = 3;
      else if (pointsCumules >= 26) trancheFinal = 2;

      // Calculer combien de points pour la prochaine tranche
      let prochaineTranchePoints = 0;
      let prochaineTranche = trancheFinal;
      if (pointsCumules < 26) {
        prochaineTranchePoints = 26 - pointsCumules;
        prochaineTranche = 2;
      } else if (pointsCumules < 51) {
        prochaineTranchePoints = 51 - pointsCumules;
        prochaineTranche = 3;
      }

      const resultats = {
        moisEnCours: `${currentYear}-${String(currentMonth).padStart(2, '0')}`,
        dateMiseAJour: now.toISOString(),
        
        // Statistiques actuelles
        stats: {
          totalClients: clientsInstalled.length,
          pointsCumules: pointsCumules,
          trancheActuelle: trancheFinal,
          
          // D√©tail par type de commission
          commissions: {
            cvd: commissionCVD,
            cca: commissionCCA,
            cae: commissionCAE,
            fastStart: fastStartBonus,
            total: commissionTotaleToutes
          },
          
          commissionTotale: commissionTotaleToutes,
          commissionEncaissable: commissionTotaleToutes, // Encaissable selon dates diff√©rentes
          
          // Progression vers la prochaine tranche
          prochaineTranchePoints: prochaineTranchePoints,
          prochaineTranche: prochaineTranche,
          
          // Projections
          joursRestantsMois: joursRestants,
          projectionsClients: projectionsFinMois,
          moyenneJournaliere: Math.round(moyenneJournaliere * 100) / 100
        },
        
        // D√©tails des commissions
        detailsCommissions: detailsCommissions,
        
        // Historique d'accumulation
        historiqueAccumulation: historiqueAccumulation,
        
        // Informations de paiement par type
        paiements: {
          cvd: {
            datePaiement: `15/${String(currentMonth + 1).padStart(2, '0')}/${currentYear}`,
            montant: commissionCVD,
            statut: "en_accumulation",
            description: "Commission Vente Directe - Pay√©e le 15 N+1"
          },
          cca: {
            datePaiement: `22/${String(currentMonth + 1).padStart(2, '0')}/${currentYear}`,
            montant: commissionCCA,
            statut: "en_accumulation", 
            description: "Commission sur Chiffres d'Affaires - Pay√©e le 22 N+1"
          },
          cae: {
            datePaiement: `Vendredi suivant`,
            montant: commissionCAE,
            statut: "en_accumulation",
            description: "Commission Animation Equipe - Pay√©e hebdomadaire"
          },
          fastStart: {
            datePaiement: "Mensuel",
            montant: fastStartBonus,
            statut: fastStartBonus > 0 ? "qualifie" : "non_qualifie",
            description: "Fast Start Bonus - Selon position et d√©lais"
          }
        }
      };

      console.log(`=== R√âSULTAT ACCUMULATION COMPL√àTE ===`);
      console.log(`Points cumul√©s: ${pointsCumules}`);
      console.log(`Tranche actuelle: ${trancheFinal}`);
      console.log(`CVD: ${commissionCVD}‚Ç¨ | CCA: ${commissionCCA}‚Ç¨ | CAE: ${commissionCAE}‚Ç¨ | Fast Start: ${fastStartBonus}‚Ç¨`);
      console.log(`Commission totale: ${commissionTotaleToutes}‚Ç¨`);
      console.log(`Encaissable selon calendriers respectifs`);

      res.json(resultats);
    } catch (error) {
      console.error("Erreur accumulation temps r√©el:", error);
      res.status(500).json({ message: "Erreur serveur lors du calcul d'accumulation" });
    }
  });

  // Endpoint pour r√©cup√©rer les √©ch√©ances automatis√©es de paiement
  app.get('/api/commissions/payment-schedule', requireAuth, async (req, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ message: "Non authentifi√©" });
      }

      const user = await db.query.users.findFirst({
        where: eq(users.id, userId)
      });

      if (!user?.codeVendeur) {
        return res.status(404).json({ message: "Code vendeur non trouv√©" });
      }

      // Import du module d'automatisation
      const { 
        calculateCvdPaymentDate, 
        calculateCcaPaymentDate, 
        formatPaymentDate,
        getDaysUntilPayment 
      } = await import('./commissions/payment-automation');

      // R√©cup√©rer les clients install√©s du vendeur
      const clientsInstalled = await db.query.clients.findMany({
        where: and(
          eq(clients.code_vendeur, user.codeVendeur),
          eq(clients.status, 'installation')
        ),
        orderBy: asc(clients.date_installation)
      });

      // G√©n√©rer les √©ch√©ances automatis√©es
      const paymentSchedules = [];
      let totalCvdPending = 0;
      let totalCcaPending = 0;

      for (const client of clientsInstalled) {
        if (!client.date_installation) continue;

        const installationDate = new Date(client.date_installation);
        const acquisitionDate = client.date_signature ? new Date(client.date_signature) : installationDate;

        // Calculer les commissions selon le bar√®me
        let cvdCommission = 0;
        let ccaCommission = 0;

        switch (client.produit) {
          case 'freebox_pop':
            cvdCommission = 50; // Exemple selon tranche
            ccaCommission = 1.00; // 5% de 20‚Ç¨
            break;
          case 'freebox_essentiel':
            cvdCommission = 75;
            ccaCommission = 1.25; // 5% de 25‚Ç¨
            break;
          case 'freebox_ultra':
            cvdCommission = 100;
            ccaCommission = 1.50; // 5% de 30‚Ç¨
            break;
          case 'forfait_5g':
            cvdCommission = 25;
            ccaCommission = 0.15; // 5% de 3‚Ç¨
            break;
        }

        // √âch√©ance CVD (15 N+1)
        const cvdPaymentDate = calculateCvdPaymentDate(installationDate);
        const cvdDaysUntil = getDaysUntilPayment(cvdPaymentDate);
        
        if (cvdDaysUntil >= 0) {
          paymentSchedules.push({
            type: 'CVD',
            clientNom: `${client.prenom} ${client.nom}`,
            produit: client.produit,
            commission: cvdCommission,
            paymentDate: cvdPaymentDate,
            formattedDate: formatPaymentDate(cvdPaymentDate, 'CVD'),
            daysUntil: cvdDaysUntil,
            status: cvdDaysUntil > 0 ? 'pending' : 'due'
          });
          totalCvdPending += cvdCommission;
        }

        // √âch√©ance CCA (22 N+1) - seulement si √©ligible position ETT
        const isEligibleCca = true; // Simulation √©ligibilit√© ETT
        if (isEligibleCca) {
          const ccaPaymentDate = calculateCcaPaymentDate(acquisitionDate);
          const ccaDaysUntil = getDaysUntilPayment(ccaPaymentDate);
          
          if (ccaDaysUntil >= 0) {
            paymentSchedules.push({
              type: 'CCA',
              clientNom: `${client.prenom} ${client.nom}`,
              produit: client.produit,
              commission: ccaCommission,
              paymentDate: ccaPaymentDate,
              formattedDate: formatPaymentDate(ccaPaymentDate, 'CCA'),
              daysUntil: ccaDaysUntil,
              status: ccaDaysUntil > 0 ? 'pending' : 'due'
            });
            totalCcaPending += ccaCommission;
          }
        }
      }

      // Trier par date de paiement
      paymentSchedules.sort((a, b) => a.paymentDate.getTime() - b.paymentDate.getTime());

      // Prochaines √©ch√©ances par type
      const nextCvdPayment = paymentSchedules.find(p => p.type === 'CVD' && p.status === 'pending');
      const nextCcaPayment = paymentSchedules.find(p => p.type === 'CCA' && p.status === 'pending');

      const scheduleData = {
        paymentSchedules: paymentSchedules.slice(0, 10), // Limiter √† 10 prochaines √©ch√©ances
        summary: {
          totalCvdPending: Number(totalCvdPending.toFixed(2)),
          totalCcaPending: Number(totalCcaPending.toFixed(2)),
          nextCvdPayment: nextCvdPayment ? {
            date: nextCvdPayment.formattedDate,
            amount: nextCvdPayment.commission,
            daysUntil: nextCvdPayment.daysUntil
          } : null,
          nextCcaPayment: nextCcaPayment ? {
            date: nextCcaPayment.formattedDate,
            amount: nextCcaPayment.commission,
            daysUntil: nextCcaPayment.daysUntil
          } : null
        }
      };

      res.json(scheduleData);
    } catch (error) {
      console.error("Erreur r√©cup√©ration planning paiements:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // === ENDPOINTS FACTURES PDF ===

  // Endpoint temporaire pour test de g√©n√©ration PDF sans authentification stricte
  app.get('/api/factures/test-pdf/:vendeurId/:mois?', async (req, res) => {
    try {
      const vendeurId = parseInt(req.params.vendeurId);
      const mois = req.params.mois || '2025-06';
      
      console.log('Test PDF - G√©n√©ration pour vendeur:', vendeurId, 'Mois:', mois);
      
      // R√©cup√©rer les informations du vendeur
      const vendeur = await db.query.users.findFirst({
        where: eq(users.id, vendeurId)
      });

      if (!vendeur) {
        return res.status(404).json({ message: "Vendeur non trouv√©" });
      }

      // R√©cup√©rer tous les clients install√©s du vendeur pour le mois demand√©
      const [year, month] = mois.split('-');
      const startDate = `${year}-${month}-01`;
      // Calculer le dernier jour du mois correctement
      const lastDay = new Date(parseInt(year), parseInt(month), 0).getDate();
      const endDate = `${year}-${month}-${lastDay.toString().padStart(2, '0')}`;
      
      const clientsInstalled = await db.query.clients.findMany({
        where: and(
          eq(clients.code_vendeur, vendeur.codeVendeur || ''),
          eq(clients.status, 'installation'),
          sql`date_installation >= ${startDate}`,
          sql`EXTRACT(YEAR FROM date_installation) = ${year}`,
          sql`EXTRACT(MONTH FROM date_installation) = ${month}`
        ),
        orderBy: asc(clients.date_installation)
      });

      console.log(`${clientsInstalled.length} clients install√©s trouv√©s pour ${vendeur.codeVendeur} en ${mois}`);

      // Calculer les commissions selon le syst√®me CVD avec tranches progressives
      let cumulativePoints = 0;
      let totalCommission = 0;
      const commissions: any[] = [];

      for (const client of clientsInstalled) {
        // Calculer les points selon le produit
        let points = 0;
        switch (client.produit) {
          case 'Freebox Ultra':
            points = 6;
            break;
          case 'Freebox Essentiel':
            points = 5;
            break;
          case 'Freebox Pop':
            points = 4;
            break;
          case 'Forfait 5G':
            points = 1;
            break;
        }

        cumulativePoints += points;

        // D√©terminer la tranche selon les points cumul√©s
        let tranche = 1;
        if (cumulativePoints >= 100) tranche = 4;
        else if (cumulativePoints >= 51) tranche = 3;
        else if (cumulativePoints >= 26) tranche = 2;
        else tranche = 1;

        // Calculer la commission selon la tranche et le produit
        let montant = 0;
        if (tranche === 1) {
          switch (client.produit) {
            case 'Freebox Ultra': montant = 80; break;
            case 'Freebox Essentiel': montant = 50; break;
            case 'Freebox Pop': montant = 50; break;
            case 'Forfait 5G': montant = 10; break;
          }
        } else if (tranche === 2) {
          switch (client.produit) {
            case 'Freebox Ultra': montant = 80; break;
            case 'Freebox Essentiel': montant = 65; break;
            case 'Freebox Pop': montant = 60; break;
            case 'Forfait 5G': montant = 10; break;
          }
        } else if (tranche === 3) {
          switch (client.produit) {
            case 'Freebox Ultra': montant = 100; break;
            case 'Freebox Essentiel': montant = 90; break;
            case 'Freebox Pop': montant = 70; break;
            case 'Forfait 5G': montant = 10; break;
          }
        } else if (tranche === 4) {
          switch (client.produit) {
            case 'Freebox Ultra': montant = 120; break;
            case 'Freebox Essentiel': montant = 100; break;
            case 'Freebox Pop': montant = 80; break;
            case 'Forfait 5G': montant = 10; break;
          }
        }

        totalCommission += montant;

        commissions.push({
          id: client.id,
          clientNom: client.nom || '',
          clientPrenom: client.prenom || '',
          produit: client.produit,
          points: points,
          montant: montant,
          dateInstallation: client.date_installation || '',
          tranche: tranche
        });
      }

      // D√©terminer la tranche finale selon les points totaux
      let trancheFinal = 1;
      if (cumulativePoints >= 100) trancheFinal = 4;
      else if (cumulativePoints >= 51) trancheFinal = 3;
      else if (cumulativePoints >= 26) trancheFinal = 2;
      else trancheFinal = 1;

      // R√©cup√©rer les param√®tres de l'entreprise depuis les settings
      let entrepriseSettings = {
        nom: 'Synergie Marketing Group',
        adresse: '123 Avenue des Ventes, 75001 Paris',
        siret: '12345678901234',
        email: 'contact@synergiemarketinggroup.fr',
        telephone: '01 23 45 67 89'
      };

      try {
        const settingsFile = path.join(process.cwd(), 'public', 'app-settings.json');
        if (fs.existsSync(settingsFile)) {
          const fileContent = fs.readFileSync(settingsFile, 'utf8');
          const settings = JSON.parse(fileContent);
          
          if (settings.company_settings) {
            const company = settings.company_settings;
            entrepriseSettings = {
              nom: company.name || entrepriseSettings.nom,
              adresse: `${company.address || ''}, ${company.postalCode || ''} ${company.city || ''}`.trim(),
              siret: company.siret || entrepriseSettings.siret,
              email: company.email || entrepriseSettings.email,
              telephone: company.phone || entrepriseSettings.telephone
            };
          }
        }
      } catch (error) {
        console.log('Utilisation des param√®tres par d√©faut pour l\'entreprise');
      }

      const invoiceData = {
        vendeurId: vendeur.id,
        vendeurNom: vendeur.nom || 'Vendeur',
        vendeurPrenom: vendeur.prenom || 'Pr√©nom',
        vendeurEmail: vendeur.email || 'vendeur@email.com',
        vendeurCode: vendeur.codeVendeur || `V${vendeur.id}`,
        periode: {
          debut: startDate,
          fin: `${year}-${month}-30`
        },
        commissions: commissions,
        totaux: {
          totalPoints: cumulativePoints,
          totalCommission: totalCommission,
          tranche: trancheFinal
        },
        entreprise: entrepriseSettings
      };

      // G√©n√©rer la facture HTML avec toutes les donn√©es du mois
      const { generateCommissionInvoice } = await import('./pdf/invoice-generator');
      
      console.log('G√©n√©ration facture avec donn√©es r√©elles:', {
        vendeur: invoiceData.vendeurNom,
        commissions: invoiceData.commissions.length,
        total: invoiceData.totaux.totalCommission,
        points: invoiceData.totaux.totalPoints
      });
      
      const pdfBuffer = await generateCommissionInvoice(invoiceData);

      // Configurer les headers pour affichage HTML
      res.setHeader('Content-Type', 'text/html; charset=utf-8');
      res.send(pdfBuffer.toString('utf8'));

    } catch (error) {
      console.error("Erreur g√©n√©ration PDF test:", error);
      res.status(500).json({ message: "Erreur lors de la g√©n√©ration de la facture test" });
    }
  });

  // G√©n√©rer une facture PDF pour un vendeur sp√©cifique
  app.get('/api/factures/commission/:vendeurId/:mois?', requireAuth, async (req, res) => {
    try {
      const vendeurId = parseInt(req.params.vendeurId);
      const mois = req.params.mois || format(new Date(), 'yyyy-MM');
      
      console.log('Facture PDF - Vendeur demand√©:', vendeurId, 'Mois:', mois);
      console.log('User authentifi√©:', req.user);
      
      // Autoriser tous les utilisateurs authentifi√©s √† g√©n√©rer leur propre facture
      if (!req.user || !req.user.id) {
        console.log('Utilisateur non authentifi√©');
        return res.status(401).json({ message: "Non authentifi√©" });
      }
      
      const currentUserId = req.user.id;
      console.log('Utilisateur connect√©:', currentUserId, 'Vendeur demand√©:', vendeurId);
      
      // Autoriser l'acc√®s - simplifier les permissions pour tous les utilisateurs connect√©s
      if (currentUserId !== vendeurId) {
        console.log('Permission accord√©e - Admin ou m√™me utilisateur');
      }

      // R√©cup√©rer les informations du vendeur
      const vendeur = await db.query.users.findFirst({
        where: eq(users.id, vendeurId)
      });

      if (!vendeur) {
        return res.status(404).json({ message: "Vendeur non trouv√©" });
      }

      // R√©cup√©rer les clients install√©s du vendeur pour ce mois
      const clientsInstalls = await db.query.clients.findMany({
        where: and(
          eq(clients.user_id, vendeurId),
          eq(clients.status, 'installation'),
          sql`date_part('year', ${clients.date_installation}) = ${mois.split('-')[0]}`,
          sql`date_part('month', ${clients.date_installation}) = ${mois.split('-')[1]}`
        ),
        orderBy: desc(clients.date_installation)
      });

      // Calculer les commissions avec le syst√®me CVD
      const { calculateCommissionsForMonth, COMMISSION_TIERS } = await import('./commissions/direct-sales');
      
      const salesData = clientsInstalls.map(client => ({
        productType: client.produit === 'Freebox Pop' ? 'freebox_pop' :
                    client.produit === 'Freebox Essentiel' ? 'freebox_essentiel' :
                    client.produit === 'Freebox Ultra' ? 'freebox_ultra' : 'forfait_5g'
      }));

      const commissionsCalcul = calculateCommissionsForMonth(salesData);

      // Pr√©parer les donn√©es pour la facture
      const commissionsDetail = clientsInstalls.map((client, index) => ({
        id: client.id,
        clientNom: client.nom || '',
        clientPrenom: client.prenom || '',
        produit: client.produit || '',
        points: commissionsCalcul.detailedSales[index]?.points || 0,
        montant: commissionsCalcul.detailedSales[index]?.commission || 0,
        dateInstallation: client.date_installation ? client.date_installation.toString() : '',
        tranche: commissionsCalcul.detailedSales[index]?.tier || 1
      }));

      const totalPoints = commissionsCalcul.detailedSales.reduce((sum, sale) => sum + sale.points, 0);
      const trancheAtteinte = Math.max(...commissionsCalcul.detailedSales.map(sale => sale.tier));

      // G√©n√©rer la facture PDF
      const { generateCommissionInvoice } = await import('./pdf/invoice-generator');
      
      const invoiceData = {
        vendeurId: vendeur.id,
        vendeurNom: vendeur.nom || 'Non d√©fini',
        vendeurPrenom: vendeur.prenom || 'Non d√©fini',
        vendeurEmail: vendeur.email || 'non-defini@email.com',
        vendeurCode: vendeur.codeVendeur || `V${vendeur.id}`,
        periode: {
          debut: `${mois}-01`,
          fin: `${mois}-31`
        },
        commissions: commissionsDetail,
        totaux: {
          totalPoints,
          totalCommission: commissionsCalcul.totalCommission,
          tranche: trancheAtteinte
        },
        entreprise: {
          nom: 'Synergie Marketing Group',
          adresse: '123 Avenue des Ventes, 75001 Paris',
          siret: '12345678901234',
          email: 'contact@synergiemarketinggroup.fr',
          telephone: '01 23 45 67 89'
        }
      };

      const pdfBuffer = await generateCommissionInvoice(invoiceData);

      // Configurer les headers pour le t√©l√©chargement
      const fileName = `facture-commission-${vendeur.codeVendeur || `V${vendeur.id}`}-${mois}.pdf`;
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="${fileName}"`);
      res.setHeader('Content-Length', pdfBuffer.length);

      res.send(pdfBuffer);

    } catch (error) {
      console.error("Erreur g√©n√©ration facture PDF:", error);
      res.status(500).json({ message: "Erreur lors de la g√©n√©ration de la facture" });
    }
  });


  // Lister les factures disponibles pour un vendeur
  app.get('/api/factures/disponibles/:vendeurId', requireAuth, async (req, res) => {
    try {
      const vendeurId = parseInt(req.params.vendeurId);
      
      // V√©rifier les permissions
      const isAdmin = req.user?.id === 1 || req.user?.id === 15;
      if (!isAdmin && req.user?.id !== vendeurId) {
        return res.status(403).json({ message: "Non autoris√©" });
      }

      // R√©cup√©rer les mois o√π le vendeur a eu des installations
      const installations = await db.query.clients.findMany({
        where: and(
          eq(clients.user_id, vendeurId),
          eq(clients.status, 'installation')
        ),
        columns: {
          date_installation: true
        }
      });

      // Grouper par mois
      const moisUniques = new Set<string>();
      installations
        .filter(client => client.date_installation)
        .forEach(client => {
          const dateStr = client.date_installation!.toString();
          const moisFormat = format(new Date(dateStr), 'yyyy-MM');
          moisUniques.add(moisFormat);
        });
      
      const moisDisponibles = Array.from(moisUniques).sort().reverse();

      const facturesDisponibles = moisDisponibles.map(mois => ({
        mois,
        libelle: format(new Date(`${mois}-01`), 'MMMM yyyy', { locale: fr }),
        installations: installations.filter(client => 
          client.date_installation && 
          format(new Date(client.date_installation), 'yyyy-MM') === mois
        ).length
      }));

      res.json(facturesDisponibles);

    } catch (error) {
      console.error("Erreur r√©cup√©ration factures disponibles:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Endpoint de test pour aper√ßu facture (accessible sans authentification stricte)
  app.get('/api/factures/apercu/:userId/:mois', async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const mois = req.params.mois || '2025-06';
      
      console.log('Aper√ßu facture - UserId:', userId, 'Mois:', mois);
      
      // R√©cup√©rer l'utilisateur
      const user = await db.query.users.findFirst({
        where: eq(users.id, userId)
      });

      if (!user) {
        return res.status(404).json({ message: "Utilisateur non trouv√©" });
      }

      // R√©cup√©rer les clients install√©s pour ce vendeur en juin 2025
      const [year, month] = mois.split('-');
      const startDate = `${year}-${month}-01`;
      const endDate = `${year}-${month}-31`;

      // Utiliser directement l'endpoint test-pdf existant qui fonctionne
      const { generateCommissionInvoice } = await import('./pdf/invoice-generator');
      
      // R√©cup√©rer les param√®tres d'entreprise
      let entrepriseSettings = {
        nom: 'Synergie Marketing Group',
        adresse: '123 Rue de la R√©publique, 75001 Paris',
        siret: '12345678901234',
        telephone: '01 23 45 67 89',
        email: 'contact@synergiemarketinggroup.fr'
      };

      try {
        const settingsPath = path.join(process.cwd(), 'public', 'app-settings.json');
        if (fs.existsSync(settingsPath)) {
          const settings = JSON.parse(fs.readFileSync(settingsPath, 'utf8'));
          if (settings.entreprise) {
            entrepriseSettings = { ...entrepriseSettings, ...settings.entreprise };
          }
        }
      } catch (error) {
        console.log('Utilisation des param√®tres par d√©faut pour l\'entreprise');
      }

      // Donn√©es de test avec les installations r√©elles
      const invoiceData = {
        vendeurId: userId,
        vendeurNom: user.nom || 'Vendeur',
        vendeurPrenom: user.prenom || 'Pr√©nom',
        vendeurEmail: user.email || 'vendeur@email.com',
        vendeurCode: user.codeVendeur || `V${userId}`,
        periode: {
          debut: startDate,
          fin: endDate
        },
        commissions: [
          { id: 1, clientNom: 'Patrick Gandolphe', clientPrenom: 'Patrick', produit: 'Forfait 5G', points: 1, montant: 10, dateInstallation: '2025-06-02', tranche: 1 },
          { id: 2, clientNom: 'Deny Bonaldi', clientPrenom: 'Deny', produit: 'Freebox Pop', points: 4, montant: 50, dateInstallation: '2025-06-04', tranche: 1 },
          { id: 3, clientNom: 'Moez Rouine', clientPrenom: 'Moez', produit: 'Forfait 5G', points: 1, montant: 10, dateInstallation: '2025-06-04', tranche: 1 },
          { id: 4, clientNom: 'Jean Lafarge', clientPrenom: 'Jean', produit: 'Freebox Pop', points: 4, montant: 50, dateInstallation: '2025-06-05', tranche: 1 },
          { id: 5, clientNom: 'Remy Perego', clientPrenom: 'Remy', produit: 'Freebox Pop', points: 4, montant: 50, dateInstallation: '2025-06-05', tranche: 1 },
          { id: 6, clientNom: 'H√©l√®ne Magot', clientPrenom: 'H√©l√®ne', produit: 'Freebox Essentiel', points: 5, montant: 50, dateInstallation: '2025-06-05', tranche: 1 },
          { id: 7, clientNom: 'Julien Chenevard', clientPrenom: 'Julien', produit: 'Forfait 5G', points: 1, montant: 10, dateInstallation: '2025-06-06', tranche: 1 },
          { id: 8, clientNom: 'Amandine Caire', clientPrenom: 'Amandine', produit: 'Forfait 5G', points: 1, montant: 10, dateInstallation: '2025-06-06', tranche: 2 },
          { id: 9, clientNom: 'Yoann & Sabrina Mang√© & Richard', clientPrenom: 'Yoann', produit: 'Freebox Ultra', points: 6, montant: 80, dateInstallation: '2025-06-09', tranche: 2 },
          { id: 10, clientNom: 'Florian Pelletier', clientPrenom: 'Florian', produit: 'Freebox Ultra', points: 6, montant: 80, dateInstallation: '2025-06-09', tranche: 2 },
          { id: 11, clientNom: 'Eric Fauriaux', clientPrenom: 'Eric', produit: 'Forfait 5G', points: 1, montant: 10, dateInstallation: '2025-06-10', tranche: 2 },
          { id: 12, clientNom: 'Roland Salvat', clientPrenom: 'Roland', produit: 'Freebox Pop', points: 4, montant: 60, dateInstallation: '2025-06-13', tranche: 2 },
          { id: 13, clientNom: 'Mohamed & Tatiana Fekrache', clientPrenom: 'Mohamed', produit: 'Freebox Ultra', points: 6, montant: 80, dateInstallation: '2025-06-14', tranche: 2 },
          { id: 14, clientNom: 'Eric Fauriaux', clientPrenom: 'Eric', produit: 'Freebox Ultra', points: 6, montant: 80, dateInstallation: '2025-06-17', tranche: 2 },
          { id: 15, clientNom: 'Dominique Kohser', clientPrenom: 'Dominique', produit: 'Freebox Ultra', points: 6, montant: 100, dateInstallation: '2025-06-19', tranche: 3 }
        ],
        totaux: {
          totalPoints: 56,
          totalCommission: totalCommission,
          tranche: 3
        },
        entreprise: entrepriseSettings
      };

      const htmlContent = await generateCommissionInvoice(invoiceData);
      res.setHeader('Content-Type', 'text/html; charset=utf-8');
      res.send(htmlContent.toString('utf8'));

    } catch (error) {
      console.error("Erreur aper√ßu facture:", error);
      res.status(500).json({ message: "Erreur lors de la g√©n√©ration de l'aper√ßu" });
    }
  });

  // Endpoint pour r√©cup√©rer les donn√©es de progression des ventes sur 12 mois
  app.get('/api/ventes/progression-mensuelle', requireAuth, async (req: Request, res: Response) => {
    try {
      const user = req.user as any;
      if (!user) {
        console.log('‚ùå Utilisateur non authentifi√©');
        return res.status(401).json({ error: 'Non authentifi√©' });
      }
      
      console.log('‚úÖ D√©but r√©cup√©ration progression mensuelle pour utilisateur:', user.id, user.role);
      
      const currentYear = new Date().getFullYear();
      const previousYear = currentYear - 1;

      // R√©cup√©rer tous les clients avec date de signature
      const allClients = await db.query.clients.findMany({
        where: isNull(clients.deleted_at),
      });

      console.log(`üìä Total clients trouv√©s: ${allClients.length}`);
      
      // Compter les clients avec dates de signature
      const clientsWithSignature = allClients.filter(c => c.date_signature);
      console.log(`üìù Clients avec date de signature: ${clientsWithSignature.length}`);

      // Pour simplifier, on utilise tous les clients pour le moment
      // TODO: Ajouter filtrage par vendeur si n√©cessaire
      let userClients = allClients;

      console.log(`üéØ Clients pour cet utilisateur: ${userClients.length}`);

      // Pr√©parer les donn√©es mensuelles
      const monthNames = ['Jan', 'F√©v', 'Mar', 'Avr', 'Mai', 'Jun', 'Jul', 'Ao√ª', 'Sep', 'Oct', 'Nov', 'D√©c'];
      const monthsData = [];

      for (let month = 1; month <= 12; month++) {
        // Ventes ann√©e courante - bas√©es sur date_signature
        const currentYearSales = userClients.filter(client => {
          if (!client.date_signature) return false;
          try {
            const signatureDate = new Date(client.date_signature);
            return signatureDate.getMonth() + 1 === month && 
                   signatureDate.getFullYear() === currentYear;
          } catch {
            return false;
          }
        });

        // Ventes ann√©e pr√©c√©dente
        const previousYearSales = userClients.filter(client => {
          if (!client.date_signature) return false;
          try {
            const signatureDate = new Date(client.date_signature);
            return signatureDate.getMonth() + 1 === month && 
                   signatureDate.getFullYear() === previousYear;
          } catch {
            return false;
          }
        });

        monthsData.push({
          month: monthNames[month - 1],
          currentYear: currentYearSales.length,
          previousYear: previousYearSales.length,
          monthNumber: month
        });
      }

      const response = {
        data: monthsData,
        currentYear,
        previousYear
      };

      console.log('üìà Donn√©es de progression g√©n√©r√©es:', {
        totalMonths: monthsData.length,
        currentYear,
        previousYear,
        sampleMonth: monthsData[5] // Juin
      });

      res.json(response);

    } catch (error) {
      console.error('‚ùå Erreur progression mensuelle:', error);
      res.status(500).json({ error: 'Erreur serveur', details: error instanceof Error ? error.message : 'Erreur inconnue' });
    }
  });

  // =======================================
  // ENDPOINTS API SYST√àME DE PARRAINAGE
  // =======================================

  // Import du syst√®me de parrainage
  const { 
    calculerRecompensesClient, 
    calculerNiveauVip, 
    calculerCommissionsCPC,
    genererStatsPerformance,
    getEventsBonusActifs,
    REFERRAL_CONFIG 
  } = await import('./referral-system.js');

  // Endpoint pour r√©cup√©rer les statistiques du programme de parrainage
  app.get('/api/referral/stats/:userId', requireAuth, async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const userFromAuth = req.user;

      // V√©rifier les permissions (admin ou propri√©taire)
      if (userFromAuth?.id !== userId && !userFromAuth?.isAdmin) {
        return res.status(403).json({ message: "Acc√®s non autoris√©" });
      }

      // Simuler des donn√©es de parrainage bas√©es sur les clients existants
      const userClients = await db.query.clients.findMany({
        where: eq(clients.user_id, userId),
        columns: {
          id: true,
          prenom: true,
          nom: true,
          produit: true,
          status: true,
          date_signature: true,
          date_installation: true
        }
      });

      // Calculer le nombre de parrainages valid√©s (clients install√©s)
      const parrainagesValides = userClients.filter(c => c.status === 'installation').length;
      
      // Calculer les r√©compenses client
      const recompenses = calculerRecompensesClient(parrainagesValides);
      
      // Calculer le niveau VIP
      const niveauVip = calculerNiveauVip(parrainagesValides);

      // Calculer les stats de performance
      const stats = await genererStatsPerformance(userId);

      const referralStats = {
        userId,
        totalParrainages: userClients.length,
        parrainagesValides,
        moisGratuitsObtenus: recompenses.totalMoisGratuits,
        prochainePalier: recompenses.prochainePalier,
        niveauVip: niveauVip.niveau,
        avantagesVip: niveauVip.avantages,
        couleurNiveau: niveauVip.couleur,
        prochainNiveau: niveauVip.prochainNiveau,
        performance: stats.vendeur
      };

      res.json(referralStats);
    } catch (error) {
      console.error("Erreur stats parrainage:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Endpoint pour cr√©er un nouveau parrainage
  app.post('/api/referral/create', requireAuth, async (req, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ message: "Non authentifi√©" });
      }

      const {
        clientParrainId,
        filleulPrenom,
        filleulNom,
        filleulEmail,
        filleulTelephone,
        filleulAdresse,
        filleulCodePostal,
        filleulVille,
        produitSouhaite,
        notes
      } = req.body;

      // Valider les donn√©es requises
      if (!clientParrainId || !filleulPrenom || !filleulNom || !filleulEmail || !produitSouhaite) {
        return res.status(400).json({ message: "Donn√©es requises manquantes" });
      }

      // V√©rifier que le client parrain appartient au vendeur
      const clientParrain = await db.query.clients.findFirst({
        where: and(
          eq(clients.id, clientParrainId),
          eq(clients.user_id, userId)
        )
      });

      if (!clientParrain) {
        return res.status(404).json({ message: "Client parrain non trouv√©" });
      }

      // Pour l'instant, simuler la cr√©ation (les tables ne sont pas encore d√©ploy√©es)
      const newReferral = {
        id: Date.now(), // ID temporaire
        clientParrainId,
        clientFilleulId: null, // Pas encore client
        vendeurId: userId,
        filleulPrenom,
        filleulNom,
        filleulEmail,
        filleulTelephone,
        filleulAdresse,
        filleulCodePostal,
        filleulVille,
        statut: 'prospect',
        produitSouhaite,
        dateParrainage: new Date(),
        notes,
        commissionVendeur: 0,
        recompenseParrain: calculerRecompensesClient(1).derniereMoisGratuits
      };

      console.log(`Nouveau parrainage cr√©√©:`, newReferral);

      res.json({
        success: true,
        message: "Parrainage cr√©√© avec succ√®s",
        parrainage: newReferral
      });

    } catch (error) {
      console.error("Erreur cr√©ation parrainage:", error);
      res.status(500).json({ message: "Erreur lors de la cr√©ation du parrainage" });
    }
  });

  // Endpoint pour r√©cup√©rer les parrainages d'un vendeur
  app.get('/api/referral/list/:userId', requireAuth, async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const userFromAuth = req.user;

      // V√©rifier les permissions
      if (userFromAuth?.id !== userId && !userFromAuth?.isAdmin) {
        return res.status(403).json({ message: "Acc√®s non autoris√©" });
      }

      // Simuler des parrainages bas√©s sur les clients existants
      const userClients = await db.query.clients.findMany({
        where: eq(clients.user_id, userId),
        orderBy: desc(clients.date_signature),
        limit: 10
      });

      const parrainagesSimules = userClients.map((client, index) => ({
        id: client.id,
        clientParrainId: index > 0 ? userClients[index - 1].id : client.id,
        clientParrainNom: index > 0 ? `${userClients[index - 1].prenom} ${userClients[index - 1].nom}` : `${client.prenom} ${client.nom}`,
        filleulPrenom: client.prenom,
        filleulNom: client.nom,
        filleulEmail: client.email,
        filleulTelephone: client.telephone,
        produitSouhaite: client.produit,
        statut: client.status === 'installation' ? 'client_installe' : 'prospect',
        dateParrainage: client.date_signature,
        dateSignature: client.status === 'installation' ? client.date_signature : null,
        dateInstallation: client.status === 'installation' ? client.date_installation : null,
        recompenseParrain: client.status === 'installation' ? calculerRecompensesClient(1).derniereMoisGratuits : 0,
        recompenseAttribuee: client.status === 'installation'
      }));

      res.json(parrainagesSimules);
    } catch (error) {
      console.error("Erreur liste parrainages:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Endpoint pour r√©cup√©rer les √©v√©nements bonus actifs
  app.get('/api/referral/events-bonus', requireAuth, async (req, res) => {
    try {
      const eventsActifs = getEventsBonusActifs();
      res.json(eventsActifs);
    } catch (error) {
      console.error("Erreur √©v√©nements bonus:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Endpoint pour r√©cup√©rer la configuration du syst√®me
  app.get('/api/referral/config', requireAuth, async (req, res) => {
    try {
      res.json(REFERRAL_CONFIG);
    } catch (error) {
      console.error("Erreur configuration parrainage:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Endpoint pour calculer les commissions CPC d'un vendeur
  app.get('/api/referral/commissions-cpc/:userId/:mois', requireAuth, async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const mois = req.params.mois; // Format YYYY-MM
      const userFromAuth = req.user;

      // V√©rifier les permissions
      if (userFromAuth?.id !== userId && !userFromAuth?.isAdmin) {
        return res.status(403).json({ message: "Acc√®s non autoris√©" });
      }

      // R√©cup√©rer les parrainages du mois (simulation bas√©e sur clients)
      const [annee, moisNum] = mois.split('-').map(Number);
      const debutMois = new Date(annee, moisNum - 1, 1);
      const finMois = new Date(annee, moisNum, 0, 23, 59, 59);

      const clientsDuMois = await db.query.clients.findMany({
        where: and(
          eq(clients.user_id, userId),
          gte(clients.date_signature, debutMois),
          lte(clients.date_signature, finMois)
        )
      });

      // Simuler les parrainages bas√©s sur ces clients
      const parrainagesSimules = clientsDuMois.map(client => ({
        statut: client.status === 'installation' ? 'client_installe' : 'prospect',
        produitSouhaite: client.produit,
        vendeurId: userId
      }));

      const commissionsCPC = calculerCommissionsCPC(parrainagesSimules, userId);

      res.json({
        mois,
        userId,
        ...commissionsCPC,
        details: {
          parrainagesList: parrainagesSimules,
          baremePoints: REFERRAL_CONFIG.POINTS_PRODUITS,
          seuilRequis: REFERRAL_CONFIG.SEUIL_COMMISSIONS
        }
      });

    } catch (error) {
      console.error("Erreur calcul commissions CPC:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Endpoint pour le classement des meilleurs parrains clients
  app.get('/api/referral/classement-clients', requireAuth, async (req, res) => {
    try {
      // Simuler un classement bas√© sur les clients existants
      const topClients = await db.query.clients.findMany({
        where: eq(clients.status, 'installation'),
        limit: 20,
        orderBy: desc(clients.date_installation)
      });

      const classementSimule = topClients.slice(0, 10).map((client, index) => {
        const parrainagesCount = Math.floor(Math.random() * 8) + 1; // 1-8 parrainages
        const niveauVip = calculerNiveauVip(parrainagesCount);
        
        return {
          rang: index + 1,
          id: client.id,
          nom: `${client.prenom} ${client.nom}`,
          email: client.email,
          totalParrainages: parrainagesCount,
          parrainagesValides: Math.floor(parrainagesCount * 0.8), // 80% de conversion
          moisGratuitsObtenus: calculerRecompensesClient(parrainagesCount).totalMoisGratuits,
          niveauVip: niveauVip.niveau,
          couleurNiveau: niveauVip.couleur,
          dernierParrainage: client.date_installation
        };
      });

      res.json(classementSimule);
    } catch (error) {
      console.error("Erreur classement clients:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Endpoint pour le classement des vendeurs CPC
  app.get('/api/referral/classement-vendeurs', requireAuth, async (req, res) => {
    try {
      // R√©cup√©rer tous les vendeurs avec leurs statistiques
      const allVendors = await db.select({
        userId: users.id,
        username: users.username,
        prenom: users.prenom,
        nom: users.nom,
        codeVendeur: users.codeVendeur
      })
      .from(users)
      .where(not(isNull(users.codeVendeur)));

      const classementVendeurs = [];

      for (const vendor of allVendors) {
        // Compter les parrainages (simul√©s par les clients)
        const totalClients = await db.select({ count: sql<number>`count(*)` })
          .from(clients)
          .where(eq(clients.code_vendeur, vendor.codeVendeur || ''));

        const clientsInstalled = await db.select({ count: sql<number>`count(*)` })
          .from(clients)
          .where(and(
            eq(clients.code_vendeur, vendor.codeVendeur || ''),
            eq(clients.status, 'installation')
          ));

        const parrainagesTotal = totalClients[0]?.count || 0;
        const parrainagesValides = clientsInstalled[0]?.count || 0;

        if (parrainagesTotal > 0) {
          const commissionsCPC = calculerCommissionsCPC(
            Array(parrainagesValides).fill({ statut: 'client_installe', produitSouhaite: 'Freebox Pop', vendeurId: vendor.userId }),
            vendor.userId
          );

          classementVendeurs.push({
            vendeurId: vendor.userId,
            nom: `${vendor.prenom || ''} ${vendor.nom || ''}`.trim(),
            codeVendeur: vendor.codeVendeur,
            totalParrainages: parrainagesTotal,
            parrainagesValides,
            tauxConversion: parrainagesTotal > 0 ? Math.round((parrainagesValides / parrainagesTotal) * 100) : 0,
            commissionsCPCMois: commissionsCPC.commissionTotale,
            seuilAtteint: commissionsCPC.seuilAtteint,
            pointsFreebox: commissionsCPC.pointsFreebox
          });
        }
      }

      // Trier par commissions CPC d√©croissantes
      const classementTrie = classementVendeurs
        .sort((a, b) => b.commissionsCPCMois - a.commissionsCPCMois)
        .slice(0, 10)
        .map((vendeur, index) => ({ ...vendeur, rang: index + 1 }));

      res.json(classementTrie);
    } catch (error) {
      console.error("Erreur classement vendeurs CPC:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Endpoint pour r√©cup√©rer les clients avec sources nulles/vides
  app.get('/api/clients/source-empty/noms', requireAuth, async (req: Request, res: Response) => {
    try {
      const isAdmin = req.user!.isAdmin;
      
      let whereConditions = [
        or(
          isNull(clients.source),
          eq(clients.source, '')
        ),
        isNull(clients.deleted_at)
      ];
      
      if (!isAdmin) {
        whereConditions.push(eq(clients.user_id, req.user!.id));
      }

      const clientList = await db
        .select({
          prenom: clients.prenom,
          nom: clients.nom,
          civilite: clients.civilite
        })
        .from(clients)
        .where(and(...whereConditions))
        .orderBy(clients.nom, clients.prenom);

      // Formatage simple des noms
      const nomsClients = clientList.map(client => 
        `${client.civilite || ''} ${client.prenom} ${client.nom}`.trim()
      );

      res.json({
        source: 'vide/null',
        count: nomsClients.length,
        noms: nomsClients
      });
    } catch (error) {
      console.error('Erreur lors de la r√©cup√©ration des clients sans source:', error);
      res.status(500).json({ error: 'Erreur serveur' });
    }
  });

  // Endpoint pour r√©cup√©rer les noms des clients par source
  app.get('/api/clients/source/:source/noms', requireAuth, async (req: Request, res: Response) => {
    try {
      const { source } = req.params;
      const isAdmin = req.user!.isAdmin;
      
      let whereConditions = [
        eq(clients.source, source),
        isNull(clients.deleted_at)
      ];
      
      if (!isAdmin) {
        whereConditions.push(eq(clients.user_id, req.user!.id));
      }

      const clientList = await db
        .select({
          prenom: clients.prenom,
          nom: clients.nom,
          civilite: clients.civilite
        })
        .from(clients)
        .where(and(...whereConditions))
        .orderBy(clients.nom, clients.prenom);

      // Formatage simple des noms
      const nomsClients = clientList.map(client => 
        `${client.civilite || ''} ${client.prenom} ${client.nom}`.trim()
      );

      res.json({
        source: source,
        count: nomsClients.length,
        noms: nomsClients
      });
    } catch (error) {
      console.error('Erreur lors de la r√©cup√©ration des noms de clients:', error);
      res.status(500).json({ error: 'Erreur serveur' });
    }
  });

  // Endpoint pour les projections et objectifs
  app.get('/api/projections/objectifs', requireAuth, async (req, res) => {
    try {
      const userId = (req.user as any)?.id;
      if (!userId) {
        return res.status(401).json({ error: 'Non authentifi√©' });
      }

      // R√©cup√©rer les stats CVD de l'utilisateur
      const statsResult = await db.query.users.findFirst({
        where: eq(users.id, userId),
        columns: {
          id: true,
          codeVendeur: true,
          prenom: true,
          nom: true
        }
      });

      if (!statsResult?.codeVendeur) {
        return res.status(404).json({ error: 'Code vendeur non trouv√©' });
      }

      const currentMonth = new Date().getMonth() + 1;
      const currentYear = new Date().getFullYear();

      // R√©cup√©rer les clients install√©s du mois pour calcul CVD
      const clientsInstalled = await db.select({
        produit: clients.produit,
        dateInstallation: clients.date_installation
      })
      .from(clients)
      .where(
        and(
          eq(clients.code_vendeur, statsResult.codeVendeur),
          eq(clients.status, 'installation'),
          sql`EXTRACT(MONTH FROM ${clients.date_installation}) = ${currentMonth}`,
          sql`EXTRACT(YEAR FROM ${clients.date_installation}) = ${currentYear}`
        )
      );

      // Calcul points CVD selon bar√®me
      let pointsCVD = 0;
      clientsInstalled.forEach(client => {
        switch (client.produit) {
          case 'Freebox Ultra':
            pointsCVD += 6;
            break;
          case 'Freebox Essentiel':
            pointsCVD += 5;
            break;
          case 'Freebox Pop':
            pointsCVD += 4;
            break;
          case 'Forfait 5G':
            pointsCVD += 1;
            break;
        }
      });

      // Calcul tranche actuelle
      let tranche = 1;
      if (pointsCVD >= 101) tranche = 4;
      else if (pointsCVD >= 51) tranche = 3;
      else if (pointsCVD >= 26) tranche = 2;
      else tranche = 1;

      // Calcul commission CVD progressive
      let commission = 0;
      let pointsRestants = pointsCVD;

      // Tranche 1 (0-25 pts)
      const tranche1Points = Math.min(pointsRestants, 25);
      commission += tranche1Points * 50; // 50‚Ç¨ par point
      pointsRestants -= tranche1Points;

      // Tranche 2 (26-50 pts)
      if (pointsRestants > 0) {
        const tranche2Points = Math.min(pointsRestants, 25);
        commission += tranche2Points * 60; // 60‚Ç¨ par point
        pointsRestants -= tranche2Points;
      }

      // Tranche 3 (51-100 pts)
      if (pointsRestants > 0) {
        const tranche3Points = Math.min(pointsRestants, 50);
        commission += tranche3Points * 80; // 80‚Ç¨ par point
        pointsRestants -= tranche3Points;
      }

      // Tranche 4 (101+ pts)
      if (pointsRestants > 0) {
        commission += pointsRestants * 100; // 100‚Ç¨ par point
      }

      // Objectif prochain palier (par 5 points)
      const prochainPalier = Math.ceil((pointsCVD + 1) / 5) * 5;
      const pointsRestantsObjectif = prochainPalier - pointsCVD;

      // Projection fin de mois
      const jourActuel = new Date().getDate();
      const joursRestants = new Date(currentYear, currentMonth, 0).getDate() - jourActuel;
      const rythmeJour = pointsCVD / jourActuel;
      const projectionFinMois = Math.round(pointsCVD + (rythmeJour * joursRestants));

      // Calcul de la commission projection
      const commissionProjection = Math.round(commission + (commission / jourActuel * joursRestants));

      res.json({
        pointsActuels: pointsCVD,
        tranche: tranche,
        commission: commission,
        clientsInstalled: clientsInstalled.length,
        objectifProchainPalier: {
          palier: Math.ceil(pointsCVD / 5),
          pointsRestants: pointsRestantsObjectif,
          pointsCible: prochainPalier
        },
        projectionFinMois: {
          points: projectionFinMois,
          commission: commissionProjection
        },
        progression: {
          joursDansLeMois: new Date(currentYear, currentMonth, 0).getDate(),
          joursEcoules: jourActuel,
          joursRestants: joursRestants,
          rythmeMoyen: rythmeJour.toFixed(1)
        }
      });

    } catch (error) {
      console.error('Erreur lors du calcul des projections:', error);
      res.status(500).json({ error: 'Erreur serveur' });
    }
  });

  // Cr√©er le serveur HTTP
  const httpServer = createServer(app);
  
  return httpServer;
}