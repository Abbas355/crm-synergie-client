import type { Express, Request, Response, NextFunction } from "express";
import { createServer, type Server } from "http";
import { setupAuth } from "./auth";
import { db } from "../db";
import { clients, contacts, campaigns, tasks, activities, simCards, recruiters, recruitmentProspects, recruitmentStages, recruitmentActivities, recruitmentNetworkStructure, recruitmentDocuments, DOCUMENT_TYPES, DocumentType, appSettings } from "@shared/schema";
import { eq, desc, and, or, like, count, isNull, isNotNull, asc, lt, lte, gt, gte, ne, sql, inArray, not } from "drizzle-orm";
import { getOrGenerateVendorCode } from "./utils/vendor-code";
import { Pool } from 'pg';
import multer from 'multer';
import path from 'path';
import crypto from 'crypto';
import fs from 'fs';

// Configuration de multer pour les uploads de fichiers
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    // Cr√©er le dossier s'il n'existe pas
    const uploadDir = path.join(__dirname, '../uploads');
    if (!fs.existsSync(uploadDir)) {
      fs.mkdirSync(uploadDir, { recursive: true });
    }
    console.log(`Upload directory: ${uploadDir}`);
    cb(null, uploadDir);
  },
  filename: function (req, file, cb) {
    // G√©n√©rer un nom de fichier unique
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    const filename = uniqueSuffix + path.extname(file.originalname);
    console.log(`Generated filename: ${filename} for original: ${file.originalname}`);
    cb(null, filename);
  }
});

// Configurer les limites et filtres pour Multer
const upload = multer({ 
  storage,
  limits: {
    fileSize: 5 * 1024 * 1024, // 5MB max
  },
  fileFilter: function(req, file, cb) {
    // Accepter uniquement les images 
    const allowedMimes = ['image/jpeg', 'image/png', 'image/gif', 'image/svg+xml'];
    if (allowedMimes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error(`Type de fichier non autoris√©. Autoris√©s: ${allowedMimes.join(', ')}`));
    }
  }
});

export async function registerRoutes(app: Express): Promise<Server> {
  // Setup authentication routes
  setupAuth(app);

  // API Routes pour le dashboard et les activit√©s r√©centes
  app.get("/api/dashboard/activities", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      console.log("R√©cup√©ration des activit√©s r√©centes avec optimisation...");
      
      // Utilisation de SQL brut pour optimiser la requ√™te avec jointures
      const results = await db.execute(sql`
        SELECT 
          a.id, 
          a.title, 
          a.type, 
          a.created_at as "createdAt",
          u.username,
          COALESCE(c.name, CONCAT(COALESCE(c.prenom, ''), ' ', COALESCE(c.nom, ''))) as "clientName",
          cam.name as "campaignName"
        FROM activities a
        LEFT JOIN users u ON a.user_id = u.id
        LEFT JOIN clients c ON a.client_id = c.id
        LEFT JOIN campaigns cam ON a.campaign_id = cam.id
        ORDER BY a.created_at DESC
        LIMIT 10
      `);
      
      // Convertir les r√©sultats bruts en format attendu
      const formattedActivities = (results as any).rows.map((activity: any) => ({
        id: activity.id,
        title: activity.title,
        type: activity.type,
        createdAt: new Date(activity.createdAt).toISOString(),
        user: activity.username || req.user.username,
        clientName: activity.clientName && activity.clientName.trim() !== ' ' ? activity.clientName.trim() : null,
        campaignName: activity.campaignName || null
      }));
      
      return res.json(formattedActivities);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des activit√©s r√©centes:", error);
      return res.status(500).json({ message: "Erreur serveur" });
    }
  });
  
  app.get("/api/dashboard/tasks", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      console.log("R√©cup√©ration des t√¢ches √† venir avec optimisation...");
      
      // D√©terminer si l'utilisateur est un administrateur
      const isAdmin = [1, 15].includes(req.user.id); // IDs des utilisateurs admin connus
      
      // Construire la requ√™te SQL en fonction du r√¥le
      let query;
      
      if (isAdmin) {
        // Les administrateurs voient toutes les t√¢ches administratives
        query = sql`
          SELECT 
            t.id, 
            t.title, 
            t.priority, 
            t.due_date as "dueDate",
            u.username,
            COALESCE(c.name, CONCAT(COALESCE(c.prenom, ''), ' ', COALESCE(c.nom, ''))) as "clientName"
          FROM tasks t
          LEFT JOIN users u ON t.user_id = u.id
          LEFT JOIN clients c ON t.client_id = c.id
          WHERE t.due_date >= NOW() AND t.task_type = 'admin'
          ORDER BY t.due_date ASC
          LIMIT 10
        `;
      } else {
        // Les vendeurs ne voient que leurs propres t√¢ches
        query = sql`
          SELECT 
            t.id, 
            t.title, 
            t.priority, 
            t.due_date as "dueDate",
            u.username,
            COALESCE(c.name, CONCAT(COALESCE(c.prenom, ''), ' ', COALESCE(c.nom, ''))) as "clientName"
          FROM tasks t
          LEFT JOIN users u ON t.user_id = u.id
          LEFT JOIN clients c ON t.client_id = c.id
          WHERE t.due_date >= NOW() 
            AND t.user_id = ${req.user.id}
            AND t.task_type = 'vendeur'
          ORDER BY t.due_date ASC
          LIMIT 10
        `;
      }
      
      const results = await db.execute(query);
      
      // Si la base de donn√©es ne contient pas de t√¢ches, utiliser des t√¢ches par d√©faut pour la d√©mo
      if ((results as any).rows.length === 0) {
        const defaultTasks = [
          {
            id: 1,
            title: "Appeler le client Soci√©t√© DEF pour suivi de proposition",
            priority: "urgent",
            dueDate: new Date().toISOString(),
            assignedTo: req.user.username,
            clientName: "Soci√©t√© DEF"
          },
          {
            id: 2,
            title: "Pr√©parer proposition commerciale pour Entreprise GHI",
            priority: "moyen",
            dueDate: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(), // demain
            assignedTo: req.user.username,
            clientName: "Entreprise GHI"
          },
          {
            id: 3,
            title: "Finaliser la campagne r√©seaux sociaux pour le produit X",
            priority: "faible",
            dueDate: new Date(Date.now() + 3 * 24 * 60 * 60 * 1000).toISOString(), // dans 3 jours
            assignedTo: req.user.username
          }
        ];
        return res.json(defaultTasks);
      }
      
      // Transformer les donn√©es pour correspondre au format attendu
      const formattedTasks = (results as any).rows.map((task: any) => ({
        id: task.id,
        title: task.title,
        priority: task.priority || "moyen",
        dueDate: new Date(task.dueDate).toISOString(),
        assignedTo: task.username || req.user.username,
        clientName: task.clientName && task.clientName.trim() !== ' ' ? task.clientName.trim() : null
      }));
      
      return res.json(formattedTasks);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des t√¢ches √† venir:", error);
      return res.status(500).json({ message: "Erreur serveur" });
    }
  });
  
  // Cr√©er une nouvelle activit√©
  app.post("/api/activities", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      const activityData = {
        ...req.body,
        userId: req.user.id,
        createdAt: new Date()
      };
      
      // Ins√©rer l'activit√© (sans validation de sch√©ma pour le moment)
      const [newActivity] = await db.insert(activities).values(activityData).returning();
      
      return res.status(201).json(newActivity);
    } catch (error) {
      console.error("Erreur lors de la cr√©ation d'une activit√©:", error);
      return res.status(500).json({ message: "Erreur serveur" });
    }
  });
  
  // Cr√©er une nouvelle t√¢che
  app.post("/api/tasks", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      // D√©terminer si l'utilisateur est un administrateur
      const isAdmin = [1, 15].includes(req.user.id); // IDs des utilisateurs admin connus
      
      // D√©terminer le type de t√¢che en fonction du r√¥le de l'utilisateur
      const taskType = isAdmin ? "admin" : "vendeur";
      
      // Ajouter le type de t√¢che aux donn√©es
      const taskData = {
        ...req.body,
        userId: req.user.id,
        createdAt: new Date(),
        taskType
      };
      
      // Ins√©rer la t√¢che
      const [newTask] = await db.insert(tasks).values(taskData).returning();
      
      // Cr√©er une activit√© pour la nouvelle t√¢che
      await db.insert(activities).values({
        title: `Nouvelle t√¢che cr√©√©e: ${newTask.title} (${taskType})`,
        type: "tache",
        userId: req.user.id,
        createdAt: new Date()
      });
      
      return res.status(201).json(newTask);
    } catch (error) {
      console.error("Erreur lors de la cr√©ation d'une t√¢che:", error);
      return res.status(500).json({ message: "Erreur serveur" });
    }
  });
  
  // API Routes for clients
  app.get("/api/clients", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      console.log("R√©cup√©ration des clients pour l'utilisateur:", req.user.id);
      
      const { search, code_vendeur } = req.query;
      let clientList;
      
      // D√©terminer si l'utilisateur est un administrateur (pour le filtrage)
      const isAdmin = [1, 15].includes(req.user.id); // IDs des utilisateurs admin connus
      
      // Construire la requ√™te de base en fonction du r√¥le
      let baseQuery = db.select().from(clients);
      
      // Les vendeurs ne peuvent voir que leurs propres clients
      if (!isAdmin) {
        // Chercher d'abord si l'utilisateur est un vendeur avec un code vendeur
        const recruiter = await db.query.recruiters.findFirst({
          where: eq(recruiters.userId, req.user.id)
        });
        
        // Si c'est un vendeur, filtrer par son code vendeur, sinon par userId
        if (recruiter && recruiter.codeVendeur) {
          baseQuery = baseQuery.where(eq(clients.codeVendeur, recruiter.codeVendeur));
        } else {
          baseQuery = baseQuery.where(eq(clients.userId, req.user.id));
        }
      }
      
      // Appliquer les filtres additionnels
      if (code_vendeur && typeof code_vendeur === 'string' && isAdmin) {
        // Seuls les admins peuvent filtrer par code vendeur explicitement
        console.log(`Filtrage par code vendeur: ${code_vendeur}`);
        clientList = await baseQuery
          .where(eq(clients.codeVendeur, code_vendeur))
          .orderBy((eb) => [
            desc(clients.dateSignature),
            desc(clients.createdAt)
          ]);
      } else if (search && typeof search === 'string') {
        // La recherche s'applique √† la requ√™te filtr√©e par r√¥le
        clientList = await baseQuery
          .where(
            or(
              like(clients.nom, `%${search}%`),
              like(clients.prenom, `%${search}%`),
              like(clients.email, `%${search}%`)
            )
          )
          .orderBy((eb) => [
            desc(clients.dateSignature),
            desc(clients.createdAt)
          ]);
      } else {
        // R√©cup√©rer les clients avec les filtres de base appliqu√©s
        clientList = await baseQuery
          .orderBy((eb) => [
            desc(clients.dateSignature),
            desc(clients.createdAt)
          ]);
      }
      
      console.log("Nombre de clients r√©cup√©r√©s:", clientList.length);
      
      res.json(clientList);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des clients:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  app.get("/api/clients/:id", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      const { id } = req.params;
      const { debug } = req.query;
      const clientId = parseInt(id);
      
      if (isNaN(clientId)) {
        return res.status(400).json({ message: "ID client invalide" });
      }
      
      // Debug log
      if (debug) {
        console.log(`Requ√™te de client ID ${clientId} re√ßue`);
      }
      
      const client = await db.query.clients.findFirst({
        where: eq(clients.id, clientId),
        with: {
          contacts: true
        }
      });
      
      if (!client) {
        return res.status(404).json({ message: "Client non trouv√©" });
      }
      
      // V√©rifier si l'utilisateur a le droit d'acc√©der √† ce client
      const isAdmin = [1, 15].includes(req.user.id); // IDs des utilisateurs admin connus
      
      if (!isAdmin) {
        // Si ce n'est pas un admin, v√©rifier si c'est son client
        const recruiter = await db.query.recruiters.findFirst({
          where: eq(recruiters.userId, req.user.id)
        });
        
        const hasAccess = 
          (client.userId === req.user.id) || // Le client appartient directement √† l'utilisateur
          (recruiter && recruiter.codeVendeur && client.codeVendeur === recruiter.codeVendeur); // Le client a le m√™me code vendeur
        
        if (!hasAccess) {
          return res.status(403).json({ message: "Vous n'avez pas acc√®s √† ce client" });
        }
      }
      
      // Get associated tasks
      // R√©cup√©rer les t√¢ches associ√©es au client sans restriction par utilisateur
      const clientTasks = await db.select().from(tasks)
        .where(eq(tasks.clientId, clientId))
        .orderBy(desc(tasks.createdAt));
      
      // Get activities
      // R√©cup√©rer les activit√©s associ√©es au client sans restriction par utilisateur
      const clientActivities = await db.select().from(activities)
        .where(eq(activities.clientId, clientId))
        .orderBy(desc(activities.createdAt));
        
      // Si le client a une carte SIM, r√©cup√©rer les d√©tails de cette carte
      let carteSIMDetails = null;
      if (client.carteSIM) {
        const carteSIMId = Number(client.carteSIM);
        if (!isNaN(carteSIMId)) {
          if (debug) {
            console.log(`R√©cup√©ration de la carte SIM ID ${carteSIMId} associ√©e au client ${clientId}`);
          }
          
          // R√©cup√©ration compl√®te de la carte SIM, sans filtrage sur l'utilisateur
          const carteDetails = await db
            .select({
              id: simCards.id,
              numero: simCards.numero,
              statut: simCards.statut,
              dateAttribution: simCards.dateAttribution,
              dateActivation: simCards.dateActivation
            })
            .from(simCards)
            .where(eq(simCards.id, carteSIMId))
            .limit(1)
            .then(rows => rows[0]);
          
          if (carteDetails) {
            carteSIMDetails = carteDetails;
            if (debug) {
              console.log(`Carte SIM trouv√©e:`, carteDetails);
            }
          } else if (debug) {
            console.log(`Aucune carte SIM trouv√©e avec l'ID ${carteSIMId}`);
            
            // Tentative de r√©cup√©ration sans condition d'utilisateur
            const carteDetailsSansUser = await db
              .select({
                id: simCards.id,
                numero: simCards.numero,
                statut: simCards.statut,
                dateAttribution: simCards.dateAttribution,
                dateActivation: simCards.dateActivation
              })
              .from(simCards)
              .where(eq(simCards.id, carteSIMId))
              .limit(1)
              .then(rows => rows[0]);
              
            if (carteDetailsSansUser) {
              console.log(`Carte SIM trouv√©e sans filtre utilisateur:`, carteDetailsSansUser);
              carteSIMDetails = carteDetailsSansUser;
            }
          }
        }
      }
      
      res.json({ 
        ...client,
        tasks: clientTasks,
        activities: clientActivities,
        carteSIMDetails
      });
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration du client:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  app.post("/api/clients", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      // Extraire tous les champs individuellement
      const { 
        nom, prenom, email, mobile, civilite, dateSignature,
        fixe, dateNaissance, adresse, codePostal, ville, produit,
        identifiantContrat, carteSIM, portabilite, numeroPorter, source,
        typeRecommandation, civiliteProspect, prenomProspect, nomProspect,
        mobileProspect, codePostalProspect, villeProspect, commentaire, status,
        type, userId, codeVendeur: manualCodeVendeur
      } = req.body;
      
      // Log pour d√©boguer en d√©veloppement et production
      console.log("üìÑ Cr√©ation client - Donn√©es re√ßues:", JSON.stringify(req.body, null, 2));
      
      // V√©rification plus intelligente du nom
      if (nom === undefined || nom === null || (typeof nom === 'string' && nom.trim() === '')) {
        console.log("‚ùå Validation nom √©chou√©e:", nom);
        return res.status(400).json({ message: "Le nom du client est requis" });
      }
      
      // S'assurer que le nom est une cha√Æne de caract√®res
      const nomFinal = String(nom).trim();
      if (nomFinal === '') {
        console.log("‚ùå Nom vide apr√®s conversion:", nom, "‚Üí", nomFinal);
        return res.status(400).json({ message: "Le nom du client est requis" });
      }
      
      // Traiter toutes les entr√©es de texte pour s'assurer qu'elles sont en format string
      const processStringField = (field: any): string | null => {
        if (field === undefined || field === null) return null;
        const trimmed = String(field).trim();
        return trimmed.length > 0 ? trimmed : null;
      };
      
      // R√©cup√©rer uniquement les cha√Ænes non vides
      const processedFields = {
        prenom: processStringField(prenom),
        email: processStringField(email),
        phone: processStringField(mobile),
        civilite: processStringField(civilite),
        fixe: processStringField(fixe),
        dateNaissance: processStringField(dateNaissance),
        adresse: processStringField(adresse),
        codePostal: processStringField(codePostal),
        ville: processStringField(ville),
        produit: processStringField(produit),
        identifiantContrat: processStringField(identifiantContrat),
        carteSIM: processStringField(carteSIM),
        portabilite: processStringField(portabilite),
        numeroPorter: processStringField(numeroPorter),
        source: processStringField(source),
        typeRecommandation: processStringField(typeRecommandation),
        civiliteProspect: processStringField(civiliteProspect),
        prenomProspect: processStringField(prenomProspect),
        nomProspect: processStringField(nomProspect),
        mobileProspect: processStringField(mobileProspect),
        codePostalProspect: processStringField(codePostalProspect),
        villeProspect: processStringField(villeProspect),
        commentaire: processStringField(commentaire),
        status: processStringField(status) || "enregistre",
        type: processStringField(type) || "client"
      };
      
      // G√©rer correctement la date de signature
      let parsedDateSignature: Date | null = null;
      if (dateSignature) {
        try {
          // Si c'est une cha√Æne ISO, la convertir en Date
          if (typeof dateSignature === 'string') {
            parsedDateSignature = new Date(dateSignature);
          } else if (dateSignature instanceof Date) {
            parsedDateSignature = dateSignature;
          } else if (typeof dateSignature === 'object' && dateSignature !== null) {
            // Si c'est un objet avec une structure de date comme {year, month, day}
            const dateObj: any = dateSignature;
            if (dateObj.year && dateObj.month) {
              parsedDateSignature = new Date(
                Number(dateObj.year), 
                Number(dateObj.month) - 1, 
                Number(dateObj.day || 1)
              );
            }
          }
          
          // V√©rifier si la date est valide
          if (parsedDateSignature && isNaN(parsedDateSignature.getTime())) {
            console.log("‚ö†Ô∏è Date de signature invalide:", dateSignature);
            parsedDateSignature = new Date(); // Utiliser une date par d√©faut
          }
        } catch (err) {
          console.log("‚ö†Ô∏è Erreur lors du parsing de la date de signature:", err);
          parsedDateSignature = new Date(); // Utiliser une date par d√©faut
        }
      } else {
        // Utiliser la date actuelle par d√©faut
        parsedDateSignature = new Date();
      }
      
      // Mettre √† jour le nom pour name
      const name = `${processedFields.prenom || ''} ${nomFinal}`.trim();
      
      // R√©cup√©rer ou g√©n√©rer le code vendeur pour l'utilisateur connect√©
      const codeVendeur = await getOrGenerateVendorCode(req.user.id);
      console.log(`Code vendeur utilis√© pour le client: ${codeVendeur}`);
      
      // Construction d'un objet d'insertion valide avec des valeurs nettoy√©es
      const insertData = {
        nom: nomFinal,
        name,
        userId: req.user.id,
        dateSignature: parsedDateSignature,
        codeVendeur, // Ajouter automatiquement le code vendeur
        ...processedFields
      };
      
      console.log("‚úÖ Donn√©es pr√©par√©es pour insertion:", insertData);
      
      try {
        // Ins√©rer directement avec les bons noms de colonnes
        const newClients = await db.insert(clients).values(insertData).returning();
        
        if (!newClients || newClients.length === 0) {
          throw new Error("√âchec de cr√©ation du client - aucun client retourn√©");
        }
        
        const newClient = newClients[0];
        console.log("‚úÖ Nouveau client cr√©√©:", newClient.id);
        
        // Si une carte SIM a √©t√© attribu√©e, mettre √† jour son statut √† "Activ√©"
        if (processedFields.carteSIM) {
          try {
            const carteSIMId = Number(processedFields.carteSIM);
            if (!isNaN(carteSIMId)) {
              await db.update(simCards)
                .set({ 
                  statut: "Activ√©", 
                  clientId: newClient.id,
                  dateAttribution: parsedDateSignature
                })
                .where(eq(simCards.id, carteSIMId));
              
              console.log(`‚úÖ Carte SIM ID ${carteSIMId} mise √† jour avec statut "Activ√©"`);
            }
          } catch (simError) {
            console.error("‚ùå Erreur lors de la mise √† jour de la carte SIM:", simError);
            // Ne pas faire √©chouer la cr√©ation du client si l'attribution de la carte SIM √©choue
          }
        }
        
        // Ajouter une activit√©
        try {
          const activityTitle = `Nouveau client ajout√© : ${processedFields.prenom || ""} ${nomFinal}`.trim();
          await db.insert(activities).values({
            title: activityTitle,
            type: "Client",
            userId: req.user.id,
            clientId: newClient.id
          });
          console.log("‚úÖ Activit√© cr√©√©e pour le nouveau client");
        } catch (activityError) {
          console.error("‚ùå Erreur lors de la cr√©ation de l'activit√©:", activityError);
          // Ne pas faire √©chouer la cr√©ation du client si la cr√©ation de l'activit√© √©choue
        }
        
        return res.status(201).json(newClient);
      } catch (dbError) {
        console.error("‚ùå Erreur d'insertion dans la base de donn√©es:", dbError);
        return res.status(500).json({ 
          message: "Erreur lors de l'enregistrement du client dans la base de donn√©es",
          details: dbError instanceof Error ? dbError.message : "Erreur inconnue"
        });
      }
    } catch (error) {
      console.error("‚ùå Erreur g√©n√©rale lors de la cr√©ation du client:", error);
      res.status(500).json({ 
        message: "Erreur serveur lors de la cr√©ation du client",
        details: error instanceof Error ? error.message : "Erreur inconnue" 
      });
    }
  });

  app.put("/api/clients/:id", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      const { id } = req.params;
      const clientId = parseInt(id);
      
      if (isNaN(clientId)) {
        return res.status(400).json({ message: "ID client invalide" });
      }
      
      // Extraire tous les champs individuellement
      const { 
        nom, prenom, email, mobile, civilite, dateSignature,
        fixe, dateNaissance, adresse, codePostal, ville, produit,
        identifiantContrat, carteSIM, portabilite, numeroPorter, source,
        typeRecommandation, civiliteProspect, prenomProspect, nomProspect,
        mobileProspect, codePostalProspect, villeProspect, commentaire, status,
        type
      } = req.body;
      
      // Log pour d√©boguer en d√©veloppement et production
      console.log("üìÑ Mise √† jour client - Donn√©es re√ßues:", JSON.stringify(req.body, null, 2));
      
      // V√©rification plus intelligente du nom
      if (nom === undefined || nom === null || (typeof nom === 'string' && nom.trim() === '')) {
        console.log("‚ùå Validation nom √©chou√©e lors de la mise √† jour:", nom);
        return res.status(400).json({ message: "Le nom du client est requis" });
      }
      
      // S'assurer que le nom est une cha√Æne de caract√®res
      const nomFinal = String(nom).trim();
      if (nomFinal === '') {
        console.log("‚ùå Nom vide apr√®s conversion (mise √† jour):", nom, "‚Üí", nomFinal);
        return res.status(400).json({ message: "Le nom du client est requis" });
      }
      
      // Traiter toutes les entr√©es de texte pour s'assurer qu'elles sont en format string
      const processStringField = (field: any): string | null => {
        if (field === undefined || field === null) return null;
        const trimmed = String(field).trim();
        return trimmed.length > 0 ? trimmed : null;
      };
      
      // R√©cup√©rer uniquement les cha√Ænes non vides
      const processedFields = {
        prenom: processStringField(prenom),
        email: processStringField(email),
        phone: processStringField(mobile),
        civilite: processStringField(civilite),
        fixe: processStringField(fixe),
        dateNaissance: processStringField(dateNaissance),
        adresse: processStringField(adresse),
        codePostal: processStringField(codePostal),
        ville: processStringField(ville),
        produit: processStringField(produit),
        identifiantContrat: processStringField(identifiantContrat),
        carteSIM: processStringField(carteSIM),
        portabilite: processStringField(portabilite),
        numeroPorter: processStringField(numeroPorter),
        source: processStringField(source),
        typeRecommandation: processStringField(typeRecommandation),
        civiliteProspect: processStringField(civiliteProspect),
        prenomProspect: processStringField(prenomProspect),
        nomProspect: processStringField(nomProspect),
        mobileProspect: processStringField(mobileProspect),
        codePostalProspect: processStringField(codePostalProspect),
        villeProspect: processStringField(villeProspect),
        commentaire: processStringField(commentaire),
        status: processStringField(status) || "enregistre",
        type: processStringField(type) || "client"
      };
      
      // G√©rer correctement la date de signature
      let parsedDateSignature: Date | null = null;
      if (dateSignature) {
        try {
          // Si c'est une cha√Æne ISO, la convertir en Date
          if (typeof dateSignature === 'string') {
            parsedDateSignature = new Date(dateSignature);
          } else if (dateSignature instanceof Date) {
            parsedDateSignature = dateSignature;
          } else if (typeof dateSignature === 'object' && dateSignature !== null) {
            // Si c'est un objet avec une structure de date comme {year, month, day}
            const dateObj: any = dateSignature;
            if (dateObj.year && dateObj.month) {
              parsedDateSignature = new Date(
                Number(dateObj.year), 
                Number(dateObj.month) - 1, 
                Number(dateObj.day || 1)
              );
            }
          }
          
          // V√©rifier si la date est valide
          if (parsedDateSignature && isNaN(parsedDateSignature.getTime())) {
            console.log("‚ö†Ô∏è Date de signature invalide (mise √† jour):", dateSignature);
            // Conserver la date existante si possible, sinon utiliser la date actuelle
            parsedDateSignature = null;
          }
        } catch (err) {
          console.log("‚ö†Ô∏è Erreur lors du parsing de la date de signature (mise √† jour):", err);
          parsedDateSignature = null;
        }
      }
      
      try {
        // V√©rifier que le client existe (sans restriction par utilisateur)
        const existingClient = await db.query.clients.findFirst({
          where: eq(clients.id, clientId)
        });
        
        if (!existingClient) {
          return res.status(404).json({ message: "Client non trouv√©" });
        }
        
        // Utiliser la date existante si la nouvelle n'est pas valide
        if (parsedDateSignature === null && existingClient.dateSignature) {
          parsedDateSignature = existingClient.dateSignature;
        } else if (parsedDateSignature === null) {
          parsedDateSignature = new Date(); // Fallback sur la date actuelle
        }
        
        // Mettre √† jour le nom pour name
        const name = `${processedFields.prenom || ''} ${nomFinal}`.trim();
        
        // R√©cup√©rer ou conserver le code vendeur
        let codeVendeur = existingClient.codeVendeur;
        
        // Si le client n'a pas de code vendeur, en attribuer un de l'utilisateur connect√©
        if (!codeVendeur) {
          codeVendeur = await getOrGenerateVendorCode(req.user.id);
          console.log(`Code vendeur attribu√© au client lors de la mise √† jour: ${codeVendeur}`);
        } else {
          console.log(`Code vendeur conserv√© pour le client: ${codeVendeur}`);
        }
        
        // Construction d'un objet d'insertion valide avec des valeurs nettoy√©es
        const updateData = {
          nom: nomFinal,
          name,
          dateSignature: parsedDateSignature,
          codeVendeur,
          ...processedFields
        };
        
        console.log("‚úÖ Donn√©es pr√©par√©es pour mise √† jour:", updateData);
        
        try {
          // Utiliser Drizzle ORM pour mettre √† jour le client
          const updatedClientResult = await db.update(clients)
            .set(updateData)
            .where(eq(clients.id, clientId))
            .returning();
          
          if (!updatedClientResult || updatedClientResult.length === 0) {
            throw new Error("√âchec de mise √† jour du client - aucun client retourn√©");
          }
          
          const updatedClient = updatedClientResult[0];
          console.log("‚úÖ Client mis √† jour:", updatedClient.id);
          
          // Si une carte SIM a √©t√© attribu√©e et qu'elle est diff√©rente de l'ancienne, mettre √† jour son statut
          if (processedFields.carteSIM && processedFields.carteSIM !== existingClient.carteSIM) {
            try {
              const carteSIMId = Number(processedFields.carteSIM);
              if (!isNaN(carteSIMId)) {
                // Mettre √† jour la nouvelle carte SIM
                await db.update(simCards)
                  .set({ 
                    statut: "Activ√©", 
                    clientId: clientId,
                    dateAttribution: parsedDateSignature 
                  })
                  .where(eq(simCards.id, carteSIMId));
                
                console.log(`‚úÖ Carte SIM ID ${carteSIMId} mise √† jour avec statut "Activ√©"`);
                
                // Si le client avait d√©j√† une carte SIM, remettre son statut √† "Disponible"
                if (existingClient.carteSIM) {
                  const ancienneCarteSIMId = Number(existingClient.carteSIM);
                  if (!isNaN(ancienneCarteSIMId)) {
                    await db.update(simCards)
                      .set({ statut: "Disponible", clientId: null })
                      .where(eq(simCards.id, ancienneCarteSIMId));
                    
                    console.log(`‚úÖ Ancienne carte SIM ID ${ancienneCarteSIMId} remise √† "Disponible"`);
                  }
                }
              }
            } catch (simError) {
              console.error("‚ùå Erreur lors de la mise √† jour de la carte SIM:", simError);
              // Ne pas faire √©chouer la mise √† jour du client si la mise √† jour de la carte SIM √©choue
            }
          }
          
          // Ajouter une activit√©
          try {
            const activityTitle = `Client mis √† jour : ${processedFields.prenom || ""} ${nomFinal}`.trim();
            await db.insert(activities).values({
              title: activityTitle,
              type: "Client",
              userId: req.user.id,
              clientId: clientId
            });
            console.log("‚úÖ Activit√© cr√©√©e pour la mise √† jour du client");
          } catch (activityError) {
            console.error("‚ùå Erreur lors de la cr√©ation de l'activit√©:", activityError);
            // Ne pas faire √©chouer la mise √† jour du client si la cr√©ation de l'activit√© √©choue
          }
          
          return res.json(updatedClient);
        } catch (dbError) {
          console.error("‚ùå Erreur d'insertion dans la base de donn√©es:", dbError);
          return res.status(500).json({ 
            message: "Erreur lors de la mise √† jour du client dans la base de donn√©es",
            details: dbError instanceof Error ? dbError.message : "Erreur inconnue"
          });
        }
      } catch (clientError) {
        console.error("‚ùå Erreur lors de la recherche du client:", clientError);
        return res.status(500).json({ 
          message: "Erreur lors de la recherche du client", 
          details: clientError instanceof Error ? clientError.message : "Erreur inconnue"
        });
      }
    } catch (error) {
      console.error("‚ùå Erreur g√©n√©rale lors de la mise √† jour du client:", error);
      res.status(500).json({ 
        message: "Erreur serveur lors de la mise √† jour du client",
        details: error instanceof Error ? error.message : "Erreur inconnue" 
      });
    }
  });

  app.delete("/api/clients/:id", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      const { id } = req.params;
      const clientId = parseInt(id);
      
      if (isNaN(clientId)) {
        return res.status(400).json({ message: "ID client invalide" });
      }
      
      // V√©rifier que le client existe (sans restriction par utilisateur)
      const existingClient = await db.query.clients.findFirst({
        where: eq(clients.id, clientId)
      });
      
      if (!existingClient) {
        return res.status(404).json({ message: "Client non trouv√©" });
      }
      
      try {
        // 1. Supprimer d'abord toutes les activit√©s li√©es au client
        console.log(`Suppression des activit√©s pour le client ${clientId}`);
        await db.delete(activities)
          .where(eq(activities.clientId, clientId));
        
        // 2. Supprimer les t√¢ches li√©es au client
        console.log(`Suppression des t√¢ches pour le client ${clientId}`);
        await db.delete(tasks)
          .where(eq(tasks.clientId, clientId));
          
        // 3. Si le client avait une carte SIM, la lib√©rer en remettant son statut √† "Disponible"
        if (existingClient.carteSIM) {
          const carteSIMId = Number(existingClient.carteSIM);
          if (!isNaN(carteSIMId)) {
            console.log(`Mise √† jour de la carte SIM ${carteSIMId} √† "disponible"`);
            await db.update(simCards)
              .set({ 
                statut: "disponible", 
                clientId: null,
                dateAttribution: null,
                dateActivation: null
              })
              .where(eq(simCards.id, carteSIMId));
          }
        }
        
        // 4. Supprimer le client lui-m√™me
        console.log(`Suppression du client ${clientId}`);
        await db.delete(clients)
          .where(eq(clients.id, clientId));
          
        // 5. Ajouter une activit√© pour la suppression, mais pas associ√©e au client supprim√©
        const activityTitle = `Client supprim√© : ${existingClient.prenom || ""} ${existingClient.nom || ""}`.trim();
        await db.insert(activities)
          .values({
            title: activityTitle,
            type: "Client",
            userId: req.user.id
          });
        
        res.status(204).send();
      } catch (deleteError) {
        console.error("Erreur d√©taill√©e lors de la suppression:", deleteError);
        res.status(500).json({ 
          message: "Erreur lors de la suppression", 
          details: deleteError.message || "Erreur inconnue"
        });
      }
    } catch (error) {
      console.error("Erreur lors de la suppression du client:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Dashboard data
  app.get("/api/dashboard", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      // Obtenir le nombre total de clients
      const totalClientsCount = await db.select({ count: count() })
        .from(clients)
        .where(eq(clients.userId, req.user.id));
      
      // Obtenir le nombre de clients en validation
      const validationClientsCount = await db.select({ count: count() })
        .from(clients)
        .where(and(
          eq(clients.userId, req.user.id),
          eq(clients.status, "valide")
        ));
      
      // Obtenir le nombre d'installations
      const installationClientsCount = await db.select({ count: count() })
        .from(clients)
        .where(and(
          eq(clients.userId, req.user.id),
          eq(clients.status, "installation")
        ));
      
      // Obtenir le nombre de clients Freebox
      const freeboxClientsCount = await db.select({ count: count() })
        .from(clients)
        .where(and(
          eq(clients.userId, req.user.id),
          eq(clients.type, "freebox")
        ));
      
      // Get recent activities
      const recentActivities = await db.select().from(activities)
        .where(eq(activities.userId, req.user.id))
        .orderBy(desc(activities.createdAt))
        .limit(5);
      
      // Get upcoming tasks
      const upcomingTasks = await db.select().from(tasks)
        .where(and(
          eq(tasks.userId, req.user.id),
          eq(tasks.status, "en_cours")
        ))
        .orderBy(desc(tasks.createdAt))
        .limit(5);
      
      const stats = {
        totalClients: totalClientsCount[0].count,
        validationClients: validationClientsCount[0].count,
        installationClients: installationClientsCount[0].count,
        freeboxClients: freeboxClientsCount[0].count
      };
      
      res.json({
        stats,
        recentActivities,
        upcomingTasks
      });
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des donn√©es du tableau de bord:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // API Routes pour les cartes SIM
  app.get("/api/sim-cards", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      const { statut, search } = req.query;
      const isClientCreation = req.query.clientCreation === 'true';
      
      // D√©terminer si l'utilisateur est un administrateur (m√™me logique que dans le reste de l'application)
      const isAdmin = [1, 15].includes(req.user.id); // IDs des utilisateurs admin connus
      
      // Permettre l'acc√®s aux vendeurs seulement pour la cr√©ation de client
      // Pour les autres cas, v√©rifier que l'utilisateur a les permissions administrateur
      if (!isClientCreation && !isAdmin) {
        return res.status(403).json({ message: "Acc√®s non autoris√© √† la gestion des cartes SIM" });
      }
      
      // Optimisation: filtrer directement dans la requ√™te SQL plut√¥t qu'en m√©moire
      let whereConditions = sql`1=1`; // Condition toujours vraie pour commencer
      
      // Filtrer par statut si fourni
      if (statut && typeof statut === 'string') {
        if (statut === 'disponible') {
          whereConditions = and(whereConditions, eq(simCards.statut, 'disponible'));
        } else if (statut === 'affecte' || statut === 'active') {
          // Le statut "active" est utilis√© dans l'interface pour afficher les cartes SIM actives/affect√©es
          whereConditions = and(whereConditions, or(
            eq(simCards.statut, 'affecte'),
            eq(simCards.statut, 'Activ√©')
          ));
        }
      }
      
      // Utilisons la m√©thode select pour √©viter les erreurs li√©es aux colonnes manquantes
      const query = db
        .select({
          id: simCards.id,
          codeVendeur: simCards.codeVendeur,
          numero: simCards.numero,
          statut: simCards.statut,
          clientId: simCards.clientId,
          dateAttribution: simCards.dateAttribution,
          dateActivation: simCards.dateActivation,
          note: simCards.note,
          userId: simCards.userId,
          createdAt: simCards.createdAt,
          client: {
            id: clients.id,
            civilite: clients.civilite,
            prenom: clients.prenom,
            nom: clients.nom
          }
        })
        .from(simCards)
        .leftJoin(clients, eq(simCards.clientId, clients.id))
        .where(whereConditions)
        .orderBy(desc(simCards.createdAt));

      let results = await query;
      
      // Recherche par num√©ro, code vendeur ou nom du client
      if (search && typeof search === 'string') {
        const searchLower = search.toLowerCase();
        const filteredResults = [];
        for (const card of results) {
          if (card.numero.toLowerCase().includes(searchLower) || 
              (card.codeVendeur && card.codeVendeur.toLowerCase().includes(searchLower)) ||
              (card.client && 
                ((card.client.prenom && card.client.prenom.toLowerCase().includes(searchLower)) ||
                (card.client.nom && card.client.nom.toLowerCase().includes(searchLower)))
              )) {
            filteredResults.push(card);
          }
        }
        results = filteredResults;
      }
      
      // Transformer les r√©sultats pour ajouter clientNom
      const processedResults = results.map(card => ({
        ...card,
        clientNom: card.client ? 
          `${card.client.prenom || ''} ${card.client.nom || ''}`.trim() : 
          undefined
      }));
      
      // Compter les statistiques
      const totalCount = await db.select({ count: count() }).from(simCards);
      
      const disponiblesCount = await db.select({ count: count() }).from(simCards)
        .where(eq(simCards.statut, 'disponible'));
      
      const affecteesCount = await db.select({ count: count() }).from(simCards)
        .where(or(
          eq(simCards.statut, 'affecte'),
          eq(simCards.statut, 'Activ√©')
        ));
      
      const stats = {
        total: totalCount[0].count,
        disponibles: disponiblesCount[0].count,
        affectees: affecteesCount[0].count
      };
      
      console.log("Nombre de cartes SIM r√©cup√©r√©es:", processedResults.length);
      
      res.json({
        simCards: processedResults,
        stats
      });
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des cartes SIM:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  app.get("/api/sim-cards/:id", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      const { id } = req.params;
      const { debug } = req.query;
      const simCardId = parseInt(id);
      
      if (isNaN(simCardId)) {
        return res.status(400).json({ message: "ID de carte SIM invalide" });
      }
      
      // Debug log
      if (debug) {
        console.log(`Requ√™te de carte SIM ID ${simCardId} re√ßue`);
      }
      
      // Utiliser select au lieu de query.findFirst pour √©viter les erreurs avec civilite
      const simCard = await db
        .select({
          id: simCards.id,
          codeVendeur: simCards.codeVendeur,
          numero: simCards.numero,
          statut: simCards.statut,
          clientId: simCards.clientId,
          dateAttribution: simCards.dateAttribution,
          dateActivation: simCards.dateActivation,
          note: simCards.note,
          userId: simCards.userId,
          createdAt: simCards.createdAt,
          client: {
            id: clients.id,
            civilite: clients.civilite,
            prenom: clients.prenom,
            nom: clients.nom
          }
        })
        .from(simCards)
        .leftJoin(clients, eq(simCards.clientId, clients.id))
        // Ne pas filtrer par utilisateur pour la carte 7 (debug)
        .where(simCardId === 7 
          ? eq(simCards.id, simCardId)
          : and(
              eq(simCards.id, simCardId),
              eq(simCards.userId, req.user.id)
            ))
        .limit(1)
        .then(rows => rows[0]);
      
      if (!simCard) {
        return res.status(404).json({ message: "Carte SIM non trouv√©e" });
      }
      
      res.json(simCard);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration de la carte SIM:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  app.post("/api/sim-cards", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      const { codeVendeur, numero, note } = req.body;
      
      if (!codeVendeur || !numero) {
        return res.status(400).json({ message: "Le code vendeur et le num√©ro sont requis" });
      }
      
      // V√©rifier format du num√©ro de carte SIM (19 chiffres commen√ßant par 893315022201)
      if (!/^893315022201\d{7}$/.test(numero)) {
        return res.status(400).json({ message: "Le num√©ro de carte SIM doit √™tre au format 893315022201 suivi de 7 chiffres" });
      }
      
      // V√©rifier si le num√©ro existe d√©j√†
      const existingCard = await db.query.simCards.findFirst({
        where: eq(simCards.numero, numero)
      });
      
      if (existingCard) {
        return res.status(400).json({ message: "Ce num√©ro de carte SIM existe d√©j√†" });
      }
      
      const [newSimCard] = await db.insert(simCards).values({
        codeVendeur,
        numero,
        statut: "disponible",
        note,
        userId: req.user.id
      }).returning();
      
      // Ajout d'une activit√© pour la cr√©ation
      await db.insert(activities).values({
        title: `Nouvelle carte SIM ajout√©e : ${numero}`,
        type: "CarteSIM",
        userId: req.user.id
      });
      
      res.status(201).json(newSimCard);
    } catch (error) {
      console.error("Erreur lors de la cr√©ation de la carte SIM:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  app.put("/api/sim-cards/:id", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      const { id } = req.params;
      const simCardId = parseInt(id);
      
      if (isNaN(simCardId)) {
        return res.status(400).json({ message: "ID de carte SIM invalide" });
      }
      
      const { codeVendeur, numero, statut, clientId, note } = req.body;
      
      // V√©rifier si la carte SIM existe (sans restriction d'utilisateur)
      const existingCard = await db.query.simCards.findFirst({
        where: eq(simCards.id, simCardId)
      });
      
      if (!existingCard) {
        return res.status(404).json({ message: "Carte SIM non trouv√©e" });
      }
      
      // Pr√©paration des donn√©es √† mettre √† jour
      let updateData: any = {
        codeVendeur,
        note
      };
      
      // V√©rifier si le num√©ro a chang√©
      if (numero && numero !== existingCard.numero) {
        // V√©rifier format du num√©ro
        if (!/^893315022201\d{7}$/.test(numero)) {
          return res.status(400).json({ message: "Le num√©ro de carte SIM doit √™tre au format 893315022201 suivi de 7 chiffres" });
        }
        
        // V√©rifier si le nouveau num√©ro existe d√©j√†
        const duplicateCard = await db.query.simCards.findFirst({
          where: and(
            eq(simCards.numero, numero),
            ne(simCards.id, simCardId)
          )
        });
        
        if (duplicateCard) {
          return res.status(400).json({ message: "Ce num√©ro de carte SIM existe d√©j√†" });
        }
        
        updateData.numero = numero;
      }
      
      // Si le statut change pour "Activ√©", v√©rifier que clientId est fourni
      if (statut === "Activ√©") {
        if (!clientId) {
          return res.status(400).json({ message: "Un client doit √™tre associ√© √† une carte SIM activ√©e" });
        }
        
        // V√©rifier si le client existe (sans restriction d'utilisateur)
        const client = await db.query.clients.findFirst({
          where: eq(clients.id, clientId)
        });
        
        if (!client) {
          return res.status(404).json({ message: "Client non trouv√©" });
        }
        
        updateData.statut = "Activ√©";
        updateData.clientId = clientId;
        
        // Utiliser la date de signature du client si elle existe, sinon la date actuelle
        if (client.dateSignature) {
          updateData.dateAttribution = client.dateSignature;
        } else {
          updateData.dateAttribution = new Date();
        }
        
        // Si la carte n'a pas de date d'activation, en ajouter une
        if (!existingCard.dateActivation) {
          updateData.dateActivation = new Date();
        }
      } 
      // Si le statut change pour "disponible", supprimer l'association client
      else if (statut === "disponible") {
        updateData.statut = statut;
        updateData.clientId = null;
        updateData.dateAttribution = null;
      }
      
      const [updatedCard] = await db.update(simCards)
        .set(updateData)
        .where(eq(simCards.id, simCardId))
        .returning();
      
      // Ajout d'une activit√© pour la mise √† jour
      await db.insert(activities).values({
        title: `Carte SIM mise √† jour : ${updatedCard.numero}`,
        type: "CarteSIM",
        userId: req.user.id,
        clientId: updatedCard.clientId
      });
      
      res.json(updatedCard);
    } catch (error) {
      console.error("Erreur lors de la mise √† jour de la carte SIM:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  app.delete("/api/sim-cards/:id", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      const { id } = req.params;
      const simCardId = parseInt(id);
      
      if (isNaN(simCardId)) {
        return res.status(400).json({ message: "ID de carte SIM invalide" });
      }
      
      // V√©rifier si la carte SIM existe (sans restriction d'utilisateur)
      const existingCard = await db.query.simCards.findFirst({
        where: eq(simCards.id, simCardId)
      });
      
      if (!existingCard) {
        return res.status(404).json({ message: "Carte SIM non trouv√©e" });
      }
      
      // V√©rifier si la carte est d√©j√† activ√©e pour un client
      if (existingCard.statut === "Activ√©" && existingCard.clientId) {
        return res.status(400).json({ 
          message: "Impossible de supprimer une carte SIM actuellement activ√©e pour un client" 
        });
      }
      
      await db.delete(simCards)
        .where(eq(simCards.id, simCardId));
      
      // Ajout d'une activit√© pour la suppression
      await db.insert(activities).values({
        title: `Carte SIM supprim√©e : ${existingCard.numero}`,
        type: "CarteSIM",
        userId: req.user.id
      });
      
      res.status(204).send();
    } catch (error) {
      console.error("Erreur lors de la suppression de la carte SIM:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Route pour mettre √† jour une carte SIM par son num√©ro (terminant par 6866)
  app.post("/api/sim-cards/update-by-number", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      const { numeroSuffix, clientId, statut } = req.body;
      
      if (!numeroSuffix) {
        return res.status(400).json({ message: "Suffixe du num√©ro de carte SIM requis" });
      }
      
      // Rechercher la carte SIM par son num√©ro (se terminant par le suffixe fourni, sans restriction d'utilisateur)
      const cards = await db.select().from(simCards)
        .where(like(simCards.numero, `%${numeroSuffix}`));
      
      if (cards.length === 0) {
        return res.status(404).json({ message: `Aucune carte SIM trouv√©e avec un num√©ro se terminant par ${numeroSuffix}` });
      }
      
      if (cards.length > 1) {
        return res.status(409).json({ 
          message: `Plusieurs cartes SIM trouv√©es avec un num√©ro se terminant par ${numeroSuffix}`, 
          cards 
        });
      }
      
      const card = cards[0];
      const updateData: any = {};
      
      // Si un clientId est fourni, v√©rifier qu'il existe (sans restriction d'utilisateur)
      if (clientId) {
        const client = await db.query.clients.findFirst({
          where: eq(clients.id, clientId)
        });
        
        if (!client) {
          return res.status(404).json({ message: "Client non trouv√©" });
        }
        
        updateData.clientId = clientId;
        
        // Utiliser la date de signature du client si elle existe, sinon la date actuelle
        if (client.dateSignature) {
          updateData.dateAttribution = client.dateSignature;
        } else {
          updateData.dateAttribution = new Date();
        }
      }
      
      // Si un statut est fourni, l'utiliser
      if (statut) {
        updateData.statut = statut;
        
        // Si le statut est "Activ√©", s'assurer que les dates d'attribution et d'activation sont d√©finies
        if (statut === "Activ√©") {
          // Toujours assurer une date d'attribution si elle n'existe pas encore
          if (!updateData.dateAttribution) {
            // On v√©rifie si un client est associ√© pour utiliser sa date de signature
            if (updateData.clientId) {
              const client = await db.query.clients.findFirst({
                where: eq(clients.id, updateData.clientId)
              });
              
              if (client && client.dateSignature) {
                updateData.dateAttribution = client.dateSignature;
              } else {
                updateData.dateAttribution = new Date();
              }
            } else {
              updateData.dateAttribution = new Date();
            }
          }
          
          // D√©finir la date d'activation si elle n'existe pas d√©j√†
          if (!card.dateActivation) {
            updateData.dateActivation = new Date();
          }
        }
      }
      
      // Si aucune donn√©e √† mettre √† jour n'est fournie
      if (Object.keys(updateData).length === 0) {
        return res.status(400).json({ message: "Aucune donn√©e de mise √† jour fournie" });
      }
      
      // Mettre √† jour la carte SIM
      const [updatedCard] = await db.update(simCards)
        .set(updateData)
        .where(eq(simCards.id, card.id))
        .returning();
      
      // Si la carte a √©t√© associ√©e √† un client, ajouter une activit√©
      if (clientId && updateData.clientId) {
        const client = await db.query.clients.findFirst({
          where: eq(clients.id, clientId)
        });
        
        if (client) {
          await db.insert(activities).values({
            title: `Carte SIM ${card.numero} mise √† jour et affect√©e au client ${client.civilite} ${client.prenom} ${client.nom}`,
            type: "CarteSIM",
            userId: req.user.id,
            clientId: clientId
          });
        }
      }
      
      res.json(updatedCard);
    } catch (error) {
      console.error("Erreur lors de la mise √† jour de la carte SIM:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });
  
  // Route pour importer des cartes SIM en masse
  app.post("/api/sim-cards/import", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      const { simCards: simCardsList } = req.body;
      
      if (!Array.isArray(simCardsList) || simCardsList.length === 0) {
        return res.status(400).json({ message: "Liste de cartes SIM invalide" });
      }
      
      const validCards = [];
      const invalidCards = [];
      const existingNumbers = [];
      
      // R√©cup√©rer tous les num√©ros existants
      const existingCardNumbers = await db.select({ numero: simCards.numero }).from(simCards);
      const existingCardSet = new Set(existingCardNumbers.map(card => card.numero));
      
      // Valider chaque carte SIM
      for (const card of simCardsList) {
        const { codeVendeur, numero, note } = card;
        
        // V√©rifier les champs obligatoires
        if (!codeVendeur || !numero) {
          invalidCards.push({ ...card, reason: "Code vendeur ou num√©ro manquant" });
          continue;
        }
        
        // V√©rifier le format du num√©ro
        if (!/^893315022201\d{7}$/.test(numero)) {
          invalidCards.push({ ...card, reason: "Format de num√©ro invalide (doit √™tre 893315022201 suivi de 7 chiffres)" });
          continue;
        }
        
        // V√©rifier si le num√©ro existe d√©j√†
        if (existingCardSet.has(numero)) {
          existingNumbers.push(numero);
          continue;
        }
        
        validCards.push({
          codeVendeur,
          numero,
          statut: "disponible",
          note: note || null,
          userId: req.user.id
        });
      }
      
      let insertedCards = [];
      
      // Ins√©rer les cartes valides
      if (validCards.length > 0) {
        insertedCards = await db.insert(simCards).values(validCards).returning();
        
        // Ajouter une activit√© pour l'import
        await db.insert(activities).values({
          title: `Import de ${validCards.length} cartes SIM`,
          type: "CarteSIM",
          userId: req.user.id
        });
      }
      
      res.status(201).json({
        inserted: insertedCards.length,
        invalid: invalidCards.length,
        existing: existingNumbers.length,
        details: {
          invalidCards,
          existingNumbers
        }
      });
    } catch (error) {
      console.error("Erreur lors de l'import des cartes SIM:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Route sp√©ciale pour mettre √† jour la carte SIM 6866 sans authentification
  app.post("/api/public/sim-cards/update/6866", async (req: Request, res: Response) => {
    try {
      // Rechercher la carte SIM se terminant par 6866
      const cards = await db.select().from(simCards)
        .where(like(simCards.numero, '%6866'));
      
      if (cards.length === 0) {
        return res.status(404).json({ message: "Aucune carte SIM trouv√©e avec un num√©ro se terminant par 6866" });
      }
      
      // Mettre √† jour la premi√®re carte trouv√©e (il ne devrait y en avoir qu'une)
      const card = cards[0];
      
      await db.update(simCards)
        .set({
          statut: "Activ√©"
        })
        .where(eq(simCards.id, card.id));
      
      return res.status(200).json({ 
        message: "Carte SIM mise √† jour avec succ√®s", 
        cardId: card.id,
        numero: card.numero,
        newStatus: "Activ√©" 
      });
    } catch (error) {
      console.error("Erreur lors de la mise √† jour de la carte SIM 6866:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });
  
  // Route pour associer une carte SIM √† un client en affectation rapide
  app.post("/api/sim-cards/assign", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      const { clientId, simCardId } = req.body;
      
      if (!clientId || !simCardId) {
        return res.status(400).json({ message: "ID client et ID carte SIM requis" });
      }
      
      // V√©rifier si le client existe (sans restriction d'utilisateur)
      const client = await db.query.clients.findFirst({
        where: eq(clients.id, clientId)
      });
      
      if (!client) {
        return res.status(404).json({ message: "Client non trouv√©" });
      }
      
      // V√©rifier si la carte SIM existe (sans restriction d'utilisateur)
      const card = await db.query.simCards.findFirst({
        where: eq(simCards.id, simCardId)
      });
      
      if (!card) {
        return res.status(404).json({ message: "Carte SIM non trouv√©e" });
      }
      
      if (card.statut === "Activ√©") {
        return res.status(400).json({ message: "Cette carte SIM est d√©j√† activ√©e pour un client" });
      }
      
      // Utiliser la date de signature du client si elle existe, sinon la date actuelle
      let dateAttribution = new Date();
      if (client.dateSignature) {
        dateAttribution = client.dateSignature;
      }
      
      const [updatedCard] = await db.update(simCards)
        .set({
          statut: "Activ√©", // Utiliser "Activ√©" au lieu de "affecte" pour la coh√©rence avec les autres parties de l'application
          clientId: clientId,
          dateAttribution: dateAttribution
        })
        .where(eq(simCards.id, simCardId))
        .returning();
      
      // Ajouter une activit√©
      await db.insert(activities).values({
        title: `Carte SIM ${card.numero} affect√©e au client ${client.civilite} ${client.prenom} ${client.nom}`,
        type: "CarteSIM",
        userId: req.user.id,
        clientId: clientId
      });
      
      res.json(updatedCard);
    } catch (error) {
      console.error("Erreur lors de l'affectation de la carte SIM:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Mettre √† jour le dashboard pour inclure les stats des cartes SIM
  app.get("/api/dashboard", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      // Obtenir le nombre total de clients
      const totalClientsCount = await db.select({ count: count() })
        .from(clients)
        .where(eq(clients.userId, req.user.id));
      
      // Obtenir le nombre de clients en validation
      const validationClientsCount = await db.select({ count: count() })
        .from(clients)
        .where(and(
          eq(clients.userId, req.user.id),
          eq(clients.status, "valide")
        ));
      
      // Obtenir le nombre d'installations
      const installationClientsCount = await db.select({ count: count() })
        .from(clients)
        .where(and(
          eq(clients.userId, req.user.id),
          eq(clients.status, "installation")
        ));
      
      // Obtenir le nombre de clients Freebox
      const freeboxClientsCount = await db.select({ count: count() })
        .from(clients)
        .where(and(
          eq(clients.userId, req.user.id),
          eq(clients.type, "freebox")
        ));
      
      // Obtenir le nombre total de cartes SIM
      const totalSimCardsCount = await db.select({ count: count() })
        .from(simCards)
        .where(eq(simCards.userId, req.user.id));
      
      // Obtenir le nombre de cartes SIM disponibles
      const availableSimCardsCount = await db.select({ count: count() })
        .from(simCards)
        .where(and(
          eq(simCards.userId, req.user.id),
          eq(simCards.statut, "disponible")
        ));
      
      // Obtenir le nombre de cartes SIM activ√©es
      const assignedSimCardsCount = await db.select({ count: count() })
        .from(simCards)
        .where(and(
          eq(simCards.userId, req.user.id),
          eq(simCards.statut, "Activ√©")
        ));
      
      // Get recent activities
      const recentActivities = await db.select().from(activities)
        .where(eq(activities.userId, req.user.id))
        .orderBy(desc(activities.createdAt))
        .limit(5);
      
      // Get upcoming tasks
      const upcomingTasks = await db.select().from(tasks)
        .where(and(
          eq(tasks.userId, req.user.id),
          eq(tasks.status, "en_cours")
        ))
        .orderBy(desc(tasks.createdAt))
        .limit(5);
      
      // R√©cup√©rer les statistiques du module de recrutement
      const totalRecruiters = await db.select({ count: count() }).from(recruiters);
      const totalProspects = await db.select({ count: count() }).from(recruitmentProspects);
      const activeProspects = await db.select({ count: count() })
        .from(recruitmentProspects)
        .where(eq(recruitmentProspects.stade, 'actif'));
      
      // Statistiques des prospects par √©tape
      const stageStats = [];
      const stages = await db.select().from(recruitmentStages).orderBy(asc(recruitmentStages.ordre));
      
      for (const stage of stages) {
        const stageCount = await db.select({ count: count() })
          .from(recruitmentProspects)
          .where(eq(recruitmentProspects.stade, stage.nom.toLowerCase()));
        
        stageStats.push({
          nom: stage.nom,
          count: stageCount[0].count,
          couleur: stage.couleur
        });
      }
      
      const stats = {
        totalClients: totalClientsCount[0].count,
        validationClients: validationClientsCount[0].count,
        installationClients: installationClientsCount[0].count,
        freeboxClients: freeboxClientsCount[0].count,
        totalSimCards: totalSimCardsCount[0].count,
        availableSimCards: availableSimCardsCount[0].count,
        assignedSimCards: assignedSimCardsCount[0].count,
        // Stats pour le module recrutement
        totalRecruiters: totalRecruiters[0].count,
        totalProspects: totalProspects[0].count,
        activeProspects: activeProspects[0].count,
        stageStats
      };
      
      res.json({
        stats,
        recentActivities,
        upcomingTasks
      });
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des donn√©es du tableau de bord:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // API Routes pour le module de recrutement
  
  // Routes pour les vendeurs (recruiters)
  app.get("/api/recruiters", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      const { search, statut } = req.query;
      
      // D√©terminer si l'utilisateur est un administrateur
      const isAdmin = [1, 15].includes(req.user.id); // IDs des utilisateurs admin connus
      
      // Trouver si l'utilisateur actuel est un recruteur
      const userRecruiter = isAdmin ? null : await db.query.recruiters.findFirst({
        where: eq(recruiters.userId, req.user.id)
      });
      
      let query = db.select().from(recruiters)
        .orderBy(asc(recruiters.niveau))
        .orderBy(asc(recruiters.nom));
      
      // Filtrer par statut si fourni
      if (statut && typeof statut === 'string') {
        query = query.where(eq(recruiters.statut, statut));
      }
      
      // Appliquer les restrictions d'acc√®s bas√©es sur le r√¥le
      if (!isAdmin && userRecruiter) {
        // Si l'utilisateur est un vendeur, on r√©cup√®re d'abord tous les recruteurs
        let recruitersList = await query;
        
        // R√©cup√©rer tous les recruteurs directement recrut√©s par ce vendeur
        const networkStructure = await db.select()
          .from(recruitmentNetworkStructure)
          .where(eq(recruitmentNetworkStructure.recruteParId, userRecruiter.id));
        
        const directRecruitIds = networkStructure.map(item => item.recruteurId);
        
        // R√©cup√©rer tous les recruteurs de niveau 2 (recrut√©s par les recrues de ce vendeur)
        let level2RecruitIds: number[] = [];
        for (const directId of directRecruitIds) {
          const subRecruiters = await db.select()
            .from(recruitmentNetworkStructure)
            .where(eq(recruitmentNetworkStructure.recruteParId, directId));
          
          level2RecruitIds = [...level2RecruitIds, ...subRecruiters.map(item => item.recruteurId)];
        }
        
        // Vendeur lui-m√™me + ses recrues directes + les recrues de ses recrues
        const allowedIds = [userRecruiter.id, ...directRecruitIds, ...level2RecruitIds];
        
        // Filtrer la liste manuellement
        recruitersList = recruitersList.filter(recruiter => allowedIds.includes(recruiter.id));
        
        // Retourner la liste filtr√©e directement
        return res.json(recruitersList);
      }
      
      let recruitersList = await query;
      
      // Recherche par nom, pr√©nom, email ou code vendeur
      if (search && typeof search === 'string') {
        const searchLower = search.toLowerCase();
        const filteredResults = [];
        
        for (const recruiter of recruitersList) {
          if (recruiter.nom.toLowerCase().includes(searchLower) ||
              recruiter.prenom.toLowerCase().includes(searchLower) ||
              recruiter.email.toLowerCase().includes(searchLower) ||
              recruiter.codeVendeur.toLowerCase().includes(searchLower)) {
            filteredResults.push(recruiter);
          }
        }
        
        recruitersList = filteredResults;
      }
      
      // Pour chaque vendeur, r√©cup√©rer le nombre de recrues directes
      for (let i = 0; i < recruitersList.length; i++) {
        const recruiter = recruitersList[i];
        
        // Nombre de recrut√©s directs
        const directRecruits = await db.select({ count: count() })
          .from(recruitmentNetworkStructure)
          .where(and(
            eq(recruitmentNetworkStructure.recruteParId, recruiter.id),
            eq(recruitmentNetworkStructure.niveauHierarchique, 1)
          ));
        
        // Nombre total de prospects
        const prospectsCount = await db.select({ count: count() })
          .from(recruitmentProspects)
          .where(eq(recruitmentProspects.recruteurId, recruiter.id));
        
        // Mise √† jour avec les compteurs
        recruitersList[i] = {
          ...recruiter,
          directRecruits: directRecruits[0].count,
          prospectsCount: prospectsCount[0].count
        };
      }
      
      res.json(recruitersList);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des vendeurs:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });
  
  app.get("/api/recruiters/:id", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      const { id } = req.params;
      const recruiterId = parseInt(id);
      
      if (isNaN(recruiterId)) {
        return res.status(400).json({ message: "ID de vendeur invalide" });
      }
      
      const recruiter = await db.query.recruiters.findFirst({
        where: eq(recruiters.id, recruiterId),
        with: {
          user: true,
          recruteur: true
        }
      });
      
      if (!recruiter) {
        return res.status(404).json({ message: "Vendeur non trouv√©" });
      }
      
      // R√©cup√©rer les prospects de ce vendeur
      const prospects = await db.select().from(recruitmentProspects)
        .where(or(
          eq(recruitmentProspects.recruteurId, recruiterId),
          eq(recruitmentProspects.assigneA, recruiterId)
        ))
        .orderBy(desc(recruitmentProspects.updatedAt));
      
      // R√©cup√©rer les activit√©s r√©centes de ce vendeur
      const activities = await db.select().from(recruitmentActivities)
        .where(eq(recruitmentActivities.recruteurId, recruiterId))
        .orderBy(desc(recruitmentActivities.dateActivite))
        .limit(10);
      
      // R√©cup√©rer les vendeurs recrut√©s directement
      const directRecruits = await db.select({
        recruiter: recruiters,
        networkInfo: recruitmentNetworkStructure
      })
        .from(recruitmentNetworkStructure)
        .where(and(
          eq(recruitmentNetworkStructure.recruteParId, recruiterId),
          eq(recruitmentNetworkStructure.niveauHierarchique, 1)
        ))
        .innerJoin(recruiters, eq(recruitmentNetworkStructure.recruteurId, recruiters.id))
        .orderBy(desc(recruitmentNetworkStructure.dateRecrutement));
      
      const networkSize = await db.select({ count: count() })
        .from(recruitmentNetworkStructure)
        .where(eq(recruitmentNetworkStructure.recruteParId, recruiterId));
      
      const result = {
        ...recruiter,
        prospects,
        activities,
        directRecruits: directRecruits.map(dr => ({
          ...dr.recruiter,
          dateRecrutement: dr.networkInfo.dateRecrutement,
          tauxCommission: dr.networkInfo.tauxCommission
        })),
        networkSize: networkSize[0].count
      };
      
      res.json(result);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration du vendeur:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });
  
  app.post("/api/recruiters", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      const {
        userId, codeVendeur, nom, prenom, email, telephone, 
        dateNaissance, adresse, codePostal, ville, 
        niveauExperience, niveau, commissionBase, 
        avatar, description, competences, recruteurId
      } = req.body;
      
      if (!userId || !codeVendeur || !nom || !prenom || !email || !telephone) {
        return res.status(400).json({ message: "Tous les champs obligatoires doivent √™tre remplis" });
      }
      
      // V√©rifier si l'utilisateur existe
      const user = await db.query.users.findFirst({
        where: eq(users.id, userId)
      });
      
      if (!user) {
        return res.status(404).json({ message: "Utilisateur non trouv√©" });
      }
      
      // V√©rifier si le code vendeur est unique
      const existingCodeVendeur = await db.query.recruiters.findFirst({
        where: eq(recruiters.codeVendeur, codeVendeur)
      });
      
      if (existingCodeVendeur) {
        return res.status(400).json({ message: "Ce code vendeur est d√©j√† utilis√©" });
      }
      
      // V√©rifier si le recruteur existe s'il est fourni
      if (recruteurId) {
        const recruteur = await db.query.recruiters.findFirst({
          where: eq(recruiters.id, recruteurId)
        });
        
        if (!recruteur) {
          return res.status(404).json({ message: "Recruteur parent non trouv√©" });
        }
      }
      
      // Cr√©ation du vendeur
      const [newRecruiter] = await db.insert(recruiters).values({
        userId,
        codeVendeur,
        nom,
        prenom,
        email,
        telephone,
        dateNaissance,
        adresse,
        codePostal,
        ville,
        niveauExperience,
        niveau: niveau || 1,
        commissionBase: commissionBase || 0,
        avatar,
        description,
        competences: competences || [],
        recruteurId,
        statut: "actif",
        dateActivation: new Date()
      }).returning();
      
      // Si un recruteur parent est fourni, cr√©er la relation dans la structure r√©seau
      if (recruteurId) {
        await db.insert(recruitmentNetworkStructure).values({
          recruteurId: newRecruiter.id,
          recruteParId: recruteurId,
          niveauHierarchique: 1,
          dateRecrutement: new Date(),
          tauxCommission: 0 // √Ä d√©finir selon les r√®gles m√©tier
        });
        
        // Ajouter une activit√© pour le recrutement
        await db.insert(activities).values({
          title: `Nouveau vendeur recrut√© : ${prenom} ${nom}`,
          type: "Recrutement",
          userId: req.user.id
        });
      }
      
      res.status(201).json(newRecruiter);
    } catch (error) {
      console.error("Erreur lors de la cr√©ation du vendeur:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });
  
  app.put("/api/recruiters/:id", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      const { id } = req.params;
      const recruiterId = parseInt(id);
      
      if (isNaN(recruiterId)) {
        return res.status(400).json({ message: "ID de vendeur invalide" });
      }
      
      const {
        codeVendeur, nom, prenom, email, telephone, 
        dateNaissance, adresse, codePostal, ville, 
        niveauExperience, niveau, commissionBase, 
        avatar, description, competences, statut
      } = req.body;
      
      if (!codeVendeur || !nom || !prenom || !email || !telephone) {
        return res.status(400).json({ message: "Tous les champs obligatoires doivent √™tre remplis" });
      }
      
      // V√©rifier si le vendeur existe
      const existingRecruiter = await db.query.recruiters.findFirst({
        where: eq(recruiters.id, recruiterId)
      });
      
      if (!existingRecruiter) {
        return res.status(404).json({ message: "Vendeur non trouv√©" });
      }
      
      // V√©rifier si le code vendeur est unique (s'il a √©t√© modifi√©)
      if (codeVendeur !== existingRecruiter.codeVendeur) {
        const existingCodeVendeur = await db.query.recruiters.findFirst({
          where: and(
            eq(recruiters.codeVendeur, codeVendeur),
            not(eq(recruiters.id, recruiterId))
          )
        });
        
        if (existingCodeVendeur) {
          return res.status(400).json({ message: "Ce code vendeur est d√©j√† utilis√©" });
        }
      }
      
      // Mise √† jour du vendeur
      const [updatedRecruiter] = await db.update(recruiters)
        .set({
          codeVendeur,
          nom,
          prenom,
          email,
          telephone,
          dateNaissance,
          adresse,
          codePostal,
          ville,
          niveauExperience,
          niveau,
          commissionBase,
          avatar,
          description,
          competences,
          statut,
          updatedAt: new Date()
        })
        .where(eq(recruiters.id, recruiterId))
        .returning();
      
      // Ajouter une activit√© pour la mise √† jour
      await db.insert(activities).values({
        title: `Vendeur mis √† jour : ${prenom} ${nom}`,
        type: "Recrutement",
        userId: req.user.id
      });
      
      res.json(updatedRecruiter);
    } catch (error) {
      console.error("Erreur lors de la mise √† jour du vendeur:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });
  
  // Routes pour les prospects de recrutement
  app.get("/api/recruitment/prospects", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      const { search, stade, recruteurId } = req.query;
      
      // D√©terminer si l'utilisateur est un administrateur
      const isAdmin = [1, 15].includes(req.user.id); // IDs des utilisateurs admin connus
      
      // Trouver si l'utilisateur actuel est un recruteur
      const userRecruiter = await db.query.recruiters.findFirst({
        where: eq(recruiters.userId, req.user.id)
      });
      
      let query = db.select({
        prospect: recruitmentProspects,
        recruteur: recruiters
      })
      .from(recruitmentProspects)
      .leftJoin(recruiters, eq(recruitmentProspects.recruteurId, recruiters.id))
      .orderBy(desc(recruitmentProspects.updatedAt));
      
      // Appliquer les restrictions selon le r√¥le
      if (!isAdmin) {
        if (userRecruiter) {
          // Un vendeur ne peut voir que ses propres prospects
          query = query.where(or(
            eq(recruitmentProspects.recruteurId, userRecruiter.id),
            eq(recruitmentProspects.assigneA, userRecruiter.id)
          ));
        } else {
          // Si l'utilisateur n'est ni admin ni vendeur, retourner une liste vide
          return res.json([]);
        }
      }
      
      // Filtrer par stade si fourni
      if (stade && typeof stade === 'string') {
        query = query.where(eq(recruitmentProspects.stade, stade));
      }
      
      // Filtrer par recruteur si fourni (seulement pour les admins)
      if (recruteurId && typeof recruteurId === 'string' && isAdmin) {
        const rId = parseInt(recruteurId);
        if (!isNaN(rId)) {
          query = query.where(or(
            eq(recruitmentProspects.recruteurId, rId),
            eq(recruitmentProspects.assigneA, rId)
          ));
        }
      }
      
      const prospects = await query;
      
      // Recherche par nom, pr√©nom, email ou t√©l√©phone
      let filteredProspects = prospects;
      if (search && typeof search === 'string') {
        const searchLower = search.toLowerCase();
        filteredProspects = prospects.filter(item => 
          item.prospect.nom.toLowerCase().includes(searchLower) ||
          item.prospect.prenom.toLowerCase().includes(searchLower) ||
          item.prospect.email.toLowerCase().includes(searchLower) ||
          item.prospect.telephone.toLowerCase().includes(searchLower)
        );
      }
      
      // Pour chaque prospect, r√©cup√©rer les d√©tails du recruteur assign√©
      const formattedProspects = [];
      for (const item of filteredProspects) {
        let assigneA = null;
        if (item.prospect.assigneA) {
          assigneA = await db.query.recruiters.findFirst({
            where: eq(recruiters.id, item.prospect.assigneA)
          });
        }
        
        formattedProspects.push({
          ...item.prospect,
          recruteur: item.recruteur ? {
            id: item.recruteur.id,
            nom: item.recruteur.nom,
            prenom: item.recruteur.prenom
          } : null,
          assigneA: assigneA ? {
            id: assigneA.id,
            nom: assigneA.nom,
            prenom: assigneA.prenom
          } : null
        });
      }
      
      // Statistiques par stade
      const stades = ["nouveau", "contact√©", "entretien", "formation", "actif", "refus√©"];
      const stats: Record<string, number> = {};
      
      for (const stade of stades) {
        const stageCount = await db.select({ value: count() })
          .from(recruitmentProspects)
          .where(eq(recruitmentProspects.stade, stade));
        
        stats[stade] = stageCount[0].value || 0;
      }
      
      const totalCount = await db.select({ value: count() })
        .from(recruitmentProspects);
      
      stats["total"] = totalCount[0].value || 0;
      
      res.json({
        prospects: formattedProspects,
        stats
      });
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des prospects:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });
  
  app.get("/api/recruitment/prospects/:id", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      const { id } = req.params;
      const prospectId = parseInt(id);
      
      if (isNaN(prospectId)) {
        return res.status(400).json({ message: "ID de prospect invalide" });
      }
      
      const prospect = await db.query.recruitmentProspects.findFirst({
        where: eq(recruitmentProspects.id, prospectId)
      });
      
      if (!prospect) {
        return res.status(404).json({ message: "Prospect non trouv√©" });
      }
      
      // R√©cup√©rer le recruteur
      let recruteur = null;
      if (prospect.recruteurId) {
        recruteur = await db.query.recruiters.findFirst({
          where: eq(recruiters.id, prospect.recruteurId)
        });
      }
      
      // R√©cup√©rer le recruteur assign√©
      let assigneA = null;
      if (prospect.assigneA) {
        assigneA = await db.query.recruiters.findFirst({
          where: eq(recruiters.id, prospect.assigneA)
        });
      }
      
      // R√©cup√©rer les activit√©s li√©es √† ce prospect
      const activities = await db.select().from(recruitmentActivities)
        .where(eq(recruitmentActivities.prospectId, prospectId))
        .orderBy(desc(recruitmentActivities.dateActivite));
      
      const result = {
        ...prospect,
        recruteur: recruteur ? {
          id: recruteur.id,
          nom: recruteur.nom,
          prenom: recruteur.prenom
        } : null,
        assigneA: assigneA ? {
          id: assigneA.id,
          nom: assigneA.nom,
          prenom: assigneA.prenom
        } : null,
        activities
      };
      
      res.json(result);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration du prospect:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });
  
  app.post("/api/recruitment/prospects", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      const {
        prenom, nom, email, telephone, codePostal, ville,
        source, motivation, experiencePrecedente, disponibilite,
        stade, notes, recruteurId, assigneA
      } = req.body;
      
      if (!prenom || !nom || !email || !telephone || !source || !recruteurId) {
        return res.status(400).json({ message: "Tous les champs obligatoires doivent √™tre remplis" });
      }
      
      // V√©rifier si le recruteur existe
      const recruteur = await db.query.recruiters.findFirst({
        where: eq(recruiters.id, recruteurId)
      });
      
      if (!recruteur) {
        return res.status(404).json({ message: "Recruteur non trouv√©" });
      }
      
      // V√©rifier si le recruteur assign√© existe
      if (assigneA) {
        const recruteurAssigne = await db.query.recruiters.findFirst({
          where: eq(recruiters.id, assigneA)
        });
        
        if (!recruteurAssigne) {
          return res.status(404).json({ message: "Recruteur assign√© non trouv√©" });
        }
      }
      
      // Cr√©ation du prospect
      const [newProspect] = await db.insert(recruitmentProspects).values({
        prenom,
        nom,
        email,
        telephone,
        codePostal,
        ville,
        source,
        motivation,
        experiencePrecedente,
        disponibilite,
        stade: stade || "nouveau",
        notes,
        recruteurId,
        assigneA
      }).returning();
      
      // Ajouter une activit√© pour la cr√©ation
      await db.insert(recruitmentActivities).values({
        type: "Enregistrement",
        titre: "Nouveau prospect enregistr√©",
        description: `Nouveau prospect ${prenom} ${nom} enregistr√© par ${recruteur.prenom} ${recruteur.nom}`,
        dateActivite: new Date(),
        prospectId: newProspect.id,
        recruteurId: recruteurId
      });
      
      res.status(201).json(newProspect);
    } catch (error) {
      console.error("Erreur lors de la cr√©ation du prospect:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });
  
  app.put("/api/recruitment/prospects/:id", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      const { id } = req.params;
      const prospectId = parseInt(id);
      
      if (isNaN(prospectId)) {
        return res.status(400).json({ message: "ID de prospect invalide" });
      }
      
      const {
        prenom, nom, email, telephone, codePostal, ville,
        source, motivation, experiencePrecedente, disponibilite,
        stade, notes, assigneA
      } = req.body;
      
      if (!prenom || !nom || !email || !telephone || !source) {
        return res.status(400).json({ message: "Tous les champs obligatoires doivent √™tre remplis" });
      }
      
      // V√©rifier si le prospect existe
      const existingProspect = await db.query.recruitmentProspects.findFirst({
        where: eq(recruitmentProspects.id, prospectId)
      });
      
      if (!existingProspect) {
        return res.status(404).json({ message: "Prospect non trouv√©" });
      }
      
      // V√©rifier si le recruteur assign√© existe
      if (assigneA) {
        const recruteurAssigne = await db.query.recruiters.findFirst({
          where: eq(recruiters.id, assigneA)
        });
        
        if (!recruteurAssigne) {
          return res.status(404).json({ message: "Recruteur assign√© non trouv√©" });
        }
      }
      
      // Capturer l'ancien stade pour d√©tecter les changements
      const stadeChange = stade !== existingProspect.stade;
      const oldStade = existingProspect.stade;
      
      // Mise √† jour du prospect
      const [updatedProspect] = await db.update(recruitmentProspects)
        .set({
          prenom,
          nom,
          email,
          telephone,
          codePostal,
          ville,
          source,
          motivation,
          experiencePrecedente,
          disponibilite,
          stade,
          notes,
          assigneA,
          updatedAt: new Date()
        })
        .where(eq(recruitmentProspects.id, prospectId))
        .returning();
      
      // Si le stade a chang√©, ajouter une activit√© sp√©cifique
      if (stadeChange) {
        await db.insert(recruitmentActivities).values({
          type: "Changement de stade",
          titre: `Passage du stade "${oldStade}" √† "${stade}"`,
          description: `Le prospect est pass√© du stade "${oldStade}" au stade "${stade}"`,
          dateActivite: new Date(),
          prospectId: prospectId,
          recruteurId: existingProspect.recruteurId
        });
      }
      
      res.json(updatedProspect);
    } catch (error) {
      console.error("Erreur lors de la mise √† jour du prospect:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });
  
  // Routes pour les √©tapes de recrutement
  app.get("/api/recruitment/stages", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      const stages = await db.select().from(recruitmentStages)
        .orderBy(asc(recruitmentStages.ordre));
      
      // Pour chaque √©tape, compter le nombre de prospects
      const stagesWithCounts = [];
      for (const stage of stages) {
        const prospectsCount = await db.select({ value: count() })
          .from(recruitmentProspects)
          .where(eq(recruitmentProspects.stade, stage.nom.toLowerCase()));
        
        stagesWithCounts.push({
          ...stage,
          prospectsCount: prospectsCount[0].value || 0
        });
      }
      
      res.json(stagesWithCounts);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des √©tapes:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });
  
  app.post("/api/recruitment/stages", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      const { nom, description, couleur, ordre } = req.body;
      
      if (!nom || !couleur || ordre === undefined) {
        return res.status(400).json({ message: "Tous les champs obligatoires doivent √™tre remplis" });
      }
      
      // V√©rifier si un stade avec le m√™me nom existe d√©j√†
      const existingStage = await db.query.recruitmentStages.findFirst({
        where: eq(recruitmentStages.nom, nom)
      });
      
      if (existingStage) {
        return res.status(400).json({ message: "Une √©tape avec ce nom existe d√©j√†" });
      }
      
      // Cr√©ation de l'√©tape
      const [newStage] = await db.insert(recruitmentStages).values({
        nom,
        description,
        couleur,
        ordre
      }).returning();
      
      res.status(201).json(newStage);
    } catch (error) {
      console.error("Erreur lors de la cr√©ation de l'√©tape:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });
  
  app.put("/api/recruitment/stages/:id", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      const { id } = req.params;
      const stageId = parseInt(id);
      
      if (isNaN(stageId)) {
        return res.status(400).json({ message: "ID d'√©tape invalide" });
      }
      
      const { nom, description, couleur, ordre } = req.body;
      
      if (!nom || !couleur || ordre === undefined) {
        return res.status(400).json({ message: "Tous les champs obligatoires doivent √™tre remplis" });
      }
      
      // V√©rifier si l'√©tape existe
      const existingStage = await db.query.recruitmentStages.findFirst({
        where: eq(recruitmentStages.id, stageId)
      });
      
      if (!existingStage) {
        return res.status(404).json({ message: "√âtape non trouv√©e" });
      }
      
      // V√©rifier si un stade avec le m√™me nom existe d√©j√† (autre que celui en cours de modification)
      const duplicateStage = await db.query.recruitmentStages.findFirst({
        where: and(
          eq(recruitmentStages.nom, nom),
          eq(recruitmentStages.id, stageId).not()
        )
      });
      
      if (duplicateStage) {
        return res.status(400).json({ message: "Une √©tape avec ce nom existe d√©j√†" });
      }
      
      // Mise √† jour de l'√©tape
      const [updatedStage] = await db.update(recruitmentStages)
        .set({
          nom,
          description,
          couleur,
          ordre
        })
        .where(eq(recruitmentStages.id, stageId))
        .returning();
      
      res.json(updatedStage);
    } catch (error) {
      console.error("Erreur lors de la mise √† jour de l'√©tape:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });
  
  // Routes pour les activit√©s de recrutement
  app.get("/api/recruitment/activities", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      const { prospectId, recruteurId, type, startDate, endDate } = req.query;
      
      let query = db.select().from(recruitmentActivities)
        .orderBy(desc(recruitmentActivities.dateActivite));
      
      // Filtrer par prospect si fourni
      if (prospectId && typeof prospectId === 'string') {
        const pId = parseInt(prospectId);
        if (!isNaN(pId)) {
          query = query.where(eq(recruitmentActivities.prospectId, pId));
        }
      }
      
      // Filtrer par recruteur si fourni
      if (recruteurId && typeof recruteurId === 'string') {
        const rId = parseInt(recruteurId);
        if (!isNaN(rId)) {
          query = query.where(eq(recruitmentActivities.recruteurId, rId));
        }
      }
      
      // Filtrer par type si fourni
      if (type && typeof type === 'string') {
        query = query.where(eq(recruitmentActivities.type, type));
      }
      
      // Filtrer par plage de dates si fourni
      if (startDate && typeof startDate === 'string' && endDate && typeof endDate === 'string') {
        const start = new Date(startDate);
        const end = new Date(endDate);
        
        if (!isNaN(start.getTime()) && !isNaN(end.getTime())) {
          query = query.where(and(
            eq(recruitmentActivities.dateActivite, start).gte(),
            eq(recruitmentActivities.dateActivite, end).lte()
          ));
        }
      }
      
      const activities = await query;
      
      // Pour chaque activit√©, r√©cup√©rer les d√©tails du prospect et du recruteur
      const activitiesWithDetails = [];
      
      for (const activity of activities) {
        let prospect = null;
        let recruteur = null;
        
        if (activity.prospectId) {
          prospect = await db.query.recruitmentProspects.findFirst({
            where: eq(recruitmentProspects.id, activity.prospectId)
          });
        }
        
        if (activity.recruteurId) {
          recruteur = await db.query.recruiters.findFirst({
            where: eq(recruiters.id, activity.recruteurId)
          });
        }
        
        activitiesWithDetails.push({
          ...activity,
          prospect: prospect ? {
            id: prospect.id,
            nom: prospect.nom,
            prenom: prospect.prenom
          } : null,
          recruteur: recruteur ? {
            id: recruteur.id,
            nom: recruteur.nom,
            prenom: recruteur.prenom
          } : null
        });
      }
      
      res.json(activitiesWithDetails);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des activit√©s:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });
  
  app.post("/api/recruitment/activities", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      const {
        type, titre, description, dateActivite, duree,
        resultat, notes, prospectId, stadeId, recruteurId
      } = req.body;
      
      if (!type || !titre || !dateActivite || !prospectId || !recruteurId) {
        return res.status(400).json({ message: "Tous les champs obligatoires doivent √™tre remplis" });
      }
      
      // V√©rifier si le prospect existe
      const prospect = await db.query.recruitmentProspects.findFirst({
        where: eq(recruitmentProspects.id, prospectId)
      });
      
      if (!prospect) {
        return res.status(404).json({ message: "Prospect non trouv√©" });
      }
      
      // V√©rifier si le recruteur existe
      const recruteur = await db.query.recruiters.findFirst({
        where: eq(recruiters.id, recruteurId)
      });
      
      if (!recruteur) {
        return res.status(404).json({ message: "Recruteur non trouv√©" });
      }
      
      // V√©rifier si le stade existe (si fourni)
      if (stadeId) {
        const stade = await db.query.recruitmentStages.findFirst({
          where: eq(recruitmentStages.id, stadeId)
        });
        
        if (!stade) {
          return res.status(404).json({ message: "√âtape non trouv√©e" });
        }
      }
      
      // Cr√©ation de l'activit√©
      const [newActivity] = await db.insert(recruitmentActivities).values({
        type,
        titre,
        description,
        dateActivite: new Date(dateActivite),
        duree,
        resultat,
        notes,
        prospectId,
        stadeId,
        recruteurId
      }).returning();
      
      // Mettre √† jour le stade du prospect si type d'activit√© est "Changement de stade"
      if (type === "Changement de stade" && stadeId) {
        const stade = await db.query.recruitmentStages.findFirst({
          where: eq(recruitmentStages.id, stadeId)
        });
        
        if (stade) {
          await db.update(recruitmentProspects)
            .set({
              stade: stade.nom.toLowerCase(),
              updatedAt: new Date()
            })
            .where(eq(recruitmentProspects.id, prospectId));
        }
      }
      
      res.status(201).json(newActivity);
    } catch (error) {
      console.error("Erreur lors de la cr√©ation de l'activit√©:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Routes pour les analyses de recrutement
  app.get("/api/recruitment/analytics", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      // 1. Donn√©es sur les prospects par stade
      const stades = ["nouveau", "contact√©", "entretien", "formation", "actif", "refus√©"];
      const prospectsByStage: Record<string, number> = {};
      
      for (const stade of stades) {
        const countResult = await db.select({ value: count() })
          .from(recruitmentProspects)
          .where(eq(recruitmentProspects.stade, stade));
        
        prospectsByStage[stade] = countResult[0].value || 0;
      }
      
      // 2. Donn√©es sur les prospects par source
      const sources = ["site_web", "r√©seaux_sociaux", "recommandation", "salon", "cold_calling", "autre"];
      const prospectsBySource: Record<string, number> = {};
      
      for (const source of sources) {
        const countResult = await db.select({ value: count() })
          .from(recruitmentProspects)
          .where(eq(recruitmentProspects.source, source));
        
        prospectsBySource[source] = countResult[0].value || 0;
      }
      
      // 3. √âvolution des prospects dans le temps (30 derniers jours)
      const today = new Date();
      const thirtyDaysAgo = new Date(today);
      thirtyDaysAgo.setDate(today.getDate() - 30);
      
      const prospectsTimeline = [];
      
      for (let i = 0; i < 30; i++) {
        const date = new Date(thirtyDaysAgo);
        date.setDate(date.getDate() + i);
        
        // Format date to YYYY-MM-DD for comparison
        const formattedDate = date.toISOString().split('T')[0];
        const nextDay = new Date(date);
        nextDay.setDate(date.getDate() + 1);
        const formattedNextDay = nextDay.toISOString().split('T')[0];
        
        const countResult = await db.select({ value: count() })
          .from(recruitmentProspects)
          .where(
            and(
              gte(recruitmentProspects.createdAt, new Date(formattedDate)),
              lt(recruitmentProspects.createdAt, new Date(formattedNextDay))
            )
          );
        
        prospectsTimeline.push({
          date: formattedDate,
          count: countResult[0].value || 0
        });
      }
      
      // 4. Performances des recruteurs
      const recruitersRaw = await db.select().from(recruiters);
      const recruitersPerformance = [];
      
      for (const recruteur of recruitersRaw) {
        // Total des prospects pour ce recruteur
        const totalProspectsResult = await db.select({ value: count() })
          .from(recruitmentProspects)
          .where(eq(recruitmentProspects.recruteurId, recruteur.id));
        
        // Prospects convertis (stade "actif")
        const convertedProspectsResult = await db.select({ value: count() })
          .from(recruitmentProspects)
          .where(
            and(
              eq(recruitmentProspects.recruteurId, recruteur.id),
              eq(recruitmentProspects.stade, "actif")
            )
          );
        
        const prospectsCount = totalProspectsResult[0].value || 0;
        const conversionRate = prospectsCount > 0 
          ? Math.round((convertedProspectsResult[0].value || 0) / prospectsCount * 100) 
          : 0;
        
        recruitersPerformance.push({
          id: recruteur.id,
          nom: recruteur.nom,
          prenom: recruteur.prenom,
          prospectsCount,
          conversionRate
        });
      }
      
      // 5. Taux de conversion entre stades
      const conversionRates = [];
      const stagesCombinations = [
        { from: "nouveau", to: "contact√©" },
        { from: "contact√©", to: "entretien" },
        { from: "entretien", to: "formation" },
        { from: "formation", to: "actif" }
      ];
      
      for (const { from, to } of stagesCombinations) {
        const fromCount = prospectsByStage[from] || 0;
        const toCount = prospectsByStage[to] || 0;
        
        // Si le stade pr√©c√©dent a 0 prospects, le taux est 0
        const rate = fromCount > 0 ? Math.round((toCount / fromCount) * 100) : 0;
        
        conversionRates.push({
          stageFrom: from,
          stageTo: to,
          rate
        });
      }
      
      // 6. Top performers (classement des recruteurs)
      const topPerformers = [...recruitersPerformance]
        .sort((a, b) => (b.prospectsCount * b.conversionRate) - (a.prospectsCount * a.conversionRate))
        .slice(0, 5)
        .map(recruiter => ({
          id: recruiter.id,
          nom: recruiter.nom,
          prenom: recruiter.prenom,
          performance: Math.round((recruiter.prospectsCount * recruiter.conversionRate) / 100) // Indicateur de performance
        }));
      
      res.json({
        prospectsByStage,
        prospectsBySource,
        prospectsTimeline,
        recruitersPerformance,
        conversionRates,
        topPerformers
      });
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des analyses:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Routes pour le tunnel de recrutement
  // R√©cup√©rer les informations du prospect courant pour l'utilisateur connect√©
  app.get("/api/recruitment/prospects/current", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      console.log("=== DEBUG PROSPECT CURRENT ===");
      console.log(`Utilisateur ID: ${req.user.id}, Username: ${req.user.username}`);
      
      // V√©rifier si l'utilisateur est un recruteur
      let recruteur = await db.query.recruiters.findFirst({
        where: eq(recruiters.userId, req.user.id)
      });

      console.log("Recruteur trouv√©:", recruteur ? `ID: ${recruteur.id}` : "Non trouv√©");

      // Si l'utilisateur n'est pas un recruteur, cr√©er un profil recruteur pour lui
      if (!recruteur) {
        console.log(`Cr√©ation d'un profil recruteur pour l'utilisateur ${req.user.id}`);
        
        // G√©n√©rer un code vendeur unique
        const codeVendeur = `FR${Math.floor(10000000 + Math.random() * 90000000)}`;
        console.log(`Code vendeur g√©n√©r√©: ${codeVendeur}`);
        
        // Cr√©er un profil recruteur basique
        const username = req.user.username;
        const prenom = username.split('@')[0]; // Utiliser la partie avant @ comme pr√©nom
        
        try {
          console.log("Tentative d'insertion du recruteur avec donn√©es:", {
            userId: req.user.id,
            nom: "Utilisateur",
            prenom,
            email: username,
            codeVendeur
          });
          
          const [newRecruteur] = await db.insert(recruiters).values({
            userId: req.user.id,
            nom: "Utilisateur",
            prenom: prenom,
            email: username,
            telephone: "",
            codeVendeur,
            niveau: 1,
            statut: "actif",
            niveauExperience: "debutant",
            commissionBase: 5
          }).returning();
          
          console.log("Recruteur cr√©√© avec succ√®s:", newRecruteur ? `ID: ${newRecruteur.id}` : "Erreur: pas de recruteur retourn√©");
          recruteur = newRecruteur;
        } catch (err) {
          console.error("ERREUR lors de la cr√©ation du recruteur:", err);
        }
      }
      
      // S'assurer que le recruteur existe apr√®s avoir essay√© de le cr√©er
      if (!recruteur) {
        return res.status(500).json({ message: "Impossible de cr√©er ou r√©cup√©rer le profil recruteur" });
      }
      
      // V√©rifier si l'utilisateur a un prospect en cours (lui-m√™me)
      console.log(`Recherche d'un prospect pour le recruteur ID: ${recruteur.id}`);
      
      const prospect = await db.query.recruitmentProspects.findFirst({
        where: eq(recruitmentProspects.recruteurId, recruteur.id),
        orderBy: desc(recruitmentProspects.createdAt)
      });

      console.log("Prospect trouv√©:", prospect ? `ID: ${prospect.id}` : "Non trouv√©");

      if (!prospect) {
        // Cr√©er un nouveau prospect si aucun n'existe
        console.log("Cr√©ation d'un nouveau prospect pour le recruteur", {
          nom: recruteur.nom,
          prenom: recruteur.prenom,
          email: recruteur.email,
          recruteurId: recruteur.id
        });
        
        try {
          const newProspect = await db.insert(recruitmentProspects).values({
            prenom: recruteur.prenom,
            nom: recruteur.nom,
            email: recruteur.email,
            telephone: recruteur.telephone,
            codePostal: recruteur.codePostal || "",
            ville: recruteur.ville || "",
            source: "interne",
            stade: "formation",
            recruteurId: recruteur.id,
            formationCompletee: false,
            formulaireComplete: false,
            pieceIdentiteDeposee: false,
            ribDepose: false,
            contratGenere: false,
            contratSigne: false
          }).returning();
          
          console.log("Nouveau prospect cr√©√© avec succ√®s:", newProspect[0] ? `ID: ${newProspect[0].id}` : "Erreur: pas de prospect retourn√©");
          return res.json(newProspect[0]);
        } catch (err) {
          console.error("ERREUR lors de la cr√©ation du prospect:", err);
          return res.status(500).json({ message: "Impossible de cr√©er un nouveau prospect" });
        }
      }

      res.json(prospect);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration du prospect actuel:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Mettre √† jour le statut de formation d'un prospect
  app.put("/api/recruitment/prospects/formation-status", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      const { scoreQuiz, formationCompletee } = req.body;
      
      const userId = req.user.id; // R√©cup√©rer de mani√®re s√ªre l'ID de l'utilisateur
      console.log(`=== DEBUG FORMATION STATUS ===`);
      console.log(`Mise √† jour du statut de formation pour l'utilisateur ${userId}`);
      console.log(`Score quiz: ${scoreQuiz}, Formation compl√©t√©e: ${formationCompletee}`);
      
      // V√©rifier si l'utilisateur est un recruteur
      let recruteur = await db.query.recruiters.findFirst({
        where: eq(recruiters.userId, userId)
      });
      
      console.log("Recruteur trouv√©:", recruteur ? `ID: ${recruteur.id}` : "Non trouv√©");

      // Si l'utilisateur n'est pas un recruteur, tenter de cr√©er un profil recruteur
      if (!recruteur) {
        console.log(`Tentative de cr√©ation d'un profil recruteur pour l'utilisateur ${userId}`);
        
        // G√©n√©rer un code vendeur unique
        const codeVendeur = `FR${Math.floor(10000000 + Math.random() * 90000000)}`;
        
        // Cr√©er un profil recruteur basique
        const username = req.user.username;
        const prenom = username.split('@')[0]; // Utiliser la partie avant @ comme pr√©nom
        
        try {
          const [newRecruteur] = await db.insert(recruiters).values({
            userId: userId,
            nom: "Utilisateur",
            prenom: prenom,
            email: username,
            telephone: "",
            codeVendeur,
            niveau: 1,
            statut: "actif",
            niveauExperience: "debutant",
            commissionBase: 5
          }).returning();
          
          recruteur = newRecruteur;
        } catch (err) {
          console.error("Erreur lors de la cr√©ation du profil recruteur:", err);
          return res.status(500).json({ message: "Impossible de cr√©er un profil recruteur" });
        }
      }
      
      // S'assurer que le recruteur existe
      if (!recruteur) {
        return res.status(404).json({ message: "Profil de recruteur non trouv√© ou impossible √† cr√©er" });
      }

      // Trouver le prospect associ√©
      const prospect = await db.query.recruitmentProspects.findFirst({
        where: eq(recruitmentProspects.recruteurId, recruteur.id),
        orderBy: desc(recruitmentProspects.createdAt)
      });

      if (!prospect) {
        return res.status(404).json({ message: "Prospect non trouv√©" });
      }

      // Mettre √† jour le statut de formation
      const updatedProspect = await db.update(recruitmentProspects)
        .set({
          formationCompletee: formationCompletee,
          scoreQuiz: scoreQuiz,
          dateFormation: new Date(),
          stade: formationCompletee ? "formulaire" : "formation"
        })
        .where(eq(recruitmentProspects.id, prospect.id))
        .returning();

      // Ajouter une activit√© de formation
      await db.insert(recruitmentActivities).values({
        type: "formation",
        titre: "Formation compl√©t√©e",
        description: `Formation compl√©t√©e avec un score de ${scoreQuiz}%`,
        dateActivite: new Date(),
        resultat: formationCompletee ? "positif" : "√† suivre",
        prospectId: prospect.id,
        recruteurId: recruteur.id
      });

      res.json(updatedProspect[0]);
    } catch (error) {
      console.error("Erreur lors de la mise √† jour du statut de formation:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Soumettre le formulaire de recrutement avec les documents
  app.post("/api/recruitment/prospects/submit-form", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      // Cette endpoint devrait traiter l'upload de fichiers (pieceIdentite et rib)
      // Dans une impl√©mentation r√©elle, vous utiliseriez multer ou un autre middleware pour g√©rer les fichiers
      const { adresse, codePostal, ville } = req.body;

      // V√©rifier si l'utilisateur est un recruteur
      const recruteur = await db.query.recruiters.findFirst({
        where: eq(recruiters.userId, req.user.id)
      });

      if (!recruteur) {
        return res.status(404).json({ message: "Profil de recruteur non trouv√©" });
      }

      // Trouver le prospect associ√©
      const prospect = await db.query.recruitmentProspects.findFirst({
        where: eq(recruitmentProspects.recruteurId, recruteur.id),
        orderBy: desc(recruitmentProspects.createdAt)
      });

      if (!prospect) {
        return res.status(404).json({ message: "Prospect non trouv√©" });
      }

      // Mettre √† jour les informations du formulaire
      const updatedProspect = await db.update(recruitmentProspects)
        .set({
          codePostal,
          ville,
          formulaireComplete: true,
          pieceIdentiteDeposee: true,
          ribDepose: true,
          stade: "contrat",
          updatedAt: new Date()
        })
        .where(eq(recruitmentProspects.id, prospect.id))
        .returning();

      // Pour l'instant, nous simulons le stockage des documents
      // Ajouter des entr√©es dans la base de donn√©es pour les documents
      // Dans une impl√©mentation compl√®te, nous utiliserions multer pour g√©rer les fichiers
      
      // Simuler l'enregistrement de la pi√®ce d'identit√©
      await db.insert(recruitmentDocuments).values({
        type: DOCUMENT_TYPES.PIECE_IDENTITE,
        nomFichier: "piece_identite.jpg",
        cheminFichier: `/uploads/prospects/${prospect.id}/piece_identite.jpg`, 
        tailleFichier: 150000, // Taille simul√©e en octets
        prospectId: prospect.id,
        uploadedById: req.user.id
      });
      
      // Simuler l'enregistrement du RIB
      await db.insert(recruitmentDocuments).values({
        type: DOCUMENT_TYPES.RIB,
        nomFichier: "rib.pdf",
        cheminFichier: `/uploads/prospects/${prospect.id}/rib.pdf`,
        tailleFichier: 80000, // Taille simul√©e en octets
        prospectId: prospect.id,
        uploadedById: req.user.id
      });
      
      // Si l'adresse est fournie, simuler un justificatif de domicile
      if (adresse) {
        await db.insert(recruitmentDocuments).values({
          type: DOCUMENT_TYPES.JUSTIFICATIF_DOMICILE,
          nomFichier: "justificatif_domicile.pdf",
          cheminFichier: `/uploads/prospects/${prospect.id}/justificatif_domicile.pdf`,
          tailleFichier: 120000, // Taille simul√©e en octets
          prospectId: prospect.id,
          uploadedById: req.user.id
        });
      }

      // Ajouter une activit√© pour le formulaire compl√©t√©
      await db.insert(recruitmentActivities).values({
        type: "formulaire",
        titre: "Formulaire compl√©t√©",
        description: "Formulaire de recrutement et documents soumis",
        dateActivite: new Date(),
        resultat: "positif",
        prospectId: prospect.id,
        recruteurId: recruteur.id
      });

      // Aussi mettre √† jour les informations du recruteur
      await db.update(recruiters)
        .set({
          adresse,
          codePostal,
          ville,
          updatedAt: new Date()
        })
        .where(eq(recruiters.id, recruteur.id));

      res.json(updatedProspect[0]);
    } catch (error) {
      console.error("Erreur lors de la soumission du formulaire:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Soumettre le contrat sign√©
  app.post("/api/recruitment/prospects/submit-contract", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      // V√©rifier si l'utilisateur est un recruteur
      const recruteur = await db.query.recruiters.findFirst({
        where: eq(recruiters.userId, req.user.id)
      });

      if (!recruteur) {
        return res.status(404).json({ message: "Profil de recruteur non trouv√©" });
      }

      // Trouver le prospect associ√©
      const prospect = await db.query.recruitmentProspects.findFirst({
        where: eq(recruitmentProspects.recruteurId, recruteur.id),
        orderBy: desc(recruitmentProspects.createdAt)
      });
      
      if (!prospect) {
        return res.status(404).json({ message: "Prospect non trouv√©" });
      }
      
      // Dans un cas r√©el, on g√©rerait l'upload du contrat sign√© ici
      // Pour l'instant, nous simulons l'enregistrement du contrat sign√©
      await db.insert(recruitmentDocuments).values({
        type: DOCUMENT_TYPES.CONTRAT_SIGNE,
        nomFichier: "contrat_signe.pdf",
        cheminFichier: `/uploads/prospects/${prospect.id}/contrat_signe.pdf`,
        tailleFichier: 250000, // Taille simul√©e en octets
        prospectId: prospect.id,
        uploadedById: req.user.id
      });

      // Mettre √† jour les informations du contrat
      const updatedProspect = await db.update(recruitmentProspects)
        .set({
          contratSigne: true,
          dateSignatureContrat: new Date(),
          stade: "actif",
          updatedAt: new Date()
        })
        .where(eq(recruitmentProspects.id, prospect.id))
        .returning();

      // Ajouter une activit√© pour le contrat sign√©
      await db.insert(recruitmentActivities).values({
        type: "contrat",
        titre: "Contrat sign√©",
        description: "Contrat de recrutement sign√© et valid√©",
        dateActivite: new Date(),
        resultat: "positif",
        prospectId: prospect.id,
        recruteurId: recruteur.id
      });

      // Mettre √† jour le statut du recruteur √† actif
      await db.update(recruiters)
        .set({
          statut: "actif",
          dateActivation: new Date(),
          updatedAt: new Date()
        })
        .where(eq(recruiters.id, recruteur.id));

      res.json(updatedProspect[0]);
    } catch (error) {
      console.error("Erreur lors de la soumission du contrat:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Endpoint pour g√©n√©rer le contrat
  app.post("/api/recruitment/prospects/generate-contract", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      // V√©rifier si l'utilisateur est un recruteur
      const recruteur = await db.query.recruiters.findFirst({
        where: eq(recruiters.userId, req.user.id)
      });

      if (!recruteur) {
        return res.status(404).json({ message: "Profil de recruteur non trouv√©" });
      }

      // Trouver le prospect associ√©
      const prospect = await db.query.recruitmentProspects.findFirst({
        where: eq(recruitmentProspects.recruteurId, recruteur.id),
        orderBy: desc(recruitmentProspects.createdAt)
      });

      if (!prospect) {
        return res.status(404).json({ message: "Prospect non trouv√©" });
      }
      
      // Importer la fonction de g√©n√©ration de contrat
      const { generateContratHTML } = await import("../client/src/lib/document-templates");
      
      // G√©n√©rer le contenu HTML du contrat avec les donn√©es du prospect
      const contratHTML = generateContratHTML({
        nom: prospect.nom,
        prenom: prospect.prenom,
        adresse: prospect.adresse || "",
        codePostal: prospect.codePostal || "",
        ville: prospect.ville || "",
        nomSociete: prospect.nomSociete || `${prospect.prenom} ${prospect.nom}`,
        siret: prospect.siret || "",
        codeVendeur: prospect.codeVendeur || ""
      });
      
      // Taille r√©elle du contenu
      const tailleFichier = Buffer.byteLength(contratHTML, 'utf8');
      const nomFichier = `contrat_${prospect.nom.toLowerCase()}_${prospect.prenom.toLowerCase()}.html`;
      
      // Enregistrer le contrat dans la base de donn√©es
      const [document] = await db.insert(recruitmentDocuments).values({
        type: DOCUMENT_TYPES.CONTRAT_VIERGE,
        nomFichier,
        contenuDocument: contratHTML,
        tailleFichier,
        prospectId: prospect.id,
        uploadedById: req.user.id,
        dateUpload: new Date()
      }).returning();

      // Mettre √† jour le statut pour indiquer que le contrat a √©t√© g√©n√©r√©
      const updatedProspect = await db.update(recruitmentProspects)
        .set({
          contratGenere: true,
          updatedAt: new Date()
        })
        .where(eq(recruitmentProspects.id, prospect.id))
        .returning();

      // Ajouter une activit√© pour la g√©n√©ration de contrat
      await db.insert(recruitmentActivities).values({
        type: "contrat",
        titre: "Contrat g√©n√©r√©",
        description: "Contrat de recrutement g√©n√©r√© et pr√™t √† √™tre sign√©",
        dateActivite: new Date(),
        resultat: "en attente",
        prospectId: prospect.id,
        recruteurId: recruteur.id
      });

      res.json({
        prospect: updatedProspect[0],
        document
      });
    } catch (error) {
      console.error("Erreur lors de la g√©n√©ration du contrat:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // R√©cup√©rer les documents d'un prospect
  app.get("/api/recruitment/prospects/:id/documents", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      const { id } = req.params;
      const prospectId = parseInt(id);
      
      if (isNaN(prospectId)) {
        return res.status(400).json({ message: "ID prospect invalide" });
      }
      
      // V√©rifier si l'utilisateur a les droits sur ce prospect
      const recruteur = await db.query.recruiters.findFirst({
        where: eq(recruiters.userId, req.user.id)
      });
      
      if (!recruteur) {
        return res.status(403).json({ message: "Acc√®s non autoris√©" });
      }
      
      // R√©cup√©rer le prospect pour v√©rifier l'acc√®s
      const prospect = await db.query.recruitmentProspects.findFirst({
        where: eq(recruitmentProspects.id, prospectId)
      });
      
      if (!prospect) {
        return res.status(404).json({ message: "Prospect non trouv√©" });
      }
      
      // V√©rifier que ce prospect est bien li√© au recruteur connect√©
      if (prospect.recruteurId !== recruteur.id) {
        return res.status(403).json({ message: "Vous n'avez pas acc√®s √† ce prospect" });
      }
      
      // R√©cup√©rer tous les documents associ√©s au prospect
      const documents = await db.select().from(recruitmentDocuments)
        .where(eq(recruitmentDocuments.prospectId, prospectId))
        .orderBy(desc(recruitmentDocuments.createdAt));
      
      res.json(documents);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des documents:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });
  
  // R√©cup√©rer un document sp√©cifique
  app.get("/api/recruitment/documents/:id", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      const { id } = req.params;
      const documentId = parseInt(id);
      
      if (isNaN(documentId)) {
        return res.status(400).json({ message: "ID document invalide" });
      }
      
      // R√©cup√©rer le document
      const document = await db.query.recruitmentDocuments.findFirst({
        where: eq(recruitmentDocuments.id, documentId)
      });
      
      if (!document) {
        return res.status(404).json({ message: "Document non trouv√©" });
      }
      
      // V√©rifier si l'utilisateur a les droits sur ce document via le recruteur
      const recruteur = await db.query.recruiters.findFirst({
        where: eq(recruiters.userId, req.user.id)
      });
      
      if (!recruteur) {
        return res.status(403).json({ message: "Acc√®s non autoris√©" });
      }
      
      // V√©rifier que le recruteur a acc√®s √† ce prospect/document
      const prospectDetails = await db.query.recruitmentProspects.findFirst({
        where: eq(recruitmentProspects.id, document.prospectId)
      });
      
      if (!prospectDetails || prospectDetails.recruteurId !== recruteur.id) {
        return res.status(403).json({ message: "Vous n'avez pas acc√®s √† ce document" });
      }
      
      // Dans une impl√©mentation r√©elle, nous renverrions le fichier
      // Pour l'instant, on renvoie juste les m√©tadonn√©es
      res.json({
        ...document,
        url: `/api/files${document.cheminFichier}` // URL simul√©e pour acc√©der au fichier
      });
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration du document:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Endpoint pour g√©n√©rer l'attestation de formation et l'attestation sur l'honneur
  app.post("/api/recruitment/prospects/generate-attestation", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      let { prospectId } = req.body;
      
      // Si l'ID du prospect n'est pas fourni, chercher le prospect pour l'utilisateur actuel
      if (!prospectId) {
        // V√©rifier si l'utilisateur est un recruteur
        const recruteur = await db.query.recruiters.findFirst({
          where: eq(recruiters.userId, req.user.id)
        });

        if (!recruteur) {
          return res.status(404).json({ message: "Profil de recruteur non trouv√©" });
        }

        // Trouver le prospect associ√© au recruteur connect√©
        const userProspect = await db.query.recruitmentProspects.findFirst({
          where: eq(recruitmentProspects.recruteurId, recruteur.id),
          orderBy: desc(recruitmentProspects.createdAt)
        });
        
        if (!userProspect) {
          return res.status(404).json({ message: "Prospect non trouv√© pour cet utilisateur" });
        }
        
        prospectId = userProspect.id;
      }
      
      // R√©cup√©rer le prospect
      const prospect = await db.query.recruitmentProspects.findFirst({
        where: eq(recruitmentProspects.id, prospectId)
      });
      
      if (!prospect) {
        return res.status(404).json({ message: "Prospect non trouv√©" });
      }
      
      // V√©rifier si la formation a bien √©t√© compl√©t√©e
      if (!prospect.formationCompletee || !prospect.scoreQuiz || prospect.scoreQuiz < 80) {
        return res.status(400).json({ 
          message: "Le prospect n'a pas compl√©t√© la formation avec un score suffisant" 
        });
      }

      // G√©n√©rer le contenu HTML de l'attestation
      const dateFormation = prospect.dateFormation 
        ? new Date(prospect.dateFormation).toLocaleDateString('fr-FR') 
        : new Date().toLocaleDateString('fr-FR');
      
      const dateAttestation = new Date().toLocaleDateString('fr-FR');
      const scoreQuiz = prospect.scoreQuiz;
      const nomComplet = `${prospect.prenom} ${prospect.nom}`;
      
      // Importer les fonctions de g√©n√©ration de documents
      const { generateAttestationHTML, generateAttestationSurHonneurHTML } = await import("../client/src/lib/document-templates");
      
      // G√©n√©rer l'attestation de formation
      const attestationFormationHTML = generateAttestationHTML(
        prospect.nom,
        prospect.prenom,
        dateFormation,
        dateAttestation
      );
      
      // G√©n√©rer aussi l'attestation sur l'honneur
      const attestationSurHonneurHTML = generateAttestationSurHonneurHTML({
        nom: prospect.nom,
        prenom: prospect.prenom,
        adresse: prospect.adresse || "",
        codePostal: prospect.codePostal || "",
        ville: prospect.ville || "",
        nomSociete: prospect.nomSociete || `${prospect.prenom} ${prospect.nom}`,
        siret: prospect.siret || "",
        codeVendeur: prospect.codeVendeur || ""
      });
      
      // 1. Enregistrer l'attestation de formation
      const [attestationFormation] = await db.insert(recruitmentDocuments)
        .values({
          type: DOCUMENT_TYPES.ATTESTATION_FORMATION,
          nomFichier: `attestation_formation_${prospect.nom.toLowerCase()}_${prospect.prenom.toLowerCase()}.html`,
          contenuDocument: attestationFormationHTML,
          cheminFichier: `/documents/attestations/${prospectId}_attestation_formation.html`,
          tailleFichier: Buffer.byteLength(attestationFormationHTML, 'utf8'),
          prospectId: prospect.id,
          uploadedById: req.user.id,
          estSigne: false,
          dateUpload: new Date()
        })
        .returning();
      
      // 2. Enregistrer l'attestation sur l'honneur
      const [attestationSurHonneur] = await db.insert(recruitmentDocuments)
        .values({
          type: DOCUMENT_TYPES.ATTESTATION_SUR_HONNEUR,
          nomFichier: `attestation_sur_honneur_${prospect.nom.toLowerCase()}_${prospect.prenom.toLowerCase()}.html`,
          contenuDocument: attestationSurHonneurHTML,
          cheminFichier: `/documents/attestations/${prospectId}_attestation_sur_honneur.html`,
          tailleFichier: Buffer.byteLength(attestationSurHonneurHTML, 'utf8'),
          prospectId: prospect.id,
          uploadedById: req.user.id,
          estSigne: false,
          dateUpload: new Date()
        })
        .returning();
      
      // Ajouter une activit√© pour les attestations
      await db.insert(recruitmentActivities)
        .values({
          type: "document",
          titre: "Attestations g√©n√©r√©es",
          description: "Attestation de formation et attestation sur l'honneur g√©n√©r√©es",
          dateActivite: new Date(),
          prospectId: prospect.id,
          recruteurId: prospect.recruteurId
        });
      
      res.status(201).json({
        message: "Attestations g√©n√©r√©es avec succ√®s",
        attestationFormation,
        attestationSurHonneur
      });
    } catch (error) {
      console.error("Erreur lors de la g√©n√©ration de l'attestation:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });
  
  // Endpoint pour la signature √©lectronique
  app.post("/api/recruitment/documents/sign", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      const { documentId, signatureData } = req.body;
      
      if (!documentId) {
        return res.status(400).json({ message: "ID de document requis" });
      }
      
      if (!signatureData || !signatureData.signature) {
        return res.status(400).json({ message: "Donn√©es de signature requises" });
      }
      
      // R√©cup√©rer le document
      const document = await db.query.recruitmentDocuments.findFirst({
        where: eq(recruitmentDocuments.id, documentId)
      });
      
      if (!document) {
        return res.status(404).json({ message: "Document non trouv√©" });
      }
      
      if (document.estSigne) {
        return res.status(400).json({ message: "Le document est d√©j√† sign√©" });
      }
      
      // Construire les m√©tadonn√©es de signature s√©curis√©es
      const signatureMetadata = {
        signature: signatureData.signature,
        date: new Date().toISOString(),
        ipAddress: req.ip || "unknown",
        userAgent: req.headers["user-agent"] || "unknown",
        userId: req.user.id,
        timestamp: Date.now(),
        // Cr√©er un identifiant unique pour la signature
        signatureId: crypto.randomUUID ? crypto.randomUUID() : `sig-${Date.now()}-${Math.random().toString(36).substring(2, 10)}`
      };
      
      // Mettre √† jour le document
      const updatedDocument = await db.update(recruitmentDocuments)
        .set({
          estSigne: true,
          signatureData: signatureMetadata,
          dateSignature: new Date()
        })
        .where(eq(recruitmentDocuments.id, documentId))
        .returning();
      
      // Si c'est une attestation de formation, rien d'autre √† faire
      // Si c'est un contrat, mettre √† jour le statut du prospect
      if (document.type === DOCUMENT_TYPES.CONTRAT_SIGNE) {
        await db.update(recruitmentProspects)
          .set({
            contratSigne: true,
            dateSignatureContrat: new Date(),
            stade: "actif", // Mettre √† jour le stade si n√©cessaire
            updatedAt: new Date()
          })
          .where(eq(recruitmentProspects.id, document.prospectId));
        
        // Ajouter une activit√© pour la signature du contrat
        await db.insert(recruitmentActivities)
          .values({
            type: "contrat",
            titre: "Contrat sign√©",
            description: "Le contrat a √©t√© sign√© √©lectroniquement",
            dateActivite: new Date(),
            prospectId: document.prospectId,
            recruteurId: req.user.id // √Ä adapter selon votre mod√®le
          });
      }
      
      res.json({
        message: "Document sign√© avec succ√®s",
        document: updatedDocument[0]
      });
    } catch (error) {
      console.error("Erreur lors de la signature du document:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Route pour envoyer un document par email
  app.post("/api/recruitment/documents/send-email", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      const { documentId, recipientEmail, recipientName } = req.body;
      
      if (!documentId || !recipientEmail) {
        return res.status(400).json({ message: "ID de document et email du destinataire requis" });
      }
      
      // V√©rifier que l'email est valide
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(recipientEmail)) {
        return res.status(400).json({ message: "Format d'email invalide" });
      }
      
      // R√©cup√©rer le document
      const document = await db.query.recruitmentDocuments.findFirst({
        where: eq(recruitmentDocuments.id, documentId)
      });
      
      if (!document) {
        return res.status(404).json({ message: "Document non trouv√©" });
      }
      
      // Importer le service d'email
      const { sendAttestationEmail } = await import('./email-service');
      
      // Envoyer l'email
      const success = await sendAttestationEmail(document, recipientEmail, recipientName || "");
      
      if (success) {
        // Ajouter une activit√© pour tracer l'envoi
        await db.insert(recruitmentActivities)
          .values({
            type: "email",
            titre: "Attestation envoy√©e par email",
            description: `Attestation envoy√©e √† ${recipientEmail}`,
            dateActivite: new Date(),
            prospectId: document.prospectId,
            recruteurId: req.user.id
          });
        
        return res.status(200).json({ 
          message: "Document envoy√© par email avec succ√®s",
          success: true
        });
      } else {
        return res.status(500).json({ 
          message: "Erreur lors de l'envoi du document par email", 
          success: false 
        });
      }
    } catch (error) {
      console.error("Erreur lors de l'envoi du document par email:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Route pour acc√©der aux documents directement
  // Endpoint d'administration pour v√©rifier et corriger les relations de donn√©es
  app.post("/api/admin/fix-data-relations", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      const { validateAndFixDataRelations } = await import("./data-validation");
      await validateAndFixDataRelations();
      
      res.json({ success: true, message: "V√©rification et correction des donn√©es effectu√©es avec succ√®s" });
    } catch (error) {
      console.error("Erreur lors de la correction des donn√©es:", error);
      res.status(500).json({ message: "Erreur serveur lors de la correction des donn√©es" });
    }
  });
  
  app.get("/documents/:type/:id", async (req: Request, res: Response) => {
    try {
      const { type, id } = req.params;
      
      if (!type || !id) {
        return res.status(400).json({ message: "Type et ID de document requis" });
      }
      
      // Extraire l'ID du prospect et le type de document
      const documentId = parseInt(id.split('_')[0]);
      if (isNaN(documentId)) {
        return res.status(400).json({ message: "ID de document invalide" });
      }
      
      // R√©cup√©rer le document depuis la base de donn√©es
      const document = await db.query.recruitmentDocuments.findFirst({
        where: eq(recruitmentDocuments.id, documentId)
      });
      
      if (!document) {
        return res.status(404).json({ message: "Document non trouv√©" });
      }
      
      // D√©terminer le type MIME
      let contentType = 'application/octet-stream';
      
      if (type === 'attestations') {
        contentType = 'text/html';
      } else if (id.endsWith('.pdf')) {
        contentType = 'application/pdf';
      } else if (id.endsWith('.html')) {
        contentType = 'text/html';
      }
      
      // Si le document a un contenu stock√© directement dans la base de donn√©es
      if (document.contenuDocument) {
        // Pour les attestations, convertir en PDF si demand√©
        if (type === 'attestations' && req.query.format === 'pdf') {
          // Ici on renvoie simplement le HTML car la conversion sera faite c√¥t√© client
          // avec une biblioth√®que comme jsPDF ou html2pdf
          return res.setHeader('Content-Type', contentType)
                    .setHeader('Content-Disposition', `attachment; filename="${document.nomFichier.replace('.html', '.pdf')}"`)
                    .send(document.contenuDocument);
        }
        
        // Renvoyer le contenu du document
        return res.setHeader('Content-Type', contentType).send(document.contenuDocument);
      }
      
      // Si le document est stock√© comme fichier (non impl√©ment√© actuellement)
      return res.status(404).json({ message: "Contenu du document non disponible" });
    } catch (error) {
      console.error("Erreur lors de l'acc√®s au document:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Routes publiques pour le tunnel de recrutement (accessible sans authentification)
  // V√©rification du token pour acc√©der aux donn√©es d'un prospect
  async function verifyProspectToken(prospectId: number, token: string) {
    if (!prospectId || !token) {
      return false;
    }
    
    const prospect = await db.query.recruitmentProspects.findFirst({
      where: eq(recruitmentProspects.id, prospectId)
    });
    
    if (!prospect) {
      return false;
    }
    
    // Cr√©er un token bas√© sur l'ID, l'email et un sel unique (date de cr√©ation)
    const dateStr = prospect.createdAt.toISOString().split('T')[0];
    const expectedToken = crypto
      .createHash('sha256')
      .update(`${prospect.id}-${prospect.email}-${dateStr}`)
      .digest('hex');
    
    return token === expectedToken;
  }
  
  // R√©cup√©rer les donn√©es d'un prospect par son ID (avec v√©rification de token)
  app.get("/api/recruitment/public/prospects/:id", async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      const { token } = req.query;
      const prospectId = parseInt(id);
      
      if (isNaN(prospectId)) {
        return res.status(400).json({ message: "ID prospect invalide" });
      }
      
      if (!token || typeof token !== 'string') {
        return res.status(401).json({ message: "Token d'acc√®s requis" });
      }
      
      // V√©rifier le token
      const isValidToken = await verifyProspectToken(prospectId, token);
      if (!isValidToken) {
        return res.status(401).json({ message: "Token d'acc√®s invalide" });
      }
      
      // R√©cup√©rer les donn√©es du prospect
      const prospect = await db.query.recruitmentProspects.findFirst({
        where: eq(recruitmentProspects.id, prospectId)
      });
      
      if (!prospect) {
        return res.status(404).json({ message: "Prospect non trouv√©" });
      }
      
      res.json(prospect);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des donn√©es du prospect:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });
  
  // Mettre √† jour le statut de formation d'un prospect
  app.put("/api/recruitment/public/prospects/:id/formation-status", async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      const { token } = req.query;
      const { formationCompletee } = req.body;
      const prospectId = parseInt(id);
      
      if (isNaN(prospectId)) {
        return res.status(400).json({ message: "ID prospect invalide" });
      }
      
      if (!token || typeof token !== 'string') {
        return res.status(401).json({ message: "Token d'acc√®s requis" });
      }
      
      // V√©rifier le token
      const isValidToken = await verifyProspectToken(prospectId, token);
      if (!isValidToken) {
        return res.status(401).json({ message: "Token d'acc√®s invalide" });
      }
      
      // Mettre √† jour le statut de formation
      const [updatedProspect] = await db.update(recruitmentProspects)
        .set({
          formationCompletee: formationCompletee,
          dateFormation: new Date()
        })
        .where(eq(recruitmentProspects.id, prospectId))
        .returning();
      
      res.json(updatedProspect);
    } catch (error) {
      console.error("Erreur lors de la mise √† jour du statut de formation:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });
  
  // Soumettre le formulaire d'inscription
  app.post("/api/recruitment/public/prospects/:id/submit-form", upload.fields([
    { name: 'pieceIdentite', maxCount: 1 },
    { name: 'rib', maxCount: 1 }
  ]), async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      const { token } = req.body;
      const { adresse, codePostal, ville } = req.body;
      const files = req.files as { [fieldname: string]: Express.Multer.File[] };
      const prospectId = parseInt(id);
      
      if (isNaN(prospectId)) {
        return res.status(400).json({ message: "ID prospect invalide" });
      }
      
      if (!token || typeof token !== 'string') {
        return res.status(401).json({ message: "Token d'acc√®s requis" });
      }
      
      // V√©rifier le token
      const isValidToken = await verifyProspectToken(prospectId, token);
      if (!isValidToken) {
        return res.status(401).json({ message: "Token d'acc√®s invalide" });
      }
      
      // V√©rifier les donn√©es requises
      if (!adresse || !codePostal || !ville) {
        return res.status(400).json({ message: "Adresse, code postal et ville sont requis" });
      }
      
      // V√©rifier les fichiers
      const pieceIdentite = files?.pieceIdentite?.[0];
      const rib = files?.rib?.[0];
      
      if (!pieceIdentite || !rib) {
        return res.status(400).json({ message: "Pi√®ce d'identit√© et RIB sont requis" });
      }
      
      // Mettre √† jour les informations du prospect (ignorer adresse qui ne fait pas partie du sch√©ma)
      const [updatedProspect] = await db.update(recruitmentProspects)
        .set({
          codePostal,
          ville,
          pieceIdentiteDeposee: true,
          ribDepose: true,
          formulaireComplete: true,
          // Pas de dateFormulaire dans le sch√©ma
        })
        .where(eq(recruitmentProspects.id, prospectId))
        .returning();
      
      // Stocker les fichiers (ici on simule le stockage)
      // Dans une impl√©mentation r√©elle, nous sauvegarderions les fichiers dans un syst√®me de stockage
      
      // Ajouter les documents dans la base de donn√©es
      await db.insert(recruitmentDocuments).values([
        {
          prospectId,
          type: 'piece_identite',
          nomFichier: pieceIdentite.originalname,
          cheminFichier: `/uploads/prospects/${prospectId}/piece_identite/${pieceIdentite.originalname}`,
          tailleFichier: pieceIdentite.size,
          dateUpload: new Date(),
          uploadedById: 0, // 0 pour signifier que c'est le prospect lui-m√™me
          contenuDocument: null, // Le contenu n'est pas stock√© en base
          estSigne: null, // Pas besoin de signature pour ces documents
          signatureData: null,
          dateSignature: null
        },
        {
          prospectId,
          type: 'rib',
          nomFichier: rib.originalname,
          cheminFichier: `/uploads/prospects/${prospectId}/rib/${rib.originalname}`,
          tailleFichier: rib.size,
          dateUpload: new Date(),
          uploadedById: 0,
          contenuDocument: null,
          estSigne: null,
          signatureData: null,
          dateSignature: null
        }
      ]);
      
      res.json(updatedProspect);
    } catch (error) {
      console.error("Erreur lors de la soumission du formulaire:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });
  
  // G√©n√©rer un contrat pour un prospect
  app.post("/api/recruitment/public/prospects/:id/generate-contract", async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      const { token } = req.query;
      const prospectId = parseInt(id);
      
      if (isNaN(prospectId)) {
        return res.status(400).json({ message: "ID prospect invalide" });
      }
      
      if (!token || typeof token !== 'string') {
        return res.status(401).json({ message: "Token d'acc√®s requis" });
      }
      
      // V√©rifier le token
      const isValidToken = await verifyProspectToken(prospectId, token);
      if (!isValidToken) {
        return res.status(401).json({ message: "Token d'acc√®s invalide" });
      }
      
      // R√©cup√©rer les donn√©es du prospect
      const prospect = await db.query.recruitmentProspects.findFirst({
        where: eq(recruitmentProspects.id, prospectId)
      });
      
      if (!prospect) {
        return res.status(404).json({ message: "Prospect non trouv√©" });
      }
      
      // V√©rifier que le formulaire a √©t√© compl√©t√©
      if (!prospect.formulaireComplete) {
        return res.status(400).json({ message: "Le formulaire doit √™tre compl√©t√© avant de g√©n√©rer le contrat" });
      }
      
      // G√©n√©rer le contrat (ici on simule un contrat simple pour l'exemple)
      const contenuContrat = `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="UTF-8">
        <title>Contrat de Vendeur</title>
        <style>
          body { font-family: Arial, sans-serif; margin: 40px; line-height: 1.5; }
          .header { text-align: center; margin-bottom: 30px; }
          h1 { color: #333; font-size: 24px; text-align: center; margin-bottom: 30px; }
          .content { margin-bottom: 30px; }
          .signature-section { margin-top: 60px; display: flex; justify-content: space-between; }
          .signature-box { width: 45%; }
          .signature-line { border-top: 1px solid #333; margin-top: 70px; margin-bottom: 10px; }
          .footer { margin-top: 60px; font-size: 12px; text-align: center; color: #666; }
        </style>
      </head>
      <body>
        <div class="header">
          <h1>CONTRAT DE VENDEUR IND√âPENDANT</h1>
        </div>
        
        <div class="content">
          <p>Entre les soussign√©s :</p>
          <p><strong>Synergie Marketing Group</strong>, repr√©sent√©e par son directeur, ci-apr√®s d√©nomm√©e "la Soci√©t√©"</p>
          <p>Et</p>
          <p><strong>${prospect.prenom} ${prospect.nom}</strong>, demeurant ${prospect.codePostal || ""} ${prospect.ville || ""}, ci-apr√®s d√©nomm√© "le Vendeur Ind√©pendant"</p>
          
          <h2>Article 1 - Objet du contrat</h2>
          <p>Le pr√©sent contrat a pour objet de d√©finir les conditions dans lesquelles le Vendeur Ind√©pendant s'engage √† commercialiser les produits et services propos√©s par la Soci√©t√©.</p>
          
          <h2>Article 2 - Statut du Vendeur Ind√©pendant</h2>
          <p>Le Vendeur Ind√©pendant exerce son activit√© en toute ind√©pendance. Il n'est li√© √† la Soci√©t√© par aucun lien de subordination.</p>
          
          <h2>Article 3 - Obligations du Vendeur Ind√©pendant</h2>
          <p>Le Vendeur Ind√©pendant s'engage √† :</p>
          <ul>
            <li>Respecter la r√©glementation en vigueur</li>
            <li>Suivre les formations obligatoires</li>
            <li>Pr√©senter de mani√®re loyale et transparente les produits et services</li>
            <li>Ne pas faire de promesses non autoris√©es par la Soci√©t√©</li>
          </ul>
          
          <h2>Article 4 - R√©mun√©ration</h2>
          <p>Le Vendeur Ind√©pendant percevra des commissions selon le bar√®me en vigueur au moment de la vente.</p>
          
          <h2>Article 5 - Dur√©e</h2>
          <p>Le pr√©sent contrat est conclu pour une dur√©e ind√©termin√©e √† compter de sa signature.</p>
        </div>
        
        <div class="signature-section">
          <div class="signature-box">
            <p>Pour la Soci√©t√© :</p>
            <div class="signature-line"></div>
            <p>Date : ${new Date().toLocaleDateString('fr-FR')}</p>
          </div>
          
          <div class="signature-box">
            <p>Le Vendeur Ind√©pendant :</p>
            <div class="signature-line"></div>
            <p>Date : </p>
          </div>
        </div>
        
        <div class="footer">
          <p>Synergie Marketing Group - Contrat de Vendeur Ind√©pendant - ${new Date().getFullYear()}</p>
        </div>
      </body>
      </html>
      `;
      
      // Enregistrer le contrat dans la base de donn√©es
      const [document] = await db.insert(recruitmentDocuments).values({
        prospectId,
        type: 'contrat_vierge',
        nomFichier: `contrat_vendeur_${prospect.prenom.toLowerCase()}_${prospect.nom.toLowerCase()}.html`,
        cheminFichier: `/uploads/prospects/${prospectId}/contrat/contrat_vendeur.html`,
        tailleFichier: contenuContrat.length,
        dateUpload: new Date(),
        uploadedById: 0,
        contenuDocument: contenuContrat,
        estSigne: false,
        signatureData: null,
        dateSignature: null
      }).returning();
      
      // Mettre √† jour le statut du prospect
      await db.update(recruitmentProspects)
        .set({
          contratGenere: true,
          // Pas de dateContratGenere dans le sch√©ma
        })
        .where(eq(recruitmentProspects.id, prospectId));
      
      res.json({ 
        success: true, 
        message: "Contrat g√©n√©r√© avec succ√®s", 
        document 
      });
    } catch (error) {
      console.error("Erreur lors de la g√©n√©ration du contrat:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });
  
  // G√©n√©rer une attestation de formation pour un prospect
  app.post("/api/recruitment/public/prospects/:id/generate-attestation", async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      const { token } = req.query;
      const prospectId = parseInt(id);
      
      if (isNaN(prospectId)) {
        return res.status(400).json({ message: "ID prospect invalide" });
      }
      
      if (!token || typeof token !== 'string') {
        return res.status(401).json({ message: "Token d'acc√®s requis" });
      }
      
      // V√©rifier le token
      const isValidToken = await verifyProspectToken(prospectId, token);
      if (!isValidToken) {
        return res.status(401).json({ message: "Token d'acc√®s invalide" });
      }
      
      // R√©cup√©rer les donn√©es du prospect
      const prospect = await db.query.recruitmentProspects.findFirst({
        where: eq(recruitmentProspects.id, prospectId)
      });
      
      if (!prospect) {
        return res.status(404).json({ message: "Prospect non trouv√©" });
      }
      
      // V√©rifier si la formation a √©t√© compl√©t√©e
      if (!prospect.formationCompletee) {
        return res.status(400).json({ 
          message: "Le prospect n'a pas encore compl√©t√© sa formation" 
        });
      }
      
      // G√©n√©rer le contenu HTML de l'attestation
      const dateFormation = prospect.dateFormation 
        ? new Date(prospect.dateFormation).toLocaleDateString('fr-FR') 
        : new Date().toLocaleDateString('fr-FR');
      
      const dateAttestation = new Date().toLocaleDateString('fr-FR');
      
      // Importer les fonctions de g√©n√©ration de documents
      const { generateAttestationHTML, generateAttestationSurHonneurHTML } = await import("../client/src/lib/document-templates");
      
      // G√©n√©rer l'attestation de formation
      const attestationFormationHTML = generateAttestationHTML(
        prospect.nom,
        prospect.prenom,
        dateFormation,
        dateAttestation
      );
      
      // G√©n√©rer aussi l'attestation sur l'honneur
      const attestationSurHonneurHTML = generateAttestationSurHonneurHTML({
        nom: prospect.nom,
        prenom: prospect.prenom,
        adresse: prospect.adresse || "",
        codePostal: prospect.codePostal || "",
        ville: prospect.ville || "",
        nomSociete: prospect.nomSociete || `${prospect.prenom} ${prospect.nom}`,
        siret: prospect.siret || "",
        codeVendeur: prospect.codeVendeur || ""
      });
      
      // Trouver un administrateur pour l'attribution du document
      const adminUser = await db.query.users.findFirst({
        where: eq(users.role, "admin")
      });
      
      if (!adminUser) {
        return res.status(500).json({ message: "Erreur: aucun administrateur trouv√© dans le syst√®me" });
      }
      
      // 1. Enregistrer l'attestation de formation
      const [attestationFormation] = await db.insert(recruitmentDocuments)
        .values({
          type: DOCUMENT_TYPES.ATTESTATION_FORMATION,
          nomFichier: `attestation_formation_${prospect.nom.toLowerCase()}_${prospect.prenom.toLowerCase()}.html`,
          contenuDocument: attestationFormationHTML,
          cheminFichier: `/documents/attestations/${prospectId}_attestation_formation.html`,
          tailleFichier: Buffer.byteLength(attestationFormationHTML, 'utf8'),
          prospectId: prospect.id,
          uploadedById: adminUser.id,
          estSigne: false,
          dateUpload: new Date()
        })
        .returning();
      
      // 2. Enregistrer l'attestation sur l'honneur
      const [attestationSurHonneur] = await db.insert(recruitmentDocuments)
        .values({
          type: DOCUMENT_TYPES.ATTESTATION_SUR_HONNEUR,
          nomFichier: `attestation_sur_honneur_${prospect.nom.toLowerCase()}_${prospect.prenom.toLowerCase()}.html`,
          contenuDocument: attestationSurHonneurHTML,
          cheminFichier: `/documents/attestations/${prospectId}_attestation_sur_honneur.html`,
          tailleFichier: Buffer.byteLength(attestationSurHonneurHTML, 'utf8'),
          prospectId: prospect.id,
          uploadedById: adminUser.id,
          estSigne: false,
          dateUpload: new Date()
        })
        .returning();
      
      // Ajouter une activit√© pour les attestations
      await db.insert(recruitmentActivities)
        .values({
          type: "document",
          titre: "Attestations g√©n√©r√©es",
          description: "Attestation de formation et attestation sur l'honneur g√©n√©r√©es",
          dateActivite: new Date(),
          prospectId: prospect.id,
          recruteurId: prospect.recruteurId || null
        });
      
      res.json({ 
        success: true, 
        message: "Attestations g√©n√©r√©es avec succ√®s", 
        attestationFormation,
        attestationSurHonneur
      });
    } catch (error) {
      console.error("Erreur lors de la g√©n√©ration des attestations:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });
  
  // Soumettre un contrat sign√©
  app.post("/api/recruitment/public/prospects/:id/submit-contract", upload.single('contratSigne'), async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      const { token } = req.body;
      const file = req.file;
      const prospectId = parseInt(id);
      
      if (isNaN(prospectId)) {
        return res.status(400).json({ message: "ID prospect invalide" });
      }
      
      if (!token || typeof token !== 'string') {
        return res.status(401).json({ message: "Token d'acc√®s requis" });
      }
      
      // V√©rifier le token
      const isValidToken = await verifyProspectToken(prospectId, token);
      if (!isValidToken) {
        return res.status(401).json({ message: "Token d'acc√®s invalide" });
      }
      
      if (!file) {
        return res.status(400).json({ message: "Contrat sign√© requis" });
      }
      
      // R√©cup√©rer les donn√©es du prospect
      const prospect = await db.query.recruitmentProspects.findFirst({
        where: eq(recruitmentProspects.id, prospectId)
      });
      
      if (!prospect) {
        return res.status(404).json({ message: "Prospect non trouv√©" });
      }
      
      // Enregistrer le contrat sign√© dans la base de donn√©es
      const [document] = await db.insert(recruitmentDocuments).values({
        prospectId,
        type: 'contrat_signe',
        nomFichier: file.originalname,
        cheminFichier: `/uploads/prospects/${prospectId}/contrat/contrat_signe.pdf`,
        tailleFichier: file.size,
        dateUpload: new Date(),
        uploadedById: 0,
        contenuDocument: null, // Le fichier PDF n'est pas stock√© comme contenu
        estSigne: true,
        signatureData: null, // La signature est dans le fichier lui-m√™me
        dateSignature: new Date()
      }).returning();
      
      // Mettre √† jour le statut du prospect
      await db.update(recruitmentProspects)
        .set({
          contratSigne: true,
          dateContratSigne: new Date(),
          statut: "Vendeur"
        })
        .where(eq(recruitmentProspects.id, prospectId));
      
      res.json({ 
        success: true, 
        message: "Contrat sign√© soumis avec succ√®s", 
        document 
      });
    } catch (error) {
      console.error("Erreur lors de la soumission du contrat sign√©:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });
  
  // R√©cup√©rer les documents d'un prospect (version publique)
  app.get("/api/recruitment/public/prospects/:id/documents", async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      const { token, type } = req.query;
      const prospectId = parseInt(id);
      
      if (isNaN(prospectId)) {
        return res.status(400).json({ message: "ID prospect invalide" });
      }
      
      if (!token || typeof token !== 'string') {
        return res.status(401).json({ message: "Token d'acc√®s requis" });
      }
      
      // V√©rifier le token
      const isValidToken = await verifyProspectToken(prospectId, token);
      if (!isValidToken) {
        return res.status(401).json({ message: "Token d'acc√®s invalide" });
      }
      
      // Construire la requ√™te de base
      let query = db.select().from(recruitmentDocuments)
        .where(eq(recruitmentDocuments.prospectId, prospectId));
      
      // Filtrer par type si sp√©cifi√©
      if (type && typeof type === 'string') {
        query = query.where(eq(recruitmentDocuments.type, type as DocumentType));
      }
      
      // Ex√©cuter la requ√™te
      const documents = await query.orderBy(desc(recruitmentDocuments.createdAt));
      
      res.json(documents);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des documents:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });
  
  // Signer un document √©lectroniquement (version publique)
  app.post("/api/recruitment/public/documents/sign", async (req: Request, res: Response) => {
    try {
      const { documentId, signatureData } = req.body;
      
      if (!documentId || !signatureData?.signature) {
        return res.status(400).json({ message: "ID de document et signature requis" });
      }
      
      // R√©cup√©rer le document
      const document = await db.query.recruitmentDocuments.findFirst({
        where: eq(recruitmentDocuments.id, documentId)
      });
      
      if (!document) {
        return res.status(404).json({ message: "Document non trouv√©" });
      }
      
      // V√©rifier qu'il n'est pas d√©j√† sign√©
      if (document.estSigne) {
        return res.status(400).json({ message: "Ce document est d√©j√† sign√©" });
      }
      
      // Mettre √† jour le document avec la signature
      const [updatedDocument] = await db.update(recruitmentDocuments)
        .set({
          estSigne: true,
          signatureData: signatureData,
          dateSignature: new Date()
        })
        .where(eq(recruitmentDocuments.id, documentId))
        .returning();
      
      // Si c'est une attestation de formation, mettre √† jour le statut
      if (document.type === 'attestation_formation') {
        await db.update(recruitmentProspects)
          .set({
            attestationSignee: true,
            dateAttestationSignee: new Date()
          })
          .where(eq(recruitmentProspects.id, document.prospectId));
      }
      
      res.json({ 
        success: true, 
        message: "Document sign√© avec succ√®s", 
        document: updatedDocument 
      });
    } catch (error) {
      console.error("Erreur lors de la signature du document:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });
  
  // Envoyer un document par email (version publique)
  app.post("/api/recruitment/public/documents/email", async (req: Request, res: Response) => {
    try {
      const { documentId, recipientEmail, recipientName } = req.body;
      
      if (!documentId || !recipientEmail) {
        return res.status(400).json({ message: "ID de document et email du destinataire requis" });
      }
      
      // R√©cup√©rer le document
      const document = await db.query.recruitmentDocuments.findFirst({
        where: eq(recruitmentDocuments.id, documentId)
      });
      
      if (!document) {
        return res.status(404).json({ message: "Document non trouv√©" });
      }
      
      // R√©cup√©rer le prospect associ√©
      const prospect = await db.query.recruitmentProspects.findFirst({
        where: eq(recruitmentProspects.id, document.prospectId)
      });
      
      if (!prospect) {
        return res.status(404).json({ message: "Prospect associ√© non trouv√©" });
      }
      
      // Envoyer l'email avec le document
      // Utiliser le service d'email pour envoyer le document (ex: sendAttestationEmail)
      const emailService = await import('./email-service');
      const emailSent = await emailService.sendAttestationEmail(
        document,
        recipientEmail,
        recipientName || `${prospect.prenom} ${prospect.nom}`
      );
      
      if (!emailSent) {
        return res.status(500).json({ message: "Erreur lors de l'envoi de l'email" });
      }
      
      res.json({ 
        success: true, 
        message: "Document envoy√© par email avec succ√®s" 
      });
    } catch (error) {
      console.error("Erreur lors de l'envoi du document par email:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // API Routes pour les param√®tres de l'application
  app.get("/api/settings", async (req: Request, res: Response) => {
    try {
      // R√©cup√©rer tous les param√®tres de l'application
      const settings = await db.select().from(appSettings);
      
      // Transformer la liste en objet pour faciliter l'acc√®s c√¥t√© client
      const settingsObject: Record<string, any> = {};
      settings.forEach(setting => {
        settingsObject[setting.key] = setting.value;
      });
      
      // Ajouter l'URL du logo s'il existe
      if (settingsObject["logo"]) {
        settingsObject.logoUrl = `/uploads/${settingsObject["logo"]}`;
      }
      
      return res.json(settingsObject);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des param√®tres de l'application:", error);
      return res.status(500).json({ message: "Erreur serveur" });
    }
  });
  
  // Route pour mettre √† jour un param√®tre
  app.post("/api/settings/:key", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      const { key } = req.params;
      const { value, description } = req.body;
      
      // V√©rifier si le param√®tre existe d√©j√†
      const existingSetting = await db
        .select()
        .from(appSettings)
        .where(eq(appSettings.key, key))
        .limit(1)
        .then(rows => rows[0]);
      
      if (existingSetting) {
        // Mettre √† jour le param√®tre existant
        const [updatedSetting] = await db
          .update(appSettings)
          .set({ 
            value, 
            description,
            updatedAt: new Date() 
          })
          .where(eq(appSettings.key, key))
          .returning();
        
        return res.json(updatedSetting);
      } else {
        // Cr√©er un nouveau param√®tre
        const [newSetting] = await db
          .insert(appSettings)
          .values({
            key,
            value,
            description,
            updatedAt: new Date()
          })
          .returning();
        
        return res.status(201).json(newSetting);
      }
    } catch (error) {
      console.error("Erreur lors de la mise √† jour du param√®tre:", error);
      return res.status(500).json({ message: "Erreur serveur" });
    }
  });
  
  // Route pour t√©l√©charger un logo
  app.post("/api/settings/upload/logo", (req: Request, res: Response, next: NextFunction) => {
    console.log("Requ√™te de t√©l√©chargement de logo re√ßue");
    
    // Utiliser un middleware interm√©diaire pour capturer les erreurs multer
    upload.single('logo')(req, res, (err) => {
      if (err) {
        console.error("Erreur Multer lors de l'upload:", err);
        if (err.code === 'LIMIT_FILE_SIZE') {
          return res.status(400).json({ message: "Fichier trop volumineux (max 5MB)" });
        } else if (err instanceof multer.MulterError) {
          return res.status(400).json({ message: `Erreur d'upload: ${err.message}` });
        } else {
          return res.status(400).json({ message: err.message || "Erreur lors du t√©l√©chargement" });
        }
      }
      
      // Continuer le processus apr√®s r√©ussite de l'upload
      handleLogoUpload(req, res);
    });
  });
  
  // Fonction s√©par√©e pour g√©rer le fichier une fois upload√©
  async function handleLogoUpload(req: Request, res: Response) {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Non authentifi√©" });
      }
      
      if (!req.file) {
        return res.status(400).json({ message: "Aucun fichier n'a √©t√© t√©l√©charg√©" });
      }
      
      console.log("Fichier re√ßu:", req.file);
      
      // Le nom du fichier t√©l√©charg√©
      const filename = req.file.filename;
      
      // Mettre √† jour le param√®tre de logo
      const existingSetting = await db
        .select()
        .from(appSettings)
        .where(eq(appSettings.key, "logo"))
        .limit(1)
        .then(rows => rows[0]);
      
      if (existingSetting) {
        // Si un logo existait d√©j√†, supprimer l'ancien fichier
        if (existingSetting.value) {
          const oldLogoPath = path.join(__dirname, '../uploads', existingSetting.value);
          console.log(`V√©rification de l'ancien logo √†: ${oldLogoPath}`);
          if (fs.existsSync(oldLogoPath)) {
            fs.unlinkSync(oldLogoPath);
            console.log("Ancien logo supprim√©");
          }
        }
        
        console.log("Mise √† jour du param√®tre de logo existant");
        // Mettre √† jour le param√®tre existant
        const [updatedSetting] = await db
          .update(appSettings)
          .set({ 
            value: filename,
            updatedAt: new Date() 
          })
          .where(eq(appSettings.key, "logo"))
          .returning();
        
        return res.json({ 
          ...updatedSetting,
          logoUrl: `/uploads/${filename}`
        });
      } else {
        console.log("Cr√©ation d'un nouveau param√®tre de logo");
        // Cr√©er un nouveau param√®tre
        const [newSetting] = await db
          .insert(appSettings)
          .values({
            key: "logo",
            value: filename,
            description: "Logo de l'entreprise",
            updatedAt: new Date()
          })
          .returning();
        
        return res.status(201).json({ 
          ...newSetting,
          logoUrl: `/uploads/${filename}`
        });
      }
    } catch (error) {
      console.error("Erreur lors du traitement du logo:", error);
      return res.status(500).json({ message: "Erreur serveur" });
    }
  }
  
  // Route pour servir les fichiers t√©l√©charg√©s
  app.use('/uploads', (req, res, next) => {
    // S√©curit√©: √©viter le "directory traversal"
    const fileName = req.path.replace(/\.\./g, '').replace(/^\/+/, '');
    const filePath = path.join(__dirname, '../uploads', fileName);
    
    // V√©rifier si le fichier existe
    if (fs.existsSync(filePath)) {
      res.sendFile(filePath);
    } else {
      next();
    }
  });

  // Create and return the HTTP server
  // API pour obtenir les statistiques des codes vendeur
  app.get("/api/vendor-codes", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      // R√©cup√©rer tous les codes vendeur distincts avec le nombre de clients associ√©s
      const vendorCodesWithCount = await db.execute(sql`
        SELECT 
          code_vendeur, 
          COUNT(*) as client_count 
        FROM clients 
        WHERE code_vendeur IS NOT NULL 
        GROUP BY code_vendeur 
        ORDER BY client_count DESC
      `);
      
      // Convertir le r√©sultat en format JSON standard
      const result = (vendorCodesWithCount as any).rows.map((row: any) => ({
        codeVendeur: row.code_vendeur,
        clientCount: parseInt(row.client_count)
      }));
      
      res.json(result);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des codes vendeur:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });
  
  // API pour obtenir les statistiques des codes vendeur
  app.get("/api/vendor-codes", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      // R√©cup√©rer tous les codes vendeur distincts avec le nombre de clients associ√©s
      const vendorCodesWithCount = await db.execute(sql`
        SELECT 
          code_vendeur, 
          COUNT(*) as client_count 
        FROM clients 
        WHERE code_vendeur IS NOT NULL 
        GROUP BY code_vendeur 
        ORDER BY client_count DESC
      `);
      
      // Convertir le r√©sultat en format JSON standard
      const result = (vendorCodesWithCount as any).rows.map((row: any) => ({
        codeVendeur: row.code_vendeur,
        clientCount: parseInt(row.client_count)
      }));
      
      res.json(result);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des codes vendeur:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // API pour obtenir le top 10 des vendeurs avec leurs performances
  app.get("/api/top-vendors", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) return res.status(401).json({ message: "Non authentifi√©" });
      
      // V√©rifier si l'utilisateur est un administrateur
      const isAdmin = [1, 15].includes(req.user.id);
      
      // R√©cup√©rer les vendeurs que l'utilisateur connect√© peut voir
      let visibleVendorIds: number[] = [];
      
      if (isAdmin) {
        // Les administrateurs peuvent voir tous les vendeurs
        const allVendors = await db.select({ id: users.id }).from(users);
        visibleVendorIds = allVendors.map(vendor => vendor.id);
      } else {
        // Pour les vendeurs normaux, nous allons simplement montrer quelques vendeurs 
        // (puisque la structure de recrutement n'est pas compl√®tement impl√©ment√©e)
        
        // Ajouter l'ID de l'utilisateur connect√©
        visibleVendorIds.push(req.user.id);
        
        // R√©cup√©rer d'autres ID d'utilisateurs pour les exemples
        const otherUsersResult = await db.execute(sql`
          SELECT id FROM users WHERE id <> ${req.user.id} LIMIT 10
        `);
        
        const otherUserIds = (otherUsersResult as any).rows
          .map((row: any) => parseInt(row.id))
          .filter((id: number) => !isNaN(id));
          
        visibleVendorIds = [...visibleVendorIds, ...otherUserIds];
      }
      
      // G√©n√©rer des donn√©es d'exemple pour le top 10 des vendeurs
      const sampleData = [
        { 
          codeVendeur: "FR00123456",
          userId: visibleVendorIds[0] || 16,
          username: "exemple@synergie.fr",
          prenom: "Thomas",
          nom: "Dubois",
          clientCount: 42,
          partnersCount: 7 
        },
        { 
          codeVendeur: "FR00123457",
          userId: visibleVendorIds[1] || 2,
          username: "sophie.martin@synergie.fr",
          prenom: "Sophie",
          nom: "Martin",
          clientCount: 38,
          partnersCount: 5 
        },
        { 
          codeVendeur: "FR00123458",
          userId: visibleVendorIds[2] || 3,
          username: "lucas.bernard@synergie.fr",
          prenom: "Lucas",
          nom: "Bernard",
          clientCount: 32,
          partnersCount: 4 
        },
        { 
          codeVendeur: "FR00123459",
          userId: visibleVendorIds[3] || 4,
          username: "julie.petit@synergie.fr",
          prenom: "Julie",
          nom: "Petit",
          clientCount: 29,
          partnersCount: 3 
        },
        { 
          codeVendeur: "FR00123460",
          userId: visibleVendorIds[4] || 5,
          username: "nicolas.robert@synergie.fr",
          prenom: "Nicolas",
          nom: "Robert",
          clientCount: 26,
          partnersCount: 2 
        },
        { 
          codeVendeur: "FR00123461",
          userId: visibleVendorIds[5] || 6,
          username: "laura.richard@synergie.fr",
          prenom: "Laura",
          nom: "Richard",
          clientCount: 24,
          partnersCount: 2 
        },
        { 
          codeVendeur: "FR00123462",
          userId: visibleVendorIds[6] || 7,
          username: "maxime.durand@synergie.fr",
          prenom: "Maxime",
          nom: "Durand",
          clientCount: 22,
          partnersCount: 1 
        },
        { 
          codeVendeur: "FR00123463",
          userId: visibleVendorIds[7] || 8,
          username: "emilie.moreau@synergie.fr",
          prenom: "Emilie",
          nom: "Moreau",
          clientCount: 20,
          partnersCount: 1 
        },
        { 
          codeVendeur: "FR00123464",
          userId: visibleVendorIds[8] || 9,
          username: "alexandre.simon@synergie.fr",
          prenom: "Alexandre",
          nom: "Simon",
          clientCount: 18,
          partnersCount: 0 
        },
        { 
          codeVendeur: "FR00123465",
          userId: visibleVendorIds[9] || 10,
          username: "celine.laurent@synergie.fr",
          prenom: "C√©line",
          nom: "Laurent",
          clientCount: 15,
          partnersCount: 0 
        }
      ];
      
      res.json(sampleData);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des vendeurs:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  const httpServer = createServer(app);
  return httpServer;
}
