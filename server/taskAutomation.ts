import { db } from "@db";
import { tasks, clients } from "@shared/schema";
import { eq } from "drizzle-orm";

interface AutoTaskConfig {
  clientId: number;
  clientName: string;
  commentaire?: string;
  statusChange?: {
    newStatus: string;
    oldStatus: string;
  };
}

// Mots-cl√©s pour d√©tecter les appels
const CALL_KEYWORDS = [
  'appeler', 'rappeler', 'rappeller', 'recontacter', 't√©l√©phoner', 'joindre',
  'rappel', 'contact', 'appel', 't√©l√©phone', 'call', 'contacter'
];

// Fonction pour extraire les dates du commentaire
function extractDateFromComment(text: string): Date | null {
  if (!text) return null;
  
  // Patterns de dates possibles
  const datePatterns = [
    /(\d{1,2})\/(\d{1,2})\/(\d{4})/g, // DD/MM/YYYY ou D/M/YYYY
    /(\d{1,2})-(\d{1,2})-(\d{4})/g,  // DD-MM-YYYY ou D-M-YYYY
    /(\d{1,2})\.(\d{1,2})\.(\d{4})/g, // DD.MM.YYYY ou D.M.YYYY
    /(\d{4})-(\d{1,2})-(\d{1,2})/g   // YYYY-MM-DD
  ];
  
  const foundDates: Date[] = [];
  
  // Parcourir tous les patterns pour trouver toutes les dates
  for (const pattern of datePatterns) {
    const matches = Array.from(text.matchAll(pattern));
    
    for (const match of matches) {
      try {
        let day, month, year;
        
        if (pattern === datePatterns[3]) { // YYYY-MM-DD
          [, year, month, day] = match;
        } else { // DD/MM/YYYY formats
          [, day, month, year] = match;
        }
        
        const date = new Date(parseInt(year), parseInt(month) - 1, parseInt(day));
        if (!isNaN(date.getTime())) {
          foundDates.push(date);
        }
      } catch (error) {
        continue;
      }
    }
  }
  
  // Retourner la date la plus r√©cente (future ou pr√©sente)
  if (foundDates.length === 0) return null;
  
  // Trier les dates par ordre d√©croissant (plus r√©cente en premier)
  foundDates.sort((a, b) => b.getTime() - a.getTime());
  
  if (foundDates.length > 1) {
    console.log(`üìÖ Dates trouv√©es dans le commentaire: ${foundDates.map(d => d.toLocaleDateString('fr-FR')).join(', ')}`);
    console.log(`üìÖ Date la plus r√©cente s√©lectionn√©e: ${foundDates[0].toLocaleDateString('fr-FR')}`);
  }
  
  return foundDates[0];
}

// Fonction pour d√©tecter si le commentaire n√©cessite un appel
function isCallRequired(commentaire: string): boolean {
  if (!commentaire) return false;
  
  const lowerComment = commentaire.toLowerCase();
  return CALL_KEYWORDS.some(keyword => lowerComment.includes(keyword));
}

// Fonction pour cr√©er une t√¢che automatique bas√©e sur le commentaire
export async function createTaskFromComment(config: AutoTaskConfig): Promise<number | null> {
  if (!config.commentaire) return null;
  
  const isCall = isCallRequired(config.commentaire);
  const extractedDate = extractDateFromComment(config.commentaire);
  
  // D√©finir l'√©ch√©ance
  let echeance: Date;
  if (extractedDate) {
    echeance = extractedDate;
  } else {
    // Par d√©faut, √©ch√©ance dans 2 jours
    echeance = new Date();
    echeance.setDate(echeance.getDate() + 2);
  }
  
  const taskData = {
    userId: 1, // ID par d√©faut pour les t√¢ches automatiques (admin)
    title: isCall 
      ? `Appeler ${config.clientName}`
      : `Suivi du contrat ${config.clientName}`,
    description: config.commentaire,
    status: 'pending' as const,
    priority: 'medium' as const,
    dueDate: echeance,
    clientId: config.clientId,
    category: isCall ? 'appel' : 'suivi',
    isAutoGenerated: true,
    triggerEvent: 'comment_analysis'
  };
  
  try {
    const [newTask] = await db.insert(tasks).values(taskData).returning();
    console.log(`T√¢che automatique cr√©√©e: ${taskData.title} (ID: ${newTask.id})`);
    return newTask.id;
  } catch (error) {
    console.error('Erreur lors de la cr√©ation de la t√¢che automatique:', error);
    return null;
  }
}

// Fonction pour cr√©er une t√¢che lors d'un changement de statut vers "Post-production"
export async function createTaskFromStatusChange(config: AutoTaskConfig): Promise<number | null> {
  if (!config.statusChange || config.statusChange.newStatus !== 'post_production') {
    return null;
  }
  
  // √âch√©ance : lendemain du changement de statut
  const echeance = new Date();
  echeance.setDate(echeance.getDate() + 1);
  
  const taskData = {
    userId: 1, // ID par d√©faut pour les t√¢ches automatiques (admin)
    title: `Installation - ${config.clientName}`,
    description: `Reprendre contact avec le client pour comprendre pourquoi l'installation ne s'est pas r√©alis√©e`,
    status: 'pending' as const,
    priority: 'high' as const,
    dueDate: echeance,
    clientId: config.clientId,
    category: 'installation',
    isAutoGenerated: true,
    triggerEvent: 'status_change_post_production'
  };
  
  try {
    const [newTask] = await db.insert(tasks).values(taskData).returning();
    console.log(`T√¢che automatique post-production cr√©√©e: ${taskData.title} (ID: ${newTask.id})`);
    return newTask.id;
  } catch (error) {
    console.error('Erreur lors de la cr√©ation de la t√¢che post-production:', error);
    return null;
  }
}

// Fonction principale d'automatisation
export async function processTaskAutomation(
  clientId: number,
  options: {
    commentaire?: string;
    statusChange?: { newStatus: string; oldStatus: string };
  }
): Promise<number[]> {
  try {
    // R√©cup√©rer les informations du client
    const [client] = await db.select().from(clients).where(eq(clients.id, clientId));
    
    if (!client) {
      console.error(`Client avec ID ${clientId} non trouv√©`);
      return [];
    }
    
    const clientName = `${client.prenom} ${client.nom}`;
    const createdTaskIds: number[] = [];
    
    const config: AutoTaskConfig = {
      clientId,
      clientName,
      commentaire: options.commentaire,
      statusChange: options.statusChange
    };
    
    // Traiter la cr√©ation de t√¢che bas√©e sur le commentaire
    if (options.commentaire) {
      const taskId = await createTaskFromComment(config);
      if (taskId) {
        createdTaskIds.push(taskId);
      }
    }
    
    // Traiter la cr√©ation de t√¢che bas√©e sur le changement de statut
    if (options.statusChange) {
      const taskId = await createTaskFromStatusChange(config);
      if (taskId) {
        createdTaskIds.push(taskId);
      }
    }
    
    console.log(`Automatisation termin√©e pour ${clientName}. T√¢ches cr√©√©es: ${createdTaskIds.length}`);
    return createdTaskIds;
    
  } catch (error) {
    console.error('Erreur dans processTaskAutomation:', error);
    return [];
  }
}